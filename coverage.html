
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>perplexity: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/diogo/perplexity-go/cmd/perplexity/config.go (25.0%)</option>
				
				<option value="file1">github.com/diogo/perplexity-go/cmd/perplexity/cookies.go (84.9%)</option>
				
				<option value="file2">github.com/diogo/perplexity-go/cmd/perplexity/history.go (8.1%)</option>
				
				<option value="file3">github.com/diogo/perplexity-go/cmd/perplexity/main.go (0.0%)</option>
				
				<option value="file4">github.com/diogo/perplexity-go/cmd/perplexity/root.go (38.3%)</option>
				
				<option value="file5">github.com/diogo/perplexity-go/cmd/perplexity/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"

        "github.com/diogo/perplexity-go/internal/ui"
        "github.com/spf13/cobra"
)

var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Manage configuration interactively",
        Long: `Open an interactive menu to view and modify configuration settings.

Use arrow keys to navigate, Enter to select an option, and Esc to cancel.

Configuration options:
  - Model:     Default AI model (pplx_pro, gpt5, claude45sonnet, etc.)
  - Mode:      Search mode (fast, pro, reasoning, deep-research, default)
  - Language:  Response language (e.g., en-US, pt-BR)
  - Sources:   Search sources (web, scholar, social)
  - Streaming: Enable/disable streaming output
  - Incognito: Enable/disable history saving`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return ui.RunInteractiveConfig(cfg, cfgMgr)
        }</span>,
}

var configPathCmd = &amp;cobra.Command{
        Use:   "path",
        Short: "Show configuration file path",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                fmt.Println(cfgMgr.GetConfigFile())
                return nil
        }</span>,
}

func init() <span class="cov8" title="1">{
        configCmd.AddCommand(configPathCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/diogo/perplexity-go/internal/auth"
        "github.com/spf13/cobra"
)

var cookiesCmd = &amp;cobra.Command{
        Use:   "cookies",
        Short: "Manage authentication cookies",
        Long:  `Manage authentication cookies for Perplexity API access.`,
}

// importCookiesCmd is a root-level command for importing cookies.
var importCookiesCmd = &amp;cobra.Command{
        Use:   "import-cookies &lt;file&gt;",
        Short: "Import cookies from file",
        Long: `Import cookies from a JSON or Netscape format file.

Supported formats:
  - JSON: Browser extension export (cookies.json)
  - Netscape: curl/wget format (cookies.txt)

Example:
  perplexity import-cookies ~/Downloads/cookies.json`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                importFile := args[0]

                // Check if source file exists
                if _, err := os.Stat(importFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("file not found: %s", importFile)
                }</span>

                // Try JSON format first
                <span class="cov8" title="1">cookies, err := auth.LoadCookiesFromFile(importFile)
                if err != nil </span><span class="cov8" title="1">{
                        // Try Netscape format
                        cookies, err = auth.LoadCookiesFromNetscape(importFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse cookies (tried JSON and Netscape formats): %v", err)
                        }</span>
                }

                <span class="cov8" title="1">if len(cookies) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("no Perplexity cookies found in file")
                }</span>

                // Save to config cookie file
                <span class="cov8" title="1">if err := auth.SaveCookiesToFile(cookies, cfg.CookieFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save cookies: %v", err)
                }</span>

                <span class="cov8" title="1">render.RenderSuccess(fmt.Sprintf("Imported %d cookies to %s", len(cookies), cfg.CookieFile))

                if !auth.HasCSRFToken(cookies) </span><span class="cov8" title="1">{
                        render.RenderWarning("CSRF token not found - session may not work")
                }</span>

                <span class="cov8" title="1">return nil</span>
        },
}

var cookiesStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Check authentication status",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                cookieFile := cfg.CookieFile
                if flagCookieFile != "" </span><span class="cov0" title="0">{
                        cookieFile = flagCookieFile
                }</span>

                // Check if file exists
                <span class="cov8" title="1">if _, err := os.Stat(cookieFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        render.RenderWarning("Not authenticated")
                        render.RenderInfo(fmt.Sprintf("Cookie file not found: %s", cookieFile))
                        render.RenderInfo("Run 'perplexity import-cookies &lt;file&gt;' to import cookies")
                        return nil
                }</span>

                // Load and validate cookies
                <span class="cov8" title="1">cookies, err := auth.LoadCookiesFromFile(cookieFile)
                if err != nil </span><span class="cov0" title="0">{
                        render.RenderError(fmt.Errorf("failed to load cookies: %v", err))
                        return err
                }</span>

                <span class="cov8" title="1">if len(cookies) == 0 </span><span class="cov0" title="0">{
                        render.RenderWarning("No Perplexity cookies found in file")
                        return nil
                }</span>

                // Check for CSRF token
                <span class="cov8" title="1">if auth.HasCSRFToken(cookies) </span><span class="cov8" title="1">{
                        render.RenderSuccess("Authenticated")
                        fmt.Printf("Cookie file: %s\n", cookieFile)
                        fmt.Printf("Cookies loaded: %d\n", len(cookies))

                        // Show cookie names
                        fmt.Println("\nCookies:")
                        for _, c := range cookies </span><span class="cov8" title="1">{
                                fmt.Printf("  - %s\n", c.Name)
                        }</span>
                } else<span class="cov8" title="1"> {
                        render.RenderWarning("Cookies found but CSRF token missing")
                        render.RenderInfo("Session may be expired. Re-export cookies from browser.")
                }</span>

                <span class="cov8" title="1">return nil</span>
        },
}

var cookiesClearCmd = &amp;cobra.Command{
        Use:   "clear",
        Short: "Clear saved cookies",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if err := os.Remove(cfg.CookieFile); err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                render.RenderInfo("No cookies to clear")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to remove cookies: %v", err)</span>
                }

                <span class="cov8" title="1">render.RenderSuccess("Cookies cleared")
                return nil</span>
        },
}

var cookiesPathCmd = &amp;cobra.Command{
        Use:   "path",
        Short: "Show cookie file path",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                fmt.Println(cfg.CookieFile)
                return nil
        }</span>,
}

func init() <span class="cov8" title="1">{
        cookiesCmd.AddCommand(cookiesStatusCmd)
        cookiesCmd.AddCommand(cookiesClearCmd)
        cookiesCmd.AddCommand(cookiesPathCmd)

        // NOTE: importCookiesCmd is added to the rootCmd in root.go
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "strconv"

        "github.com/diogo/perplexity-go/internal/history"
        "github.com/spf13/cobra"
)

var (
        historyCount int
)

var historyCmd = &amp;cobra.Command{
        Use:   "history",
        Short: "View query history",
        Long:  `View and manage your query history.`,
        RunE:  runHistoryList,
}

var historyListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List recent queries",
        RunE:  runHistoryList,
}

var historySearchCmd = &amp;cobra.Command{
        Use:   "search &lt;query&gt;",
        Short: "Search history",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                reader := history.NewReader(cfg.HistoryFile)
                entries, err := reader.Search(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to search history: %v", err)
                }</span>

                <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                        render.RenderInfo("No matching entries found")
                        return nil
                }</span>

                <span class="cov0" title="0">render.RenderTitle(fmt.Sprintf("Search Results: %d matches", len(entries)))
                for i, entry := range entries </span><span class="cov0" title="0">{
                        fmt.Printf("[%d] %s\n", i+1, entry.Timestamp.Format("2006-01-02 15:04"))
                        fmt.Printf("    Query: %s\n", entry.Query)
                        fmt.Printf("    Mode: %s, Model: %s\n", entry.Mode, entry.Model)
                        fmt.Println()
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

var historyShowCmd = &amp;cobra.Command{
        Use:   "show &lt;index&gt;",
        Short: "Show details of a history entry",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                idx, err := strconv.Atoi(args[0])
                if err != nil || idx &lt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid index: %s", args[0])
                }</span>

                <span class="cov0" title="0">reader := history.NewReader(cfg.HistoryFile)
                entries, err := reader.ReadAll()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read history: %v", err)
                }</span>

                <span class="cov0" title="0">if idx &gt; len(entries) </span><span class="cov0" title="0">{
                        return fmt.Errorf("index out of range: %d (max: %d)", idx, len(entries))
                }</span>

                <span class="cov0" title="0">entry := entries[idx-1]
                render.RenderTitle("History Entry")
                fmt.Printf("Timestamp: %s\n", entry.Timestamp.Format("2006-01-02 15:04:05"))
                fmt.Printf("Query:     %s\n", entry.Query)
                fmt.Printf("Mode:      %s\n", entry.Mode)
                fmt.Printf("Model:     %s\n", entry.Model)
                if entry.Response != "" </span><span class="cov0" title="0">{
                        fmt.Println("\nResponse:")
                        render.RenderStyledResponse(entry.Response)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

var historyClearCmd = &amp;cobra.Command{
        Use:   "clear",
        Short: "Clear all history",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                reader := history.NewReader(cfg.HistoryFile)
                if err := reader.Clear(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear history: %v", err)
                }</span>
                <span class="cov0" title="0">render.RenderSuccess("History cleared")
                return nil</span>
        },
}

func runHistoryList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        reader := history.NewReader(cfg.HistoryFile)

        var entries []any
        var err error

        if historyCount &gt; 0 </span><span class="cov0" title="0">{
                entries, err = readLastN(reader, historyCount)
        }</span> else<span class="cov0" title="0"> {
                entries, err = readLastN(reader, 20)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read history: %v", err)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                render.RenderInfo("No history entries")
                return nil
        }</span>

        <span class="cov0" title="0">render.RenderTitle("Recent Queries")
        for i, e := range entries </span><span class="cov0" title="0">{
                entry := e.(historyEntry)
                fmt.Printf("[%d] %s\n", i+1, entry.Timestamp)
                fmt.Printf("    %s\n", entry.Query)
                if entry.Mode != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    Mode: %s", entry.Mode)
                        if entry.Model != "" </span><span class="cov0" title="0">{
                                fmt.Printf(", Model: %s", entry.Model)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type historyEntry struct {
        Timestamp string
        Query     string
        Mode      string
        Model     string
}

func readLastN(reader *history.Reader, n int) ([]any, error) <span class="cov0" title="0">{
        entries, err := reader.ReadLast(n)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]any, len(entries))
        for i, e := range entries </span><span class="cov0" title="0">{
                result[i] = historyEntry{
                        Timestamp: e.Timestamp.Format("2006-01-02 15:04"),
                        Query:     e.Query,
                        Mode:      e.Mode,
                        Model:     e.Model,
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func init() <span class="cov8" title="1">{
        historyCmd.AddCommand(historyListCmd)
        historyCmd.AddCommand(historySearchCmd)
        historyCmd.AddCommand(historyShowCmd)
        historyCmd.AddCommand(historyClearCmd)

        historyCmd.Flags().IntVarP(&amp;historyCount, "count", "n", 20, "Number of entries to show")
        historyListCmd.Flags().IntVarP(&amp;historyCount, "count", "n", 20, "Number of entries to show")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package main is the entry point for the perplexity CLI.
package main

import (
        "os"
)

func main() <span class="cov0" title="0">{
        if err := Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/diogo/perplexity-go/internal/auth"
        "github.com/mattn/go-isatty"
        "github.com/diogo/perplexity-go/internal/config"
        "github.com/diogo/perplexity-go/internal/history"
        "github.com/diogo/perplexity-go/internal/ui"
        "github.com/diogo/perplexity-go/pkg/client"
        "github.com/diogo/perplexity-go/pkg/models"
        "github.com/spf13/cobra"
)

var (
        // Flags
        flagModel      string
        flagMode       string
        flagSources    string
        flagLanguage   string
        flagStream     bool
        flagNoStream   bool
        flagIncognito  bool
        flagOutputFile string
        flagInputFile  string
        flagCookieFile string
        flagVerbose    bool

        // Global config
        cfg     *config.Config
        cfgMgr  *config.Manager
        render  *ui.Renderer
)

// rootCmd represents the base command.
var rootCmd = &amp;cobra.Command{
        Use:   "perplexity [query]",
        Short: "Perplexity AI CLI - Search with AI",
        Long: `Perplexity CLI is a command-line interface for Perplexity AI.

It allows you to perform AI-powered searches directly from your terminal
with support for multiple models, streaming output, and file attachments.

The query can be provided as command-line arguments, from a file (-f), or via stdin (pipe).

Examples:
  perplexity "What is the capital of France?"
  perplexity "Explain quantum computing" --model gpt5 --mode pro
  perplexity "Latest news on AI" --sources web,scholar --stream
  echo "What is Go?" | perplexity
  perplexity -f prompt.md --mode pro
  perplexity -f question.txt -o answer.md`,
        Args: cobra.ArbitraryArgs,
        RunE: runQuery,
}

// Execute runs the root command.
func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Query flags
        rootCmd.Flags().StringVarP(&amp;flagModel, "model", "m", "", "AI model to use (pplx_pro, gpt5, claude45sonnet, etc.)")
        rootCmd.Flags().StringVar(&amp;flagMode, "mode", "", "Search mode (fast, pro, reasoning, deep-research, default)")
        rootCmd.Flags().StringVarP(&amp;flagSources, "sources", "s", "", "Search sources (web,scholar,social)")
        rootCmd.Flags().StringVarP(&amp;flagLanguage, "language", "l", "", "Response language (e.g., en-US, pt-BR)")
        rootCmd.Flags().BoolVar(&amp;flagStream, "stream", false, "Enable streaming output")
        rootCmd.Flags().BoolVar(&amp;flagNoStream, "no-stream", false, "Disable streaming output")
        rootCmd.Flags().BoolVarP(&amp;flagIncognito, "incognito", "i", false, "Don't save to history")
        rootCmd.Flags().StringVarP(&amp;flagOutputFile, "output", "o", "", "Save response to file")
        rootCmd.Flags().StringVarP(&amp;flagInputFile, "file", "f", "", "Read query from file (takes precedence over args/stdin)")
        rootCmd.Flags().StringVarP(&amp;flagCookieFile, "cookies", "c", "", "Path to cookies.json file")
        rootCmd.Flags().BoolVarP(&amp;flagVerbose, "verbose", "v", false, "Verbose output")

        // Add subcommands
        rootCmd.AddCommand(configCmd)
        rootCmd.AddCommand(historyCmd)
        rootCmd.AddCommand(cookiesCmd)
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(importCookiesCmd)
}</span>

func initConfig() <span class="cov0" title="0">{
        var err error

        // Initialize config manager
        cfgMgr, err = config.NewManager()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error initializing config: %v\n", err)
                os.Exit(1)
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err = cfgMgr.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                os.Exit(1)
        }</span>

        // Initialize renderer
        <span class="cov0" title="0">render, err = ui.NewRenderer()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error initializing renderer: %v\n", err)
                os.Exit(1)
        }</span>
}

func runQuery(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        var query string
        var err error

        // Priority: -f/--file &gt; args &gt; stdin
        // 1. Check if -f/--file flag is provided
        if flagInputFile != "" </span><span class="cov0" title="0">{
                query, err = getQueryFromFile(flagInputFile)
                if err != nil </span><span class="cov0" title="0">{
                        render.RenderError(err)
                        return err
                }</span>
        }

        // 2. If query is still empty, try args or stdin
        <span class="cov8" title="1">if query == "" </span><span class="cov8" title="1">{
                isTerminal := isatty.IsTerminal(os.Stdin.Fd()) || isatty.IsCygwinTerminal(os.Stdin.Fd())
                query, err = getQueryFromInput(args, os.Stdin, isTerminal)
                if err != nil </span><span class="cov0" title="0">{
                        render.RenderError(err)
                        return err
                }</span>
        }

        // If query is still empty, show help
        <span class="cov8" title="1">if query == "" </span><span class="cov8" title="1">{
                return cmd.Help()
        }</span>

        // Determine cookie file
        <span class="cov8" title="1">cookieFile := cfg.CookieFile
        if flagCookieFile != "" </span><span class="cov0" title="0">{
                cookieFile = flagCookieFile
        }</span>

        // Check if cookies exist
        <span class="cov8" title="1">if _, err := os.Stat(cookieFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                render.RenderError(fmt.Errorf("cookies file not found: %s", cookieFile))
                render.RenderInfo("Run 'perplexity import-cookies &lt;file&gt;' to import cookies from browser")
                return fmt.Errorf("no cookies found")
        }</span>

        // Load cookies
        <span class="cov0" title="0">cookies, err := auth.LoadCookiesFromFile(cookieFile)
        if err != nil </span><span class="cov0" title="0">{
                render.RenderError(fmt.Errorf("failed to load cookies: %v", err))
                return err
        }</span>

        // Create client
        <span class="cov0" title="0">cli, err := client.NewWithCookies(cookies)
        if err != nil </span><span class="cov0" title="0">{
                render.RenderError(fmt.Errorf("failed to create client: %v", err))
                return err
        }</span>
        <span class="cov0" title="0">defer cli.Close()

        // Build search options
        opts := buildSearchOptions(query)

        // Setup context with cancellation
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle interrupt
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-sigCh
                cancel()
        }</span>()

        // Determine if streaming
        <span class="cov0" title="0">streaming := cfg.Streaming
        if flagStream </span><span class="cov0" title="0">{
                streaming = true
        }</span>
        <span class="cov0" title="0">if flagNoStream </span><span class="cov0" title="0">{
                streaming = false
        }</span>
        <span class="cov0" title="0">opts.Stream = streaming

        if flagVerbose </span><span class="cov0" title="0">{
                render.RenderInfo(fmt.Sprintf("Query: %s", query))
                render.RenderInfo(fmt.Sprintf("Mode: %s, Model: %s", opts.Mode, opts.Model))
                render.RenderInfo(fmt.Sprintf("Streaming: %v", streaming))
                render.NewLine()
        }</span>

        <span class="cov0" title="0">var responseText string

        if streaming </span><span class="cov0" title="0">{
                // Streaming mode
                ch, err := cli.SearchStream(ctx, opts)
                if err != nil </span><span class="cov0" title="0">{
                        render.RenderError(err) // Render error from stream initiation
                        return err
                }</span>

                <span class="cov0" title="0">var fullResponse strings.Builder
                var allWebResults []models.WebResult
                for chunk := range ch </span><span class="cov0" title="0">{
                        if chunk.Error != nil </span><span class="cov0" title="0">{ // Handle all chunk errors
                                if chunk.Error == context.Canceled </span><span class="cov0" title="0">{
                                        render.NewLine()
                                        render.RenderWarning("Search cancelled")
                                        break</span> // Exit loop on cancel
                                }
                                // Report other errors
                                <span class="cov0" title="0">render.RenderError(chunk.Error)
                                return chunk.Error</span>
                        }

                        // For new step-based format, only render FINAL step
                        <span class="cov0" title="0">if chunk.StepType == "FINAL" &amp;&amp; chunk.Text != "" </span><span class="cov0" title="0">{
                                // Render as markdown instead of raw text
                                if err := render.RenderStyledResponse(chunk.Text); err != nil </span><span class="cov0" title="0">{
                                        render.RenderStreamChunk(chunk)
                                }</span>
                                <span class="cov0" title="0">fullResponse.WriteString(chunk.Text)
                                allWebResults = append(allWebResults, chunk.WebResults...)</span>
                        } else<span class="cov0" title="0"> if chunk.StepType == "" </span><span class="cov0" title="0">{
                                // Legacy format - render as stream
                                render.RenderStreamChunk(chunk)
                                if chunk.Delta != "" </span><span class="cov0" title="0">{
                                        fullResponse.WriteString(chunk.Delta)
                                }</span> else<span class="cov0" title="0"> if chunk.Text != "" </span><span class="cov0" title="0">{
                                        fullResponse.WriteString(chunk.Text)
                                }</span>
                        }
                }
                <span class="cov0" title="0">render.NewLine()

                // Post-stream rendering of the full accumulated response (with new styling/markdown)
                if fullResponse.Len() &gt; 0 </span><span class="cov0" title="0">{
                        if err := render.RenderStyledResponse(fullResponse.String()); err != nil </span><span class="cov0" title="0">{
                                // If final styled rendering fails, the raw stream output is still there.
                                render.RenderError(fmt.Errorf("failed to render final response: %w", err))
                        }</span>
                }

                // Render web results if any
                <span class="cov0" title="0">if len(allWebResults) &gt; 0 </span><span class="cov0" title="0">{
                        render.RenderWebResults(allWebResults)
                }</span>

                <span class="cov0" title="0">responseText = fullResponse.String()</span>
        } else<span class="cov0" title="0"> {
                // Non-streaming mode with spinner
                done := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        frame := 0
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-done:<span class="cov0" title="0">
                                        render.ClearLine()
                                        return</span>
                                case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0">
                                        render.RenderSpinner(frame)
                                        frame++</span>
                                }
                        }
                }()

                <span class="cov0" title="0">resp, err := cli.Search(ctx, opts)
                close(done)

                if err != nil </span><span class="cov0" title="0">{
                        if err == context.Canceled </span><span class="cov0" title="0">{
                                render.RenderWarning("Search cancelled")
                                return nil
                        }</span>
                        <span class="cov0" title="0">render.RenderError(err)
                        return err</span>
                }

                <span class="cov0" title="0">if err := render.RenderResponse(resp); err != nil </span><span class="cov0" title="0">{
                        render.RenderError(err)
                        return err
                }</span>
                <span class="cov0" title="0">responseText = resp.Text</span>
        }

        // Save to output file if specified
        <span class="cov0" title="0">if flagOutputFile != "" </span><span class="cov0" title="0">{
                if err := os.WriteFile(flagOutputFile, []byte(responseText), 0644); err != nil </span><span class="cov0" title="0">{
                        render.RenderError(fmt.Errorf("failed to save output: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        render.RenderSuccess(fmt.Sprintf("Saved to %s", flagOutputFile))
                }</span>
        }

        // Save to history if not incognito
        <span class="cov0" title="0">if !flagIncognito &amp;&amp; !cfg.Incognito </span><span class="cov0" title="0">{
                hw, err := history.NewWriter(cfg.HistoryFile)
                if err == nil </span><span class="cov0" title="0">{
                        hw.Append(models.HistoryEntry{
                                Query:    query,
                                Mode:     string(opts.Mode),
                                Model:    string(opts.Model),
                                Response: truncateResponse(responseText, 500),
                        })
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func buildSearchOptions(query string) models.SearchOptions <span class="cov8" title="1">{
        opts := models.DefaultSearchOptions(query)

        // Apply config defaults
        opts.Model = cfg.DefaultModel
        opts.Mode = cfg.DefaultMode
        opts.Language = cfg.DefaultLanguage
        opts.Sources = cfg.DefaultSources
        opts.Incognito = cfg.Incognito

        // Override with flags
        if flagModel != "" </span><span class="cov8" title="1">{
                opts.Model = models.Model(flagModel)
        }</span>
        <span class="cov8" title="1">if flagMode != "" </span><span class="cov8" title="1">{
                opts.Mode = models.Mode(flagMode)
        }</span>
        <span class="cov8" title="1">if flagLanguage != "" </span><span class="cov8" title="1">{
                opts.Language = flagLanguage
        }</span>
        <span class="cov8" title="1">if flagSources != "" </span><span class="cov8" title="1">{
                sources := strings.Split(flagSources, ",")
                opts.Sources = make([]models.Source, 0, len(sources))
                for _, s := range sources </span><span class="cov8" title="1">{
                        opts.Sources = append(opts.Sources, models.Source(strings.TrimSpace(s)))
                }</span>
        }
        <span class="cov8" title="1">if flagIncognito </span><span class="cov8" title="1">{
                opts.Incognito = true
        }</span>

        <span class="cov8" title="1">return opts</span>
}

func truncateResponse(s string, maxLen int) string <span class="cov8" title="1">{
        if len(s) &lt;= maxLen </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return s[:maxLen] + "..."</span>
}

// getQueryFromInput extracts the query from command-line args or stdin.
// This function is exported for testing purposes.
func getQueryFromInput(args []string, stdin io.Reader, isTerminal bool) (string, error) <span class="cov8" title="1">{
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                return strings.Join(args, " "), nil
        }</span>

        // If stdin is not a terminal, try to read from it
        <span class="cov8" title="1">if !isTerminal </span><span class="cov8" title="1">{
                data, err := io.ReadAll(stdin)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed to read from stdin: %w", err)
                }</span>
                <span class="cov8" title="1">return strings.TrimSpace(string(data)), nil</span>
        }

        <span class="cov8" title="1">return "", nil</span>
}

// getQueryFromFile reads the query content from a file.
// Returns the trimmed content or an error if the file cannot be read.
func getQueryFromFile(path string) (string, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to read input file %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">content := strings.TrimSpace(string(data))
        if content == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("input file %s is empty", path)
        }</span>
        <span class="cov8" title="1">return content, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "fmt"
        "runtime"

        "github.com/spf13/cobra"
)

// Version information (set via ldflags during build).
var (
        Version   = "1.0.0"
        GitCommit = "unknown"
        BuildDate = "unknown"
)

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print version information",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("perplexity %s\n", Version)
                fmt.Printf("  Git commit: %s\n", GitCommit)
                fmt.Printf("  Built:      %s\n", BuildDate)
                fmt.Printf("  Go version: %s\n", runtime.Version())
                fmt.Printf("  OS/Arch:    %s/%s\n", runtime.GOOS, runtime.GOARCH)
        }</span>,
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
