## ROLE & PRIMARY GOAL:
You are a "Robotic Senior System Architect AI". Your mission is to meticulously analyze the user's refactoring or design request (`User Task`), strictly adhere to `Guiding Principles` and `User Rules`, comprehend the existing `File Structure` (if provided and relevant), and then generate a comprehensive, actionable plan. Your *sole and exclusive output* must be a single, well-structured Markdown document detailing this plan. Zero tolerance for any deviation from the specified output format.

---

## INPUT SECTIONS OVERVIEW:
1.  `User Task`: The user's problem, system to be designed, or code/system to be refactored.
2.  `Guiding Principles`: Your core operational directives as a senior architect/planner.
3.  `User Rules`: Task-specific constraints or preferences from the user, overriding `Guiding Principles` in case of conflict.
4.  `Output Format & Constraints`: Strict rules for your *only* output: the Markdown plan.
5.  `File Structure Format Description`: How the provided project files are structured in this prompt (if applicable).
6.  `File Structure`: The current state of the project's files (if applicable to the task).

---

## 1. User Task
Identifique as áreas mais críticas para o aumento da cobertura de testes e implemente o aumento da cobertura de testes para atingir individualmente em cada área, pelo menos 80% de cobertura.

---

## 2. Guiding Principles (Your Senior Architect/Planner Logic)

### A. Analysis & Understanding (Internal Thought Process - Do NOT output this part):
1.  **Deconstruct Request:** Deeply understand the `User Task` – its explicit requirements, implicit goals, underlying problems, and success criteria.
2.  **Contextual Comprehension:** If `File Structure` is provided, analyze it to understand the current system's architecture, components, dependencies, and potential pain points relevant to the task.
3.  **Scope Definition:** Clearly delineate the boundaries of the proposed plan. What is in scope and what is out of scope?
4.  **Identify Key Areas:** Determine the primary systems, modules, components, or processes that the plan will address.
5.  **Risk Assessment & Mitigation:** Anticipate potential challenges, technical debt, integration issues, performance impacts, scalability concerns, and security considerations. Propose mitigation strategies or areas needing further investigation.
6.  **Assumptions:** If ambiguities exist in `User Task` or `File Structure`, make well-founded assumptions based on best practices, common architectural patterns, and the provided context. Document these assumptions clearly in the output.
7.  **Evaluate Alternatives (Briefly):** Internally consider different approaches or high-level solutions, selecting or recommending the one that best balances requirements, constraints, maintainability, scalability, and long-term vision.

### B. Plan Generation & Standards:
*   **Clarity & Actionability:** The plan must be clear, concise, and broken down into actionable steps or phases. Each step should have a discernible purpose **and, where appropriate, suggest criteria for its completion (Definition of Done) or potential for high-level effort estimation (e.g., S/M/L).**
*   **Justification:** Provide rationale for key decisions, architectural choices, or significant refactoring steps. Explain the "why" behind the "what."
*   **Modularity & Cohesion:** Design plans that promote modularity, separation of concerns, and high cohesion within components.
*   **Scalability & Performance:** Consider how the proposed design or refactoring will impact system scalability and performance.
*   **Maintainability & Testability:** The resulting system (after implementing the plan) should be maintainable and testable. The plan might include suggestions for improving these aspects.
*   **Phased Approach:** For complex tasks, break down the plan into logical phases or milestones. Define clear objectives for each phase. **Consider task prioritization within and between phases.**
*   **Impact Analysis:** Describe the potential impact of the proposed changes on existing functionality, users, or other systems.
*   **Dependencies:** Identify key dependencies between tasks within the plan or dependencies on external factors/teams.
*   **Non-Functional Requirements (NFRs):** Explicitly address any NFRs mentioned in the `User Task` or inferable as critical (e.g., security, reliability, usability, performance). **Security aspects should be considered by design.**
*   **Technology Choices (if applicable):** If new technologies are proposed, justify their selection, **briefly noting potential integration challenges or learning curves.** If existing technologies are leveraged, ensure the plan aligns with their best practices.
*   **No Implementation Code:** The output is a plan, not code. Pseudocode or illustrative snippets are acceptable *within the plan document* if they clarify a complex point, but full code implementation is out of scope for this role.

---

## 3. User Rules

*(These are user-provided, project-specific rules, methodological preferences (e.g., "Prioritize DDD principles"), or task constraints. They take precedence over `Guiding Principles`.)*

---

## 4. Output Format & Constraints (MANDATORY & STRICT)

Your **ONLY** output will be a single, well-structured Markdown document. No other text, explanations, or apologies are permitted outside this Markdown document.

### Markdown Structure (Suggested Outline - Adapt as needed for clarity, maintaining the spirit of each section):

```markdown
# Refactoring/Design Plan: [Brief Title Reflecting User Task]

## 1. Executive Summary & Goals
   - Briefly state the primary objective of this plan.
   - List 2-3 key goals or outcomes.

## 2. Current Situation Analysis (if applicable, especially for refactoring or when `File Structure` is provided)
   - Brief overview of the existing system/component based on `File Structure` or `User Task`.
   - Identify key pain points, limitations, or areas for improvement relevant to the task.

## 3. Proposed Solution / Refactoring Strategy
   ### 3.1. High-Level Design / Architectural Overview
      - Describe the target architecture or the overall approach to refactoring.
      - Use diagrams if they can be represented textually (e.g., Mermaid.js syntax within a code block, or ASCII art). **If a diagram is complex, consider breaking it down into multiple simpler diagrams illustrating different views or components.** Describe them clearly.
   ### 3.2. Key Components / Modules
      - Identify new components to be created or existing ones to be significantly modified.
      - Describe their responsibilities and interactions.
   ### 3.3. Detailed Action Plan / Phases
      - **Phase 1: [Name of Phase]**
         - Objective(s) for this phase.
         - **Priority:** [e.g., High/Medium/Low for the phase itself, if multiple phases can be parallelized or reordered]
         - Task 1.1: [Description]
            - **Rationale/Goal:** [Brief explanation of why this task is needed]
            - **Estimated Effort (Optional):** [e.g., S/M/L, or placeholder for team estimation]
            - **Deliverable/Criteria for Completion:** [What indicates this task is done]
         - Task 1.2: [Description]
            - **Rationale/Goal:** ...
            - **Estimated Effort (Optional):** ...
            - **Deliverable/Criteria for Completion:** ...
         - ...
      - **Phase 2: [Name of Phase] (if applicable)**
         - Objective(s) for this phase.
         - **Priority:** ...
         - Task 2.1: [Description]
            - **Rationale/Goal:** ...
            - **Estimated Effort (Optional):** ...
            - **Deliverable/Criteria for Completion:** ...
         - ...
      - *(Add more phases/tasks as necessary. Tasks should be actionable and logically sequenced. Ensure clear dependencies between tasks are noted either here or in section 4.2.)*
   ### 3.4. Data Model Changes (if applicable)
      - Describe any necessary changes to data structures, database schemas, etc.
   ### 3.5. API Design / Interface Changes (if applicable)
      - Detail new or modified APIs (endpoints, function signatures, data contracts, etc.).
      - Consider versioning, backward compatibility, and potential impact on consumers if relevant.

## 4. Key Considerations & Risk Mitigation
   ### 4.1. Technical Risks & Challenges
      - List potential technical hurdles (e.g., complex migrations, performance bottlenecks, integration with legacy systems).
      - Suggest mitigation strategies or contingency plans.
   ### 4.2. Dependencies
      - List internal (task-to-task, phase-to-phase) and external dependencies (e.g., other teams, third-party services, specific skill availability).
   ### 4.3. Non-Functional Requirements (NFRs) Addressed
      - How the plan addresses key NFRs (scalability, security, performance, maintainability, reliability, usability, etc.). **Be specific about how design choices contribute to these NFRs.**

## 5. Success Metrics / Validation Criteria
   - How will the success of this plan's implementation be measured?
   - What are the key indicators (quantitative or qualitative) that the goals have been achieved?

## 6. Assumptions Made
   - List any assumptions made during the planning process (e.g., about existing infrastructure, team skills, third-party component behavior).

## 7. Open Questions / Areas for Further Investigation
   - List any questions that need answering or areas requiring more detailed research before or during implementation.
   - **(Optional) Key discussion points for the team before finalizing or starting implementation.**

```

### General Constraints on the Plan:
*   **Comprehensive & Detailed:** The plan should provide enough detail for a development team to understand the scope, approach, and individual steps.
*   **Realistic & Achievable:** The proposed plan should be grounded in reality and consider practical implementation constraints.
*   **Forward-Looking:** While addressing the current task, consider future maintainability, scalability, and extensibility where appropriate.
*   **Strictly Markdown:** The entire output must be a single Markdown document. Do not include any preamble or closing remarks outside the Markdown content itself.

---

## 5. File Structure Format Description
The `File Structure` (provided in the next section, if applicable) is formatted as follows:
1.  An initial project directory tree structure (e.g., generated by `tree` or similar).
2.  Followed by the content of each file, using an XML-like structure:
    <file path="RELATIVE/PATH/TO/FILE">
    (File content here)
    </file>
    The `path` attribute contains the project-root-relative path, using forward slashes (`/`).
    File content is the raw text of the file. Each file block is separated by a newline.
    *(This section may be omitted if no file structure is relevant to the task).*

---

## 6. File Structure
└── perplexity-cli-go/
    ├── build/
    ├── cmd/
    │   └── perplexity/
    │       ├── cmd_integration_test.go.broken [23.5KB]
    │       ├── config.go [1.1KB]
    │       ├── cookies.go [3.9KB]
    │       ├── cookies_test.go [9.5KB]
    │       ├── history.go [4.3KB]
    │       ├── main.go [170B]
    │       ├── root.go [10.8KB]
    │       ├── root_integration_test.go.broken [31.9KB]
    │       ├── root_test.go [35.6KB]
    │       └── version.go [627B]
    ├── htmlcov/
    ├── internal/
    │   ├── auth/
    │   │   ├── cookies.go [5.6KB]
    │   │   └── cookies_test.go [6.6KB]
    │   ├── config/
    │   │   ├── manager.go [6.5KB]
    │   │   └── manager_test.go [6.1KB]
    │   ├── history/
    │   │   ├── writer.go [3.6KB]
    │   │   └── writer_test.go [6.4KB]
    │   └── ui/
    │       ├── config_menu.go [10.8KB]
    │       ├── config_menu_test.go [7.6KB]
    │       ├── renderer.go [7.7KB]
    │       └── renderer_test.go [17.5KB]
    ├── pkg/
    │   ├── client/
    │   │   ├── client.go [4.5KB]
    │   │   ├── client_test.go [5.0KB]
    │   │   ├── http.go [10.1KB]
    │   │   ├── http_test.go.bak [11.4KB]
    │   │   ├── search.go [13.3KB]
    │   │   ├── search_test.go [12.5KB]
    │   │   ├── search_test.go.broken [25.1KB]
    │   │   ├── upload.go [5.5KB]
    │   │   └── upload_test.go.bak [19.2KB]
    │   └── models/
    │       ├── request.go [3.0KB]
    │       ├── request_test.go [2.7KB]
    │       ├── response.go [4.9KB]
    │       ├── types.go [2.4KB]
    │       └── types_test.go [3.9KB]
    ├── requests/
    │   ├── extract_models.sh [802B]
    │   ├── ppx-bestmodel.md [140.8KB]
    │   ├── ppx-gemini-3-thinking.md [241.6KB]
    │   ├── ppx-gpt-5.1-thinking.md [363.2KB]
    │   ├── ppx-gpt-5.1.md [194.7KB]
    │   ├── ppx-grok-4.1-thinking.md [349.3KB]
    │   ├── ppx-grok-4.1.md [210.1KB]
    │   ├── ppx-kimi-k2-thinking.md [269.2KB]
    │   ├── ppx-sonar.md [130.5KB]
    │   ├── ppx-sonnet-4.5-thinking.md [359.7KB]
    │   └── ppx-sonnet-4.5.md [462.9KB]
    ├── CLAUDE.md [5.1KB]
    ├── Makefile [6.0KB]
    ├── cookies.json [5.7KB]
    ├── coverage.html [37.4KB]
    ├── go.mod [3.4KB]
    └── go.sum [16.8KB]

<file path="cmd/perplexity/cmd_integration_test.go.broken">
package main

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	http "github.com/bogdanfinn/fhttp"
	"github.com/diogo/perplexity-go/internal/config"
	"github.com/diogo/perplexity-go/internal/history"
	"github.com/diogo/perplexity-go/pkg/models"
	"github.com/spf13/cobra"
)

// MockClientWithResponse is a more sophisticated mock for integration tests
type MockClientWithResponse struct {
	searchResponse  *models.SearchResponse
	searchError     error
	streamChunks    []models.StreamChunk
	streamError     error
	closeError      error
	cookies         []*http.Cookie
	proQueriesRem   int
	fileUploadsRem  int
	hasValidSession bool
}

func NewMockClientWithResponse(resp *models.SearchResponse, err error) *MockClientWithResponse {
	return &MockClientWithResponse{
		searchResponse:  resp,
		searchError:     err,
		hasValidSession: true,
		proQueriesRem:   5,
		fileUploadsRem:  10,
	}
}

func NewMockStreamClientWithChunks(chunks []models.StreamChunk, err error) *MockClientWithResponse {
	return &MockClientWithResponse{
		streamChunks:    chunks,
		streamError:     err,
		hasValidSession: true,
		proQueriesRem:   5,
		fileUploadsRem:  10,
	}
}

func (m *MockClientWithResponse) Search(ctx context.Context, opts models.SearchOptions) (*models.SearchResponse, error) {
	return m.searchResponse, m.searchError
}

func (m *MockClientWithResponse) SearchStream(ctx context.Context, opts models.SearchOptions) (<-chan models.StreamChunk, error) {
	ch := make(chan models.StreamChunk, len(m.streamChunks))
	if m.streamError != nil {
		ch <- models.StreamChunk{Error: m.streamError}
		close(ch)
		return ch, m.streamError
	}
	for _, chunk := range m.streamChunks {
		ch <- chunk
	}
	close(ch)
	return ch, nil
}

func (m *MockClientWithResponse) Close() error {
	return m.closeError
}

func (m *MockClientWithResponse) SetCookies(cookies []*http.Cookie) {
	m.cookies = cookies
}

func (m *MockClientWithResponse) GetCookies() []*http.Cookie {
	return m.cookies
}

func (m *MockClientWithResponse) HasValidSession() bool {
	return m.hasValidSession
}

func (m *MockClientWithResponse) ProQueriesRemaining() int {
	return m.proQueriesRem
}

func (m *MockClientWithResponse) FileUploadsRemaining() int {
	return m.fileUploadsRem
}

// TestConfigCommand tests the config command and subcommands
func TestConfigCommand(t *testing.T) {
	tempDir := t.TempDir()

	// Save and restore HOME environment variable
	oldHome := os.Getenv("HOME")
	defer func() { os.Setenv("HOME", oldHome) }()
	os.Setenv("HOME", tempDir)

	t.Run("config path shows correct path", func(t *testing.T) {
		// Setup
		cfgMgr, err := config.NewManager()
		if err != nil {
			t.Fatalf("failed to create config manager: %v", err)
		}

		// Create a buffer to capture output
		var buf bytes.Buffer

		// Create command
		cmd := &cobra.Command{
			Use: "config path",
			RunE: func(cmd *cobra.Command, args []string) error {
				fmt.Println(cfgMgr.GetConfigFile())
				return nil
			},
		}

		// Set output
		cmd.SetOut(&buf)

		// Execute
		err = cmd.Execute()
		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}

		// Verify
		output := buf.String()
		if !strings.Contains(output, "test_config.json") {
			t.Errorf("expected config path in output, got: %s", output)
		}
	})

	t.Run("config command exists", func(t *testing.T) {
		// Verify the config command is properly set up
		if configCmd.Use != "config" {
			t.Errorf("expected config command use string 'config', got %q", configCmd.Use)
		}
		if configCmd.Short == "" {
			t.Error("config command should have a short description")
		}
	})
}

// TestHistoryCommand tests the history command and subcommands
func TestHistoryCommand(t *testing.T) {
	tempDir := t.TempDir()
	historyFile := filepath.Join(tempDir, "history.jsonl")

	t.Run("history list command exists", func(t *testing.T) {
		// Verify the history list command is properly set up
		if historyListCmd.Use != "list" {
			t.Errorf("expected history list command use string 'list', got %q", historyListCmd.Use)
		}
	})

	t.Run("history search command exists", func(t *testing.T) {
		// Verify the history search command is properly set up
		if historySearchCmd.Use != "search <query>" {
			t.Errorf("expected history search command use string 'search <query>', got %q", historySearchCmd.Use)
		}
		if historySearchCmd.Args != cobra.ExactArgs(1) {
			t.Error("history search should require exactly 1 argument")
		}
	})

	t.Run("history show command exists", func(t *testing.T) {
		// Verify the history show command is properly set up
		if historyShowCmd.Use != "show <index>" {
			t.Errorf("expected history show command use string 'show <index>', got %q", historyShowCmd.Use)
		}
		if historyShowCmd.Args != cobra.ExactArgs(1) {
			t.Error("history show should require exactly 1 argument")
		}
	})

	t.Run("history search with matching entries", func(t *testing.T) {
		// Create history entries
		hw, err := history.NewWriter(historyFile)
		if err != nil {
			t.Fatalf("failed to create history writer: %v", err)
		}

		hw.Append(models.HistoryEntry{
			Query:    "Go programming language",
			Mode:     "pro",
			Model:    "gpt51",
			Response: "Go is a statically typed programming language...",
		})

		hw.Append(models.HistoryEntry{
			Query:    "Python vs Go",
			Mode:     "fast",
			Model:    "pplx_pro",
			Response: "Python and Go are both programming languages...",
		})

		// Test search
		reader := history.NewReader(historyFile)
		entries, err := reader.Search("Go")
		if err != nil {
			t.Fatalf("failed to search history: %v", err)
		}

		if len(entries) != 2 {
			t.Errorf("expected 2 matching entries, got %d", len(entries))
		}
	})

	t.Run("history search with no matching entries", func(t *testing.T) {
		reader := history.NewReader(historyFile)
		entries, err := reader.Search("nonexistent")
		if err != nil {
			t.Fatalf("failed to search history: %v", err)
		}

		if len(entries) != 0 {
			t.Errorf("expected 0 matching entries, got %d", len(entries))
		}
	})

	t.Run("history show with valid index", func(t *testing.T) {
		// Create history entries
		hw, err := history.NewWriter(historyFile)
		if err != nil {
			t.Fatalf("failed to create history writer: %v", err)
		}

		hw.Append(models.HistoryEntry{
			Query:    "Test query",
			Mode:     "pro",
			Model:    "gpt51",
			Response: "Test response",
		})

		// Read all entries
		reader := history.NewReader(historyFile)
		entries, err := reader.ReadAll()
		if err != nil {
			t.Fatalf("failed to read history: %v", err)
		}

		if len(entries) == 0 {
			t.Fatal("expected at least one history entry")
		}

		// Show entry at index 1
		entry := entries[0]
		if entry.Query != "Test query" {
			t.Errorf("expected query 'Test query', got %q", entry.Query)
		}
		if entry.Mode != "pro" {
			t.Errorf("expected mode 'pro', got %q", entry.Mode)
		}
	})

	t.Run("history show with invalid index", func(t *testing.T) {
		reader := history.NewReader(historyFile)
		_, err := reader.ReadAll()
		if err != nil {
			t.Fatalf("failed to read history: %v", err)
		}

		// Test invalid index handling
		// (This would be tested in actual command execution)
	})

	t.Run("history command exists", func(t *testing.T) {
		// Verify the history command is properly set up
		if historyCmd.Use != "history" {
			t.Errorf("expected history command use string 'history', got %q", historyCmd.Use)
		}
		if historyCmd.Short == "" {
			t.Error("history command should have a short description")
		}
	})
}

// TestVersionCommand tests the version command
func TestVersionCommand(t *testing.T) {
	t.Run("version command prints version info", func(t *testing.T) {
		// Create a buffer to capture output
		var buf bytes.Buffer

		// Create command
		cmd := &cobra.Command{
			Use: "version",
			Run: func(cmd *cobra.Command, args []string) {
				fmt.Printf("perplexity %s\n", Version)
				fmt.Printf("  Git commit: %s\n", GitCommit)
				fmt.Printf("  Built:      %s\n", BuildDate)
				fmt.Printf("  Go version: %s\n", runtime.Version())
				fmt.Printf("  OS/Arch:    %s/%s\n", runtime.GOOS, runtime.GOARCH)
			},
		}

		// Set output
		cmd.SetOut(&buf)

		// Execute
		cmd.Run(cmd, []string{})

		// Verify
		output := buf.String()
		if !strings.Contains(output, "perplexity "+Version) {
			t.Errorf("expected version string in output, got: %s", output)
		}
		if !strings.Contains(output, "Git commit:") {
			t.Errorf("expected 'Git commit:' in output, got: %s", output)
		}
		if !strings.Contains(output, "Go version:") {
			t.Errorf("expected 'Go version:' in output, got: %s", output)
		}
		if !strings.Contains(output, "OS/Arch:") {
			t.Errorf("expected 'OS/Arch:' in output, got: %s", output)
		}
	})

	t.Run("version command exists", func(t *testing.T) {
		// Verify the version command is properly set up
		if versionCmd.Use != "version" {
			t.Errorf("expected version command use string 'version', got %q", versionCmd.Use)
		}
		if versionCmd.Short == "" {
			t.Error("version command should have a short description")
		}
	})
}

// TestCookieCommandsIntegration tests cookie-related commands with integration
func TestCookieCommandsIntegration(t *testing.T) {
	tempDir := t.TempDir()
	cookieFile := filepath.Join(tempDir, "cookies.json")

	t.Run("cookies status with existing file", func(t *testing.T) {
		// Create cookie file
		err := os.WriteFile(cookieFile, []byte(`[{"name": "next-auth.csrf-token", "value": "test123", "domain": ".perplexity.ai"}]`), 0644)
		if err != nil {
			t.Fatalf("failed to create cookie file: %v", err)
		}

		// Verify file exists
		if _, err := os.Stat(cookieFile); os.IsNotExist(err) {
			t.Error("cookie file should exist")
		}
	})

	t.Run("cookies status with missing file", func(t *testing.T) {
		missingFile := filepath.Join(tempDir, "missing.json")

		// Verify file doesn't exist
		if _, err := os.Stat(missingFile); !os.IsNotExist(err) {
			t.Error("cookie file should not exist")
		}
	})

	t.Run("import cookies command exists", func(t *testing.T) {
		// Verify the import cookies command is properly set up
		if importCookiesCmd.Use != "import-cookies" {
			t.Errorf("expected import cookies command use string 'import-cookies', got %q", importCookiesCmd.Use)
		}
		if importCookiesCmd.Short == "" {
			t.Error("import cookies command should have a short description")
		}
	})
}

// TestEndToEndQueryWithStreaming tests complete query flow with streaming
func TestEndToEndQueryWithStreaming(t *testing.T) {
	tempDir := t.TempDir()
	queryFile := filepath.Join(tempDir, "query.txt")
	outputFile := filepath.Join(tempDir, "output.txt")
	cookieFile := filepath.Join(tempDir, "cookies.json")
	historyFile := filepath.Join(tempDir, "history.jsonl")

	// Create test files
	err := os.WriteFile(queryFile, []byte("test streaming query"), 0644)
	if err != nil {
		t.Fatalf("failed to create query file: %v", err)
	}

	err = os.WriteFile(cookieFile, []byte(`[{"name": "next-auth.csrf-token", "value": "test"}]`), 0644)
	if err != nil {
		t.Fatalf("failed to create cookie file: %v", err)
	}

	t.Run("streaming query with file input and output", func(t *testing.T) {
		// Setup config
		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModePro,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb},
			CookieFile:      cookieFile,
			HistoryFile:     historyFile,
		}

		// Set flags
		flagInputFile = queryFile
		flagOutputFile = outputFile
		flagCookieFile = ""
		flagIncognito = false
		flagStream = true
		flagVerbose = false

		// Create mock streaming response
		chunks := []models.StreamChunk{
			{Delta: "This is ", StepType: "FINAL"},
			{Delta: "a streaming ", StepType: "FINAL"},
			{Delta: "response.", StepType: "FINAL"},
			{WebResults: []models.WebResult{{Title: "Test Result", URL: "http://example.com", Snippet: "Test snippet"}}},
		}
		mockClient := NewMockStreamClientWithChunks(chunks, nil)

		// Override client creation for this test
		// This is a simplified integration test
		// Note: In a real integration test, we would use dependency injection

		// Verify the setup
		if cfg.CookieFile == "" {
			t.Error("cookie file should be set")
		}
		if cfg.HistoryFile == "" {
			t.Error("history file should be set")
		}
	})

	t.Run("non-streaming query with args", func(t *testing.T) {
		// Setup config
		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModeDefault,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb},
			CookieFile:      cookieFile,
			HistoryFile:     historyFile,
		}

		// Reset flags
		flagInputFile = ""
		flagOutputFile = ""
		flagCookieFile = ""
		flagIncognito = false
		flagStream = false
		flagVerbose = false

		// Create mock response
		resp := &models.SearchResponse{
			Text: "This is a test response",
		}
		mockClient := NewMockClientWithResponse(resp, nil)

		// Verify setup
		if flagStream != false {
			t.Error("streaming should be disabled")
		}
	})

	t.Run("query with verbose mode", func(t *testing.T) {
		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModeDefault,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb},
			CookieFile:      cookieFile,
		}

		// Set verbose flag
		flagVerbose = true

		// Test buildSearchOptions with verbose
		opts := buildSearchOptions("verbose test query")

		// Verify verbose doesn't affect search options (it's just for output)
		if opts.Query != "verbose test query" {
			t.Errorf("query mismatch")
		}
	})
}

// TestErrorScenariosIntegration tests various error scenarios
func TestErrorScenariosIntegration(t *testing.T) {
	tempDir := t.TempDir()
	cookieFile := filepath.Join(tempDir, "cookies.json")

	// Create cookie file
	err := os.WriteFile(cookieFile, []byte(`[{"name": "next-auth.csrf-token", "value": "test"}]`), 0644)
	if err != nil {
		t.Fatalf("failed to create cookie file: %v", err)
	}

	t.Run("client creation error", func(t *testing.T) {
		// Test with invalid cookies
		invalidCookies := []*http.Cookie{}

		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModeDefault,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb},
			CookieFile:      cookieFile,
		}

		// This would normally create a client
		// We're testing the error handling path
	})

	t.Run("missing required cookie", func(t *testing.T) {
		// Create cookie file without required csrf-token
		badCookieFile := filepath.Join(tempDir, "badcookies.json")
		err := os.WriteFile(badCookieFile, []byte(`[{"name": "other-cookie", "value": "value"}]`), 0644)
		if err != nil {
			t.Fatalf("failed to create bad cookie file: %v", err)
		}

		// The client should detect missing csrf-token
		// This tests the error handling
	})

	t.Run("API error response", func(t *testing.T) {
		// Create mock client that returns an error
		mockClient := NewMockClientWithResponse(nil, fmt.Errorf("API error: rate limit exceeded"))

		// Verify error handling
		resp, err := mockClient.Search(context.Background(), models.SearchOptions{Query: "test"})
		if err == nil {
			t.Error("expected error, got nil")
		}
		if resp != nil {
			t.Error("response should be nil on error")
		}
	})

	t.Run("streaming error", func(t *testing.T) {
		// Create mock client that returns streaming error
		mockClient := NewMockStreamClientWithChunks(nil, fmt.Errorf("stream error"))

		// Verify error handling
		ch, err := mockClient.SearchStream(context.Background(), models.SearchOptions{Query: "test"})
		if err == nil {
			t.Error("expected error, got nil")
		}
		if ch == nil {
			t.Error("channel should be non-nil even on error")
		}
	})
}

// TestFlagCombinationsIntegration tests various flag combinations
func TestFlagCombinationsIntegration(t *testing.T) {
	// Save current state
	origFlagModel := flagModel
	origFlagMode := flagMode
	origFlagLanguage := flagLanguage
	origFlagSources := flagSources
	origFlagIncognito := flagIncognito
	origFlagStream := flagStream
	origFlagNoStream := flagNoStream

	defer func() {
		flagModel = origFlagModel
		flagMode = origFlagMode
		flagLanguage = origFlagLanguage
		flagSources = origFlagSources
		flagIncognito = origFlagIncognito
		flagStream = origFlagStream
		flagNoStream = origFlagNoStream
	}()

	cfg = &config.Config{
		DefaultModel:    models.ModelPplxPro,
		DefaultMode:     models.ModeDefault,
		DefaultLanguage: "en-US",
		DefaultSources:  []models.Source{models.SourceWeb},
		Incognito:       false,
	}

	t.Run("stream and no-stream flags interaction", func(t *testing.T) {
		// Test that --no-stream overrides config streaming
		cfg.Streaming = true
		flagStream = false
		flagNoStream = true

		// The logic in runQuery checks these flags
		// streaming should be false due to flagNoStream
	})

	t.Run("all search-related flags together", func(t *testing.T) {
		flagModel = "gpt51"
		flagMode = "pro"
		flagLanguage = "fr-FR"
		flagSources = "web,scholar,social"
		flagIncognito = true

		opts := buildSearchOptions("combined flags test")

		if opts.Model != models.ModelGPT51 {
			t.Errorf("expected model gpt51, got %q", opts.Model)
		}
		if opts.Mode != models.ModePro {
			t.Errorf("expected mode pro, got %q", opts.Mode)
		}
		if opts.Language != "fr-FR" {
			t.Errorf("expected language fr-FR, got %q", opts.Language)
		}
		if len(opts.Sources) != 3 {
			t.Errorf("expected 3 sources, got %d", len(opts.Sources))
		}
		if !opts.Incognito {
			t.Error("expected incognito to be true")
		}
	})

	t.Run("empty sources string uses config default", func(t *testing.T) {
		flagModel = ""
		flagMode = ""
		flagLanguage = ""
		flagSources = ""

		opts := buildSearchOptions("empty flags test")

		if opts.Model != models.ModelPplxPro {
			t.Errorf("expected model pplx_pro from config, got %q", opts.Model)
		}
	})
}

// TestConfigIntegration tests config loading and integration
func TestConfigIntegration(t *testing.T) {
	tempDir := t.TempDir()

	// Save and restore HOME
	oldHome := os.Getenv("HOME")
	defer func() { os.Setenv("HOME", oldHome) }()
	os.Setenv("HOME", tempDir)

	t.Run("config file with all fields", func(t *testing.T) {
		// Create config directory
		configDir := filepath.Join(tempDir, ".perplexity-cli")
		err := os.MkdirAll(configDir, 0700)
		if err != nil {
			t.Fatalf("failed to create config dir: %v", err)
		}

		// Write comprehensive config
		configFile := filepath.Join(configDir, "config.json")
		configJSON := `{
			"default_model": "gpt51",
			"default_mode": "pro",
			"default_language": "pt-BR",
			"streaming": true,
			"incognito": true,
			"history_file": "custom_history.jsonl"
		}`
		err = os.WriteFile(configFile, []byte(configJSON), 0644)
		if err != nil {
			t.Fatalf("failed to write config: %v", err)
		}

		// Load and verify
		mgr, err := config.NewManager()
		if err != nil {
			t.Fatalf("failed to create manager: %v", err)
		}

		testCfg, err := mgr.Load()
		if err != nil {
			t.Fatalf("failed to load config: %v", err)
		}

		if testCfg.DefaultModel != "gpt51" {
			t.Errorf("expected model gpt51, got %q", testCfg.DefaultModel)
		}
		if testCfg.DefaultMode != "pro" {
			t.Errorf("expected mode pro, got %q", testCfg.DefaultMode)
		}
	})

	t.Run("config with missing optional fields", func(t *testing.T) {
		// Create minimal config
		configDir := filepath.Join(tempDir, ".perplexity-cli")
		err := os.MkdirAll(configDir, 0700)
		if err != nil {
			t.Fatalf("failed to create config dir: %v", err)
		}

		configFile := filepath.Join(configDir, "config.json")
		configJSON := `{
			"default_model": "claude45sonnet"
		}`
		err = os.WriteFile(configFile, []byte(configJSON), 0644)
		if err != nil {
			t.Fatalf("failed to write config: %v", err)
		}

		// Load and verify defaults are applied
		mgr, err := config.NewManager()
		if err != nil {
			t.Fatalf("failed to create manager: %v", err)
		}

		testCfg, err := mgr.Load()
		if err != nil {
			t.Fatalf("failed to load config: %v", err)
		}

		// Should have defaults for missing fields
		if testCfg.DefaultMode == "" {
			t.Error("default mode should be set")
		}
	})
}

// TestHistoryIntegration tests history functionality integration
func TestHistoryIntegration(t *testing.T) {
	tempDir := t.TempDir()
	historyFile := filepath.Join(tempDir, "test_history.jsonl")

	t.Run("history writer and reader integration", func(t *testing.T) {
		// Create history entries
		hw, err := history.NewWriter(historyFile)
		if err != nil {
			t.Fatalf("failed to create history writer: %v", err)
		}

		// Add multiple entries
		entries := []models.HistoryEntry{
			{Query: "Query 1", Mode: "pro", Model: "gpt51", Response: "Response 1"},
			{Query: "Query 2", Mode: "fast", Model: "pplx_pro", Response: "Response 2"},
			{Query: "Query 3", Mode: "reasoning", Model: "gpt51_thinking", Response: "Response 3"},
		}

		for _, entry := range entries {
			hw.Append(entry)
		}

		// Read all entries
		reader := history.NewReader(historyFile)
		readEntries, err := reader.ReadAll()
		if err != nil {
			t.Fatalf("failed to read history: %v", err)
		}

		if len(readEntries) != len(entries) {
			t.Errorf("expected %d entries, got %d", len(entries), len(readEntries))
		}

		// Verify timestamps are set
		for _, entry := range readEntries {
			if entry.Timestamp.IsZero() {
				t.Error("timestamp should be set")
			}
		}
	})

	t.Run("history search integration", func(t *testing.T) {
		hw, err := history.NewWriter(historyFile)
		if err != nil {
			t.Fatalf("failed to create history writer: %v", err)
		}

		hw.Append(models.HistoryEntry{
			Query:    "Go programming tutorial",
			Mode:     "pro",
			Model:    "gpt51",
			Response: "Learn Go programming...",
		})

		hw.Append(models.HistoryEntry{
			Query:    "Python basics",
			Mode:     "fast",
			Model:    "pplx_pro",
			Response: "Python is easy...",
		})

		// Search for "Go"
		reader := history.NewReader(historyFile)
		results, err := reader.Search("Go")
		if err != nil {
			t.Fatalf("failed to search history: %v", err)
		}

		if len(results) != 1 {
			t.Errorf("expected 1 result for 'Go', got %d", len(results))
		}

		if results[0].Query != "Go programming tutorial" {
			t.Errorf("expected 'Go programming tutorial', got %q", results[0].Query)
		}
	})

	t.Run("history with truncation", func(t *testing.T) {
		hw, err := history.NewWriter(historyFile)
		if err != nil {
			t.Fatalf("failed to create history writer: %v", err)
		}

		// Add entry with long response
		longResponse := strings.Repeat("This is a long response. ", 100)
		hw.Append(models.HistoryEntry{
			Query:    "Long query",
			Mode:     "pro",
			Model:    "gpt51",
			Response: longResponse,
		})

		// The truncation happens in runQuery
		truncated := truncateResponse(longResponse, 500)
		if len(truncated) > 503 { // 500 + "..."
			t.Errorf("truncated response too long: %d characters", len(truncated))
		}
	})
}

// TestTimeoutAndCancellationIntegration tests timeout and cancellation scenarios
func TestTimeoutAndCancellationIntegration(t *testing.T) {
	t.Run("context cancellation handling", func(t *testing.T) {
		// Create a mock client that supports context cancellation
		ctx, cancel := context.WithCancel(context.Background())

		mockClient := NewMockClientWithResponse(&models.SearchResponse{
			Text: "Response",
		}, nil)

		// Start search
		resp, err := mockClient.Search(ctx, models.SearchOptions{Query: "test"})
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Cancel context
		cancel()

		// In a real scenario, this would be detected in the response
		// For this mock test, we just verify the pattern
		if resp == nil {
			t.Error("response should not be nil")
		}
	})

	t.Run("timeout handling", func(t *testing.T) {
		// Create context with timeout
		ctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond)
		defer cancel()

		// Short delay to trigger timeout
		time.Sleep(10 * time.Millisecond)

		// Context should be done
		select {
		case <-ctx.Done():
			// Expected
		default:
			t.Error("context should be done after timeout")
		}
	})
}
</file>
<file path="cmd/perplexity/config.go">
package main

import (
	"fmt"

	"github.com/diogo/perplexity-go/internal/ui"
	"github.com/spf13/cobra"
)

var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Manage configuration interactively",
	Long: `Open an interactive menu to view and modify configuration settings.

Use arrow keys to navigate, Enter to select an option, and Esc to cancel.

Configuration options:
  - Model:     Default AI model (pplx_pro, gpt5, claude45sonnet, etc.)
  - Mode:      Search mode (fast, pro, reasoning, deep-research, default)
  - Language:  Response language (e.g., en-US, pt-BR)
  - Sources:   Search sources (web, scholar, social)
  - Streaming: Enable/disable streaming output
  - Incognito: Enable/disable history saving`,
	RunE: func(cmd *cobra.Command, args []string) error {
		return ui.RunInteractiveConfig(cfg, cfgMgr)
	},
}

var configPathCmd = &cobra.Command{
	Use:   "path",
	Short: "Show configuration file path",
	RunE: func(cmd *cobra.Command, args []string) error {
		fmt.Println(cfgMgr.GetConfigFile())
		return nil
	},
}

func init() {
	configCmd.AddCommand(configPathCmd)
}
</file>
<file path="cmd/perplexity/cookies.go">
package main

import (
	"fmt"
	"os"

	"github.com/diogo/perplexity-go/internal/auth"
	"github.com/spf13/cobra"
)

var cookiesCmd = &cobra.Command{
	Use:   "cookies",
	Short: "Manage authentication cookies",
	Long:  `Manage authentication cookies for Perplexity API access.`,
}

// importCookiesCmd is a root-level command for importing cookies.
var importCookiesCmd = &cobra.Command{
	Use:   "import-cookies <file>",
	Short: "Import cookies from file",
	Long: `Import cookies from a JSON or Netscape format file.

Supported formats:
  - JSON: Browser extension export (cookies.json)
  - Netscape: curl/wget format (cookies.txt)

Example:
  perplexity import-cookies ~/Downloads/cookies.json`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		importFile := args[0]

		// Check if source file exists
		if _, err := os.Stat(importFile); os.IsNotExist(err) {
			return fmt.Errorf("file not found: %s", importFile)
		}

		// Try JSON format first
		cookies, err := auth.LoadCookiesFromFile(importFile)
		if err != nil {
			// Try Netscape format
			cookies, err = auth.LoadCookiesFromNetscape(importFile)
			if err != nil {
				return fmt.Errorf("failed to parse cookies (tried JSON and Netscape formats): %v", err)
			}
		}

		if len(cookies) == 0 {
			return fmt.Errorf("no Perplexity cookies found in file")
		}

		// Save to config cookie file
		if err := auth.SaveCookiesToFile(cookies, cfg.CookieFile); err != nil {
			return fmt.Errorf("failed to save cookies: %v", err)
		}

		render.RenderSuccess(fmt.Sprintf("Imported %d cookies to %s", len(cookies), cfg.CookieFile))

		if !auth.HasCSRFToken(cookies) {
			render.RenderWarning("CSRF token not found - session may not work")
		}

		return nil
	},
}

var cookiesStatusCmd = &cobra.Command{
	Use:   "status",
	Short: "Check authentication status",
	RunE: func(cmd *cobra.Command, args []string) error {
		cookieFile := cfg.CookieFile
		if flagCookieFile != "" {
			cookieFile = flagCookieFile
		}

		// Check if file exists
		if _, err := os.Stat(cookieFile); os.IsNotExist(err) {
			render.RenderWarning("Not authenticated")
			render.RenderInfo(fmt.Sprintf("Cookie file not found: %s", cookieFile))
			render.RenderInfo("Run 'perplexity import-cookies <file>' to import cookies")
			return nil
		}

		// Load and validate cookies
		cookies, err := auth.LoadCookiesFromFile(cookieFile)
		if err != nil {
			render.RenderError(fmt.Errorf("failed to load cookies: %v", err))
			return err
		}

		if len(cookies) == 0 {
			render.RenderWarning("No Perplexity cookies found in file")
			return nil
		}

		// Check for CSRF token
		if auth.HasCSRFToken(cookies) {
			render.RenderSuccess("Authenticated")
			fmt.Printf("Cookie file: %s\n", cookieFile)
			fmt.Printf("Cookies loaded: %d\n", len(cookies))

			// Show cookie names
			fmt.Println("\nCookies:")
			for _, c := range cookies {
				fmt.Printf("  - %s\n", c.Name)
			}
		} else {
			render.RenderWarning("Cookies found but CSRF token missing")
			render.RenderInfo("Session may be expired. Re-export cookies from browser.")
		}

		return nil
	},
}

var cookiesClearCmd = &cobra.Command{
	Use:   "clear",
	Short: "Clear saved cookies",
	RunE: func(cmd *cobra.Command, args []string) error {
		if err := os.Remove(cfg.CookieFile); err != nil {
			if os.IsNotExist(err) {
				render.RenderInfo("No cookies to clear")
				return nil
			}
			return fmt.Errorf("failed to remove cookies: %v", err)
		}

		render.RenderSuccess("Cookies cleared")
		return nil
	},
}

var cookiesPathCmd = &cobra.Command{
	Use:   "path",
	Short: "Show cookie file path",
	RunE: func(cmd *cobra.Command, args []string) error {
		fmt.Println(cfg.CookieFile)
		return nil
	},
}

func init() {
	cookiesCmd.AddCommand(cookiesStatusCmd)
	cookiesCmd.AddCommand(cookiesClearCmd)
	cookiesCmd.AddCommand(cookiesPathCmd)

	// NOTE: importCookiesCmd is added to the rootCmd in root.go
}
</file>
<file path="cmd/perplexity/cookies_test.go">
package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/diogo/perplexity-go/internal/config"
	"github.com/diogo/perplexity-go/internal/ui"
)

func setupTestEnv(t *testing.T) (string, func()) {
	t.Helper()

	// Create temp directory for test files
	tmpDir := t.TempDir()

	// Store original values
	originalCfg := cfg
	originalCfgMgr := cfgMgr
	originalRender := render

	// Setup test config
	var err error
	cfgMgr, err = config.NewManager()
	if err != nil {
		t.Fatalf("Failed to create config manager: %v", err)
	}

	cfg = &config.Config{
		CookieFile:  filepath.Join(tmpDir, "cookies.json"),
		HistoryFile: filepath.Join(tmpDir, "history.jsonl"),
	}

	render, err = ui.NewRenderer()
	if err != nil {
		t.Fatalf("Failed to create renderer: %v", err)
	}

	cleanup := func() {
		cfg = originalCfg
		cfgMgr = originalCfgMgr
		render = originalRender
	}

	return tmpDir, cleanup
}

func TestImportCookiesCmd_FileNotFound(t *testing.T) {
	_, cleanup := setupTestEnv(t)
	defer cleanup()

	// Call RunE directly instead of Execute
	err := importCookiesCmd.RunE(importCookiesCmd, []string{"/nonexistent/file.json"})

	if err == nil {
		t.Error("Expected error for nonexistent file")
	}
	if !strings.Contains(err.Error(), "file not found") {
		t.Errorf("Error should mention 'file not found', got: %v", err)
	}
}

func TestImportCookiesCmd_ValidJSON(t *testing.T) {
	tmpDir, cleanup := setupTestEnv(t)
	defer cleanup()

	// Create test cookie file to import
	cookieJSON := `[
		{
			"name": "imported_cookie",
			"value": "imported_value",
			"domain": ".perplexity.ai",
			"path": "/"
		},
		{
			"name": "next-auth.csrf-token",
			"value": "csrf|hash",
			"domain": ".perplexity.ai",
			"path": "/"
		}
	]`
	importFile := filepath.Join(tmpDir, "import_cookies.json")
	if err := os.WriteFile(importFile, []byte(cookieJSON), 0644); err != nil {
		t.Fatalf("Failed to write import file: %v", err)
	}

	err := importCookiesCmd.RunE(importCookiesCmd, []string{importFile})

	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	// Verify cookies were saved to config location
	if _, err := os.Stat(cfg.CookieFile); os.IsNotExist(err) {
		t.Error("Cookie file was not created at config location")
	}
}

func TestImportCookiesCmd_NoCookies(t *testing.T) {
	tmpDir, cleanup := setupTestEnv(t)
	defer cleanup()

	// Create file with only non-perplexity cookies
	cookieJSON := `[
		{
			"name": "other_cookie",
			"value": "value",
			"domain": ".example.com",
			"path": "/"
		}
	]`
	emptyCookieFile := filepath.Join(tmpDir, "empty.json")
	if err := os.WriteFile(emptyCookieFile, []byte(cookieJSON), 0644); err != nil {
		t.Fatalf("Failed to write empty cookie file: %v", err)
	}

	err := importCookiesCmd.RunE(importCookiesCmd, []string{emptyCookieFile})

	if err == nil {
		t.Error("Expected error for empty cookies")
	}
	if !strings.Contains(err.Error(), "no Perplexity cookies") {
		t.Errorf("Error should mention 'no Perplexity cookies', got: %v", err)
	}
}

func TestImportCookiesCmd_InvalidFormat(t *testing.T) {
	tmpDir, cleanup := setupTestEnv(t)
	defer cleanup()

	// Create invalid format file that doesn't look like any valid format
	invalidFile := filepath.Join(tmpDir, "invalid.txt")
	if err := os.WriteFile(invalidFile, []byte("not valid json or netscape"), 0644); err != nil {
		t.Fatalf("Failed to write invalid file: %v", err)
	}

	err := importCookiesCmd.RunE(importCookiesCmd, []string{invalidFile})

	if err == nil {
		t.Error("Expected error for invalid format")
	}
	// The error can be either "failed to parse" or "no Perplexity cookies" depending on parsing
	if !strings.Contains(err.Error(), "no Perplexity cookies") && !strings.Contains(err.Error(), "failed to parse cookies") {
		t.Errorf("Error should mention 'no Perplexity cookies' or 'failed to parse cookies', got: %v", err)
	}
}

func TestCookiesStatusCmd_NoCookies(t *testing.T) {
	_, cleanup := setupTestEnv(t)
	defer cleanup()

	// Make sure cookie file doesn't exist
	cfg.CookieFile = "/nonexistent/cookies.json"

	err := cookiesStatusCmd.RunE(cookiesStatusCmd, []string{})

	// Should not error, just show warning
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestCookiesStatusCmd_ValidCookies(t *testing.T) {
	tmpDir, cleanup := setupTestEnv(t)
	defer cleanup()

	// Create cookie file with CSRF token
	cookieJSON := `[
		{
			"name": "next-auth.csrf-token",
			"value": "token|hash",
			"domain": ".perplexity.ai",
			"path": "/"
		}
	]`
	cookieFile := filepath.Join(tmpDir, "cookies.json")
	if err := os.WriteFile(cookieFile, []byte(cookieJSON), 0644); err != nil {
		t.Fatalf("Failed to write cookie file: %v", err)
	}
	cfg.CookieFile = cookieFile

	err := cookiesStatusCmd.RunE(cookiesStatusCmd, []string{})

	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestCookiesStatusCmd_MissingCSRFToken(t *testing.T) {
	tmpDir, cleanup := setupTestEnv(t)
	defer cleanup()

	// Create cookie file without CSRF token
	cookieJSON := `[
		{
			"name": "other_cookie",
			"value": "value",
			"domain": ".perplexity.ai",
			"path": "/"
		}
	]`
	cookieFile := filepath.Join(tmpDir, "cookies.json")
	if err := os.WriteFile(cookieFile, []byte(cookieJSON), 0644); err != nil {
		t.Fatalf("Failed to write cookie file: %v", err)
	}
	cfg.CookieFile = cookieFile

	err := cookiesStatusCmd.RunE(cookiesStatusCmd, []string{})

	// Should not error, just show warning about missing CSRF token
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestCookiesClearCmd_NoCookies(t *testing.T) {
	_, cleanup := setupTestEnv(t)
	defer cleanup()

	// Make sure cookie file doesn't exist
	cfg.CookieFile = "/nonexistent/cookies.json"

	err := cookiesClearCmd.RunE(cookiesClearCmd, []string{})

	// Should not error when no cookies exist
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestCookiesClearCmd_ClearExisting(t *testing.T) {
	tmpDir, cleanup := setupTestEnv(t)
	defer cleanup()

	// Create cookie file
	cookieFile := filepath.Join(tmpDir, "cookies.json")
	if err := os.WriteFile(cookieFile, []byte("[]"), 0644); err != nil {
		t.Fatalf("Failed to write cookie file: %v", err)
	}
	cfg.CookieFile = cookieFile

	// Verify file exists
	if _, err := os.Stat(cookieFile); os.IsNotExist(err) {
		t.Fatal("Cookie file should exist before clear")
	}

	err := cookiesClearCmd.RunE(cookiesClearCmd, []string{})

	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	// Verify file was deleted
	if _, err := os.Stat(cookieFile); !os.IsNotExist(err) {
		t.Error("Cookie file should be deleted after clear")
	}
}

func TestCookiesPathCmd(t *testing.T) {
	_, cleanup := setupTestEnv(t)
	defer cleanup()

	err := cookiesPathCmd.RunE(cookiesPathCmd, []string{})

	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestCookiesCmdStructure(t *testing.T) {
	// Verify command structure (import was moved to root level as import-cookies)
	subcommands := []string{"status", "clear", "path"}

	for _, name := range subcommands {
		found := false
		for _, cmd := range cookiesCmd.Commands() {
			if cmd.Name() == name {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected subcommand %q not found", name)
		}
	}
}

func TestImportCookiesCmd_NetscapeFormat(t *testing.T) {
	tmpDir, cleanup := setupTestEnv(t)
	defer cleanup()

	// Create Netscape format cookie file
	netscapeContent := `# Netscape HTTP Cookie File
.perplexity.ai	TRUE	/	TRUE	1735689600	session	session_value
.perplexity.ai	TRUE	/	FALSE	0	next-auth.csrf-token	token|hash
`
	importFile := filepath.Join(tmpDir, "cookies.txt")
	if err := os.WriteFile(importFile, []byte(netscapeContent), 0644); err != nil {
		t.Fatalf("Failed to write Netscape file: %v", err)
	}

	err := importCookiesCmd.RunE(importCookiesCmd, []string{importFile})

	if err != nil {
		t.Errorf("Unexpected error importing Netscape format: %v", err)
	}

	// Verify cookies were saved
	if _, err := os.Stat(cfg.CookieFile); os.IsNotExist(err) {
		t.Error("Cookie file was not created")
	}
}

func TestImportCookiesCmd_MissingCSRFToken(t *testing.T) {
	tmpDir, cleanup := setupTestEnv(t)
	defer cleanup()

	// Create cookie file without CSRF token
	cookieJSON := `[
		{
			"name": "some_cookie",
			"value": "some_value",
			"domain": ".perplexity.ai",
			"path": "/"
		}
	]`
	importFile := filepath.Join(tmpDir, "no_csrf.json")
	if err := os.WriteFile(importFile, []byte(cookieJSON), 0644); err != nil {
		t.Fatalf("Failed to write import file: %v", err)
	}

	// Should succeed but show warning (warning is just printed, not returned as error)
	err := importCookiesCmd.RunE(importCookiesCmd, []string{importFile})

	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	// Verify cookies were still saved
	if _, err := os.Stat(cfg.CookieFile); os.IsNotExist(err) {
		t.Error("Cookie file was not created despite missing CSRF token")
	}
}

func TestCookiesCmd_Help(t *testing.T) {
	// Test that help text exists
	if cookiesCmd.Short == "" {
		t.Error("cookiesCmd should have a short description")
	}
	if cookiesCmd.Long == "" {
		t.Error("cookiesCmd should have a long description")
	}
}

func TestImportCookiesCmd_Help(t *testing.T) {
	// Test that help text exists
	if importCookiesCmd.Short == "" {
		t.Error("importCookiesCmd should have a short description")
	}
	if importCookiesCmd.Long == "" {
		t.Error("importCookiesCmd should have a long description")
	}
}
</file>
<file path="cmd/perplexity/history.go">
package main

import (
	"fmt"
	"strconv"

	"github.com/diogo/perplexity-go/internal/history"
	"github.com/spf13/cobra"
)

var (
	historyCount int
)

var historyCmd = &cobra.Command{
	Use:   "history",
	Short: "View query history",
	Long:  `View and manage your query history.`,
	RunE:  runHistoryList,
}

var historyListCmd = &cobra.Command{
	Use:   "list",
	Short: "List recent queries",
	RunE:  runHistoryList,
}

var historySearchCmd = &cobra.Command{
	Use:   "search <query>",
	Short: "Search history",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		reader := history.NewReader(cfg.HistoryFile)
		entries, err := reader.Search(args[0])
		if err != nil {
			return fmt.Errorf("failed to search history: %v", err)
		}

		if len(entries) == 0 {
			render.RenderInfo("No matching entries found")
			return nil
		}

		render.RenderTitle(fmt.Sprintf("Search Results: %d matches", len(entries)))
		for i, entry := range entries {
			fmt.Printf("[%d] %s\n", i+1, entry.Timestamp.Format("2006-01-02 15:04"))
			fmt.Printf("    Query: %s\n", entry.Query)
			fmt.Printf("    Mode: %s, Model: %s\n", entry.Mode, entry.Model)
			fmt.Println()
		}

		return nil
	},
}

var historyShowCmd = &cobra.Command{
	Use:   "show <index>",
	Short: "Show details of a history entry",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		idx, err := strconv.Atoi(args[0])
		if err != nil || idx < 1 {
			return fmt.Errorf("invalid index: %s", args[0])
		}

		reader := history.NewReader(cfg.HistoryFile)
		entries, err := reader.ReadAll()
		if err != nil {
			return fmt.Errorf("failed to read history: %v", err)
		}

		if idx > len(entries) {
			return fmt.Errorf("index out of range: %d (max: %d)", idx, len(entries))
		}

		entry := entries[idx-1]
		render.RenderTitle("History Entry")
		fmt.Printf("Timestamp: %s\n", entry.Timestamp.Format("2006-01-02 15:04:05"))
		fmt.Printf("Query:     %s\n", entry.Query)
		fmt.Printf("Mode:      %s\n", entry.Mode)
		fmt.Printf("Model:     %s\n", entry.Model)
		if entry.Response != "" {
			fmt.Println("\nResponse:")
			render.RenderStyledResponse(entry.Response)
		}

		return nil
	},
}

var historyClearCmd = &cobra.Command{
	Use:   "clear",
	Short: "Clear all history",
	RunE: func(cmd *cobra.Command, args []string) error {
		reader := history.NewReader(cfg.HistoryFile)
		if err := reader.Clear(); err != nil {
			return fmt.Errorf("failed to clear history: %v", err)
		}
		render.RenderSuccess("History cleared")
		return nil
	},
}

func runHistoryList(cmd *cobra.Command, args []string) error {
	reader := history.NewReader(cfg.HistoryFile)

	var entries []any
	var err error

	if historyCount > 0 {
		entries, err = readLastN(reader, historyCount)
	} else {
		entries, err = readLastN(reader, 20)
	}

	if err != nil {
		return fmt.Errorf("failed to read history: %v", err)
	}

	if len(entries) == 0 {
		render.RenderInfo("No history entries")
		return nil
	}

	render.RenderTitle("Recent Queries")
	for i, e := range entries {
		entry := e.(historyEntry)
		fmt.Printf("[%d] %s\n", i+1, entry.Timestamp)
		fmt.Printf("    %s\n", entry.Query)
		if entry.Mode != "" {
			fmt.Printf("    Mode: %s", entry.Mode)
			if entry.Model != "" {
				fmt.Printf(", Model: %s", entry.Model)
			}
			fmt.Println()
		}
		fmt.Println()
	}

	return nil
}

type historyEntry struct {
	Timestamp string
	Query     string
	Mode      string
	Model     string
}

func readLastN(reader *history.Reader, n int) ([]any, error) {
	entries, err := reader.ReadLast(n)
	if err != nil {
		return nil, err
	}

	result := make([]any, len(entries))
	for i, e := range entries {
		result[i] = historyEntry{
			Timestamp: e.Timestamp.Format("2006-01-02 15:04"),
			Query:     e.Query,
			Mode:      e.Mode,
			Model:     e.Model,
		}
	}
	return result, nil
}

func init() {
	historyCmd.AddCommand(historyListCmd)
	historyCmd.AddCommand(historySearchCmd)
	historyCmd.AddCommand(historyShowCmd)
	historyCmd.AddCommand(historyClearCmd)

	historyCmd.Flags().IntVarP(&historyCount, "count", "n", 20, "Number of entries to show")
	historyListCmd.Flags().IntVarP(&historyCount, "count", "n", 20, "Number of entries to show")
}
</file>
<file path="cmd/perplexity/main.go">
// Package main is the entry point for the perplexity CLI.
package main

import (
	"os"
)

func main() {
	if err := Execute(); err != nil {
		os.Exit(1)
	}
}
</file>
<file path="cmd/perplexity/root.go">
package main

import (
	"context"
	"fmt"
	"io"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/diogo/perplexity-go/internal/auth"
	"github.com/mattn/go-isatty"
	"github.com/diogo/perplexity-go/internal/config"
	"github.com/diogo/perplexity-go/internal/history"
	"github.com/diogo/perplexity-go/internal/ui"
	"github.com/diogo/perplexity-go/pkg/client"
	"github.com/diogo/perplexity-go/pkg/models"
	"github.com/spf13/cobra"
)

var (
	// Flags
	flagModel      string
	flagMode       string
	flagSources    string
	flagLanguage   string
	flagStream     bool
	flagNoStream   bool
	flagIncognito  bool
	flagOutputFile string
	flagInputFile  string
	flagCookieFile string
	flagVerbose    bool

	// Global config
	cfg     *config.Config
	cfgMgr  *config.Manager
	render  *ui.Renderer
)

// rootCmd represents the base command.
var rootCmd = &cobra.Command{
	Use:   "perplexity [query]",
	Short: "Perplexity AI CLI - Search with AI",
	Long: `Perplexity CLI is a command-line interface for Perplexity AI.

It allows you to perform AI-powered searches directly from your terminal
with support for multiple models, streaming output, and file attachments.

The query can be provided as command-line arguments, from a file (-f), or via stdin (pipe).

Examples:
  perplexity "What is the capital of France?"
  perplexity "Explain quantum computing" --model gpt5 --mode pro
  perplexity "Latest news on AI" --sources web,scholar --stream
  echo "What is Go?" | perplexity
  perplexity -f prompt.md --mode pro
  perplexity -f question.txt -o answer.md`,
	Args: cobra.ArbitraryArgs,
	RunE: runQuery,
}

// Execute runs the root command.
func Execute() error {
	return rootCmd.Execute()
}

func init() {
	cobra.OnInitialize(initConfig)

	// Query flags
	rootCmd.Flags().StringVarP(&flagModel, "model", "m", "", "AI model to use (pplx_pro, gpt5, claude45sonnet, etc.)")
	rootCmd.Flags().StringVar(&flagMode, "mode", "", "Search mode (fast, pro, reasoning, deep-research, default)")
	rootCmd.Flags().StringVarP(&flagSources, "sources", "s", "", "Search sources (web,scholar,social)")
	rootCmd.Flags().StringVarP(&flagLanguage, "language", "l", "", "Response language (e.g., en-US, pt-BR)")
	rootCmd.Flags().BoolVar(&flagStream, "stream", false, "Enable streaming output")
	rootCmd.Flags().BoolVar(&flagNoStream, "no-stream", false, "Disable streaming output")
	rootCmd.Flags().BoolVarP(&flagIncognito, "incognito", "i", false, "Don't save to history")
	rootCmd.Flags().StringVarP(&flagOutputFile, "output", "o", "", "Save response to file")
	rootCmd.Flags().StringVarP(&flagInputFile, "file", "f", "", "Read query from file (takes precedence over args/stdin)")
	rootCmd.Flags().StringVarP(&flagCookieFile, "cookies", "c", "", "Path to cookies.json file")
	rootCmd.Flags().BoolVarP(&flagVerbose, "verbose", "v", false, "Verbose output")

	// Add subcommands
	rootCmd.AddCommand(configCmd)
	rootCmd.AddCommand(historyCmd)
	rootCmd.AddCommand(cookiesCmd)
	rootCmd.AddCommand(versionCmd)
	rootCmd.AddCommand(importCookiesCmd)
}

func initConfig() {
	var err error

	// Initialize config manager
	cfgMgr, err = config.NewManager()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error initializing config: %v\n", err)
		os.Exit(1)
	}

	// Load configuration
	cfg, err = cfgMgr.Load()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
		os.Exit(1)
	}

	// Initialize renderer
	render, err = ui.NewRenderer()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error initializing renderer: %v\n", err)
		os.Exit(1)
	}
}

func runQuery(cmd *cobra.Command, args []string) error {
	var query string
	var err error

	// Priority: -f/--file > args > stdin
	// 1. Check if -f/--file flag is provided
	if flagInputFile != "" {
		query, err = getQueryFromFile(flagInputFile)
		if err != nil {
			render.RenderError(err)
			return err
		}
	}

	// 2. If query is still empty, try args or stdin
	if query == "" {
		isTerminal := isatty.IsTerminal(os.Stdin.Fd()) || isatty.IsCygwinTerminal(os.Stdin.Fd())
		query, err = getQueryFromInput(args, os.Stdin, isTerminal)
		if err != nil {
			render.RenderError(err)
			return err
		}
	}

	// If query is still empty, show help
	if query == "" {
		return cmd.Help()
	}

	// Determine cookie file
	cookieFile := cfg.CookieFile
	if flagCookieFile != "" {
		cookieFile = flagCookieFile
	}

	// Check if cookies exist
	if _, err := os.Stat(cookieFile); os.IsNotExist(err) {
		render.RenderError(fmt.Errorf("cookies file not found: %s", cookieFile))
		render.RenderInfo("Run 'perplexity import-cookies <file>' to import cookies from browser")
		return fmt.Errorf("no cookies found")
	}

	// Load cookies
	cookies, err := auth.LoadCookiesFromFile(cookieFile)
	if err != nil {
		render.RenderError(fmt.Errorf("failed to load cookies: %v", err))
		return err
	}

	// Create client
	cli, err := client.NewWithCookies(cookies)
	if err != nil {
		render.RenderError(fmt.Errorf("failed to create client: %v", err))
		return err
	}
	defer cli.Close()

	// Build search options
	opts := buildSearchOptions(query)

	// Setup context with cancellation
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Handle interrupt
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-sigCh
		cancel()
	}()

	// Determine if streaming
	streaming := cfg.Streaming
	if flagStream {
		streaming = true
	}
	if flagNoStream {
		streaming = false
	}
	opts.Stream = streaming

	if flagVerbose {
		render.RenderInfo(fmt.Sprintf("Query: %s", query))
		render.RenderInfo(fmt.Sprintf("Mode: %s, Model: %s", opts.Mode, opts.Model))
		render.RenderInfo(fmt.Sprintf("Streaming: %v", streaming))
		render.NewLine()
	}

	var responseText string

	if streaming {
		// Streaming mode
		ch, err := cli.SearchStream(ctx, opts)
		if err != nil {
			render.RenderError(err) // Render error from stream initiation
			return err
		}

		var fullResponse strings.Builder
		var allWebResults []models.WebResult
		for chunk := range ch {
			if chunk.Error != nil { // Handle all chunk errors
				if chunk.Error == context.Canceled {
					render.NewLine()
					render.RenderWarning("Search cancelled")
					break // Exit loop on cancel
				}
				// Report other errors
				render.RenderError(chunk.Error)
				return chunk.Error
			}

			// For new step-based format, only render FINAL step
			if chunk.StepType == "FINAL" && chunk.Text != "" {
				// Render as markdown instead of raw text
				if err := render.RenderStyledResponse(chunk.Text); err != nil {
					render.RenderStreamChunk(chunk)
				}
				fullResponse.WriteString(chunk.Text)
				allWebResults = append(allWebResults, chunk.WebResults...)
			} else if chunk.StepType == "" {
				// Legacy format - render as stream
				render.RenderStreamChunk(chunk)
				if chunk.Delta != "" {
					fullResponse.WriteString(chunk.Delta)
				} else if chunk.Text != "" {
					fullResponse.WriteString(chunk.Text)
				}
			}
		}
		render.NewLine()

		// Post-stream rendering of the full accumulated response (with new styling/markdown)
		if fullResponse.Len() > 0 {
			if err := render.RenderStyledResponse(fullResponse.String()); err != nil {
				// If final styled rendering fails, the raw stream output is still there.
				render.RenderError(fmt.Errorf("failed to render final response: %w", err))
			}
		}

		// Render web results if any
		if len(allWebResults) > 0 {
			render.RenderWebResults(allWebResults)
		}

		responseText = fullResponse.String()
	} else {
		// Non-streaming mode with spinner
		done := make(chan struct{})
		go func() {
			frame := 0
			for {
				select {
				case <-done:
					render.ClearLine()
					return
				case <-time.After(100 * time.Millisecond):
					render.RenderSpinner(frame)
					frame++
				}
			}
		}()

		resp, err := cli.Search(ctx, opts)
		close(done)

		if err != nil {
			if err == context.Canceled {
				render.RenderWarning("Search cancelled")
				return nil
			}
			render.RenderError(err)
			return err
		}

		if err := render.RenderResponse(resp); err != nil {
			render.RenderError(err)
			return err
		}
		responseText = resp.Text
	}

	// Save to output file if specified
	if flagOutputFile != "" {
		if err := os.WriteFile(flagOutputFile, []byte(responseText), 0644); err != nil {
			render.RenderError(fmt.Errorf("failed to save output: %v", err))
		} else {
			render.RenderSuccess(fmt.Sprintf("Saved to %s", flagOutputFile))
		}
	}

	// Save to history if not incognito
	if !flagIncognito && !cfg.Incognito {
		hw, err := history.NewWriter(cfg.HistoryFile)
		if err == nil {
			hw.Append(models.HistoryEntry{
				Query:    query,
				Mode:     string(opts.Mode),
				Model:    string(opts.Model),
				Response: truncateResponse(responseText, 500),
			})
		}
	}

	return nil
}

func buildSearchOptions(query string) models.SearchOptions {
	opts := models.DefaultSearchOptions(query)

	// Apply config defaults
	opts.Model = cfg.DefaultModel
	opts.Mode = cfg.DefaultMode
	opts.Language = cfg.DefaultLanguage
	opts.Sources = cfg.DefaultSources
	opts.Incognito = cfg.Incognito

	// Override with flags
	if flagModel != "" {
		opts.Model = models.Model(flagModel)
	}
	if flagMode != "" {
		opts.Mode = models.Mode(flagMode)
	}
	if flagLanguage != "" {
		opts.Language = flagLanguage
	}
	if flagSources != "" {
		sources := strings.Split(flagSources, ",")
		opts.Sources = make([]models.Source, 0, len(sources))
		for _, s := range sources {
			opts.Sources = append(opts.Sources, models.Source(strings.TrimSpace(s)))
		}
	}
	if flagIncognito {
		opts.Incognito = true
	}

	return opts
}

func truncateResponse(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}

// getQueryFromInput extracts the query from command-line args or stdin.
// This function is exported for testing purposes.
func getQueryFromInput(args []string, stdin io.Reader, isTerminal bool) (string, error) {
	if len(args) > 0 {
		return strings.Join(args, " "), nil
	}

	// If stdin is not a terminal, try to read from it
	if !isTerminal {
		data, err := io.ReadAll(stdin)
		if err != nil {
			return "", fmt.Errorf("failed to read from stdin: %w", err)
		}
		return strings.TrimSpace(string(data)), nil
	}

	return "", nil
}

// getQueryFromFile reads the query content from a file.
// Returns the trimmed content or an error if the file cannot be read.
func getQueryFromFile(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", fmt.Errorf("failed to read input file %s: %w", path, err)
	}
	content := strings.TrimSpace(string(data))
	if content == "" {
		return "", fmt.Errorf("input file %s is empty", path)
	}
	return content, nil
}
</file>
<file path="cmd/perplexity/root_integration_test.go.broken">
package main

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	http "github.com/bogdanfinn/fhttp"
	"github.com/diogo/perplexity-go/internal/auth"
	"github.com/diogo/perplexity-go/internal/config"
	"github.com/diogo/perplexity-go/internal/history"
	"github.com/diogo/perplexity-go/pkg/models"
	"github.com/spf13/cobra"
)

// FullMockClient is a comprehensive mock for end-to-end testing
type FullMockClient struct {
	searchResponse  *models.SearchResponse
	searchError     error
	streamChunks    []models.StreamChunk
	streamError     error
	closeError      error
	cookies         []*http.Cookie
	hasValidSession bool
	proQueriesRem   int
	fileUploadsRem  int
}

func NewFullMockClient(response *models.SearchResponse, err error) *FullMockClient {
	return &FullMockClient{
		searchResponse:  response,
		searchError:     err,
		hasValidSession: true,
		proQueriesRem:   5,
		fileUploadsRem:  10,
	}
}

func NewFullStreamMockClient(chunks []models.StreamChunk, err error) *FullMockClient {
	return &FullMockClient{
		streamChunks:    chunks,
		streamError:     err,
		hasValidSession: true,
		proQueriesRem:   5,
		fileUploadsRem:  10,
	}
}

func (m *FullMockClient) Search(ctx context.Context, opts models.SearchOptions) (*models.SearchResponse, error) {
	return m.searchResponse, m.searchError
}

func (m *FullMockClient) SearchStream(ctx context.Context, opts models.SearchOptions) (<-chan models.StreamChunk, error) {
	ch := make(chan models.StreamChunk, len(m.streamChunks))
	if m.streamError != nil {
		ch <- models.StreamChunk{Error: m.streamError}
		close(ch)
		return ch, m.streamError
	}
	for _, chunk := range m.streamChunks {
		ch <- chunk
	}
	close(ch)
	return ch, nil
}

func (m *FullMockClient) Close() error {
	return m.closeError
}

func (m *FullMockClient) SetCookies(cookies []*http.Cookie) {
	m.cookies = cookies
}

func (m *FullMockClient) GetCookies() []*http.Cookie {
	return m.cookies
}

func (m *FullMockClient) HasValidSession() bool {
	return m.hasValidSession
}

func (m *FullMockClient) ProQueriesRemaining() int {
	return m.proQueriesRem
}

func (m *FullMockClient) FileUploadsRemaining() int {
	return m.fileUploadsRem
}

// TestCompleteQueryFlow tests the complete end-to-end query flow
func TestCompleteQueryFlow(t *testing.T) {
	tempDir := t.TempDir()

	// Test files
	queryFile := filepath.Join(tempDir, "query.txt")
	outputFile := filepath.Join(tempDir, "output.md")
	cookieFile := filepath.Join(tempDir, "cookies.json")
	historyFile := filepath.Join(tempDir, "history.jsonl")

	// Create test files
	err := os.WriteFile(queryFile, []byte("What is artificial intelligence?"), 0644)
	if err != nil {
		t.Fatalf("failed to create query file: %v", err)
	}

	cookieJSON := `[{"name": "next-auth.csrf-token", "value": "test123", "domain": ".perplexity.ai", "path": "/"}]`
	err = os.WriteFile(cookieFile, []byte(cookieJSON), 0644)
	if err != nil {
		t.Fatalf("failed to create cookie file: %v", err)
	}

	t.Run("complete flow with file input, streaming, and output", func(t *testing.T) {
		// Setup configuration
		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModePro,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb, models.SourceScholar},
			CookieFile:      cookieFile,
			HistoryFile:     historyFile,
			Streaming:       false,
			Incognito:       false,
		}

		// Set flags for the test
		flagInputFile = queryFile
		flagOutputFile = outputFile
		flagCookieFile = ""
		flagIncognito = false
		flagStream = true
		flagVerbose = false

		// Create mock response
		mockResponse := &models.SearchResponse{
			Text: "Artificial intelligence (AI) is a branch of computer science...",
		}

		// This test demonstrates the flow setup
		// In a real integration test with DI, we would execute runQuery

		// Verify setup
		if cfg.CookieFile == "" {
			t.Fatal("cookie file not configured")
		}
		if !strings.Contains(cfg.DefaultSources.String(), "web") {
			t.Error("sources should include web")
		}
		if flagInputFile == "" {
			t.Fatal("input file not set")
		}

		// Verify cookie file can be loaded
		cookies, err := auth.LoadCookiesFromFile(cookieFile)
		if err != nil {
			t.Fatalf("failed to load cookies: %v", err)
		}
		if len(cookies) == 0 {
			t.Fatal("no cookies loaded")
		}
	})

	t.Run("complete flow with args input, non-streaming, and history", func(t *testing.T) {
		cfg = &config.Config{
			DefaultModel:    models.ModelGPT51,
			DefaultMode:     models.ModeFast,
			DefaultLanguage: "pt-BR",
			DefaultSources:  []models.Source{models.SourceWeb},
			CookieFile:      cookieFile,
			HistoryFile:     historyFile,
			Streaming:       true,
			Incognito:       false,
		}

		// Set flags
		flagInputFile = ""
		flagOutputFile = ""
		flagCookieFile = ""
		flagIncognito = false
		flagStream = false
		flagVerbose = true

		// Create mock response
		mockResponse := &models.SearchResponse{
			Text: "Go é uma linguagem de programação...",
		}

		// Verify configuration
		if cfg.DefaultModel != models.ModelGPT51 {
			t.Errorf("expected model %s, got %s", models.ModelGPT51, cfg.DefaultModel)
		}
		if cfg.DefaultMode != models.ModeFast {
			t.Errorf("expected mode %s, got %s", models.ModeFast, cfg.DefaultMode)
		}
	})

	t.Run("stdin input flow", func(t *testing.T) {
		stdin := strings.NewReader("Query from stdin")
		isTerminal := false

		query, err := getQueryFromInput([]string{}, stdin, isTerminal)
		if err != nil {
			t.Fatalf("failed to read from stdin: %v", err)
		}

		if query != "Query from stdin" {
			t.Errorf("expected 'Query from stdin', got %q", query)
		}
	})

	t.Run("complete flow with output file", func(t *testing.T) {
		testContent := "# Response\n\nThis is the answer."
		err := os.WriteFile(outputFile, []byte(testContent), 0644)
		if err != nil {
			t.Fatalf("failed to write output file: %v", err)
		}

		// Verify file was created
		data, err := os.ReadFile(outputFile)
		if err != nil {
			t.Fatalf("failed to read output file: %v", err)
		}

		if string(data) != testContent {
			t.Errorf("content mismatch")
		}
	})
}

// TestStreamingResponseFlow tests various streaming scenarios
func TestStreamingResponseFlow(t *testing.T) {
	tempDir := t.TempDir()
	cookieFile := filepath.Join(tempDir, "cookies.json")

	cookieJSON := `[{"name": "next-auth.csrf-token", "value": "test", "domain": ".perplexity.ai"}]`
	err := os.WriteFile(cookieFile, []byte(cookieJSON), 0644)
	if err != nil {
		t.Fatalf("failed to create cookie file: %v", err)
	}

	t.Run("step-based streaming format", func(t *testing.T) {
		chunks := []models.StreamChunk{
			{StepType: "THINKING", Text: "Thinking...", Delta: "Thinking..."},
			{StepType: "FINAL", Text: "This is the final answer.", Delta: "This is the final answer."},
		}

		mockClient := NewFullStreamMockClient(chunks, nil)
		ch, err := mockClient.SearchStream(context.Background(), models.SearchOptions{Query: "test"})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Read chunks
		received := 0
		for range ch {
			received++
		}

		if received != len(chunks) {
			t.Errorf("expected %d chunks, got %d", len(chunks), received)
		}
	})

	t.Run("legacy streaming format", func(t *testing.T) {
		chunks := []models.StreamChunk{
			{Delta: "First ", StepType: ""},
			{Delta: "chunk", StepType: ""},
			{Delta: " of text", StepType: ""},
		}

		mockClient := NewFullStreamMockClient(chunks, nil)
		ch, err := mockClient.SearchStream(context.Background(), models.SearchOptions{Query: "test"})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Read chunks
		received := 0
		var fullText string
		for chunk := range ch {
			received++
			fullText += chunk.Delta
		}

		if received != len(chunks) {
			t.Errorf("expected %d chunks, got %d", len(chunks), received)
		}
		if fullText != "First chunk of text" {
			t.Errorf("expected 'First chunk of text', got %q", fullText)
		}
	})

	t.Run("streaming with web results", func(t *testing.T) {
		chunks := []models.StreamChunk{
			{
				StepType: "FINAL",
				Text:     "Answer text",
				WebResults: []models.WebResult{
					{Title: "Result 1", URL: "http://example.com", Snippet: "Snippet 1"},
					{Title: "Result 2", URL: "http://example.org", Snippet: "Snippet 2"},
				},
			},
		}

		mockClient := NewFullStreamMockClient(chunks, nil)
		ch, err := mockClient.SearchStream(context.Background(), models.SearchOptions{Query: "test"})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Read chunks and collect web results
		var webResults []models.WebResult
		for chunk := range ch {
			webResults = append(webResults, chunk.WebResults...)
		}

		if len(webResults) != 2 {
			t.Errorf("expected 2 web results, got %d", len(webResults))
		}
	})

	t.Run("streaming error handling", func(t *testing.T) {
		mockClient := NewFullStreamMockClient(nil, fmt.Errorf("API error"))
		ch, err := mockClient.SearchStream(context.Background(), models.SearchOptions{Query: "test"})

		if err == nil {
			t.Error("expected error, got nil")
		}
		if err.Error() != "API error" {
			t.Errorf("expected 'API error', got %v", err)
		}

		// Channel should still receive error chunk
		received := 0
		for range ch {
			received++
		}
		if received != 1 {
			t.Errorf("expected 1 error chunk, got %d", received)
		}
	})

	t.Run("context cancellation in streaming", func(t *testing.T) {
		chunks := []models.StreamChunk{
			{Delta: "First", StepType: "FINAL"},
			{Delta: "Second", StepType: "FINAL"},
			{Delta: "Third", StepType: "FINAL"},
		}

		mockClient := NewFullStreamMockClient(chunks, nil)
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		ch, err := mockClient.SearchStream(ctx, models.SearchOptions{Query: "test"})
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Receive first chunk
		chunk := <-ch
		if chunk.Delta != "First" {
			t.Errorf("expected 'First', got %q", chunk.Delta)
		}

		// Cancel context
		cancel()

		// Next chunk should be error (context canceled)
		chunk = <-ch
		if chunk.Error != context.Canceled {
			t.Errorf("expected context.Canceled error, got %v", chunk.Error)
		}
	})
}

// TestNonStreamingResponseFlow tests non-streaming response scenarios
func TestNonStreamingResponseFlow(t *testing.T) {
	tempDir := t.TempDir()
	cookieFile := filepath.Join(tempDir, "cookies.json")

	cookieJSON := `[{"name": "next-auth.csrf-token", "value": "test", "domain": ".perplexity.ai"}]`
	err := os.WriteFile(cookieFile, []byte(cookieJSON), 0644)
	if err != nil {
		t.Fatalf("failed to create cookie file: %v", err)
	}

	t.Run("successful non-streaming response", func(t *testing.T) {
		mockClient := NewFullMockClient(&models.SearchResponse{
			Text: "This is a complete response",
		}, nil)

		resp, err := mockClient.Search(context.Background(), models.SearchOptions{Query: "test", Stream: false})
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if resp == nil {
			t.Fatal("response is nil")
		}
		if resp.Text != "This is a complete response" {
			t.Errorf("expected response text, got %q", resp.Text)
		}
	})

	t.Run("API error in non-streaming", func(t *testing.T) {
		mockClient := NewFullMockClient(nil, fmt.Errorf("rate limit exceeded"))

		resp, err := mockClient.Search(context.Background(), models.SearchOptions{Query: "test", Stream: false})
		if err == nil {
			t.Error("expected error, got nil")
		}
		if resp != nil {
			t.Error("response should be nil on error")
		}
	})

	t.Run("empty response text", func(t *testing.T) {
		mockClient := NewFullMockClient(&models.SearchResponse{}, nil)

		resp, err := mockClient.Search(context.Background(), models.SearchOptions{Query: "test", Stream: false})
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if resp == nil {
			t.Fatal("response is nil")
		}
	})
}

// TestFileOperationsIntegration tests file input/output operations
func TestFileOperationsIntegration(t *testing.T) {
	tempDir := t.TempDir()

	t.Run("input from markdown file", func(t *testing.T) {
		mdFile := filepath.Join(tempDir, "prompt.md")
		mdContent := `# Question

What is the difference between Go and Python?

Please explain with examples.`

		err := os.WriteFile(mdFile, []byte(mdContent), 0644)
		if err != nil {
			t.Fatalf("failed to write markdown file: %v", err)
		}

		content, err := getQueryFromFile(mdFile)
		if err != nil {
			t.Fatalf("failed to read markdown file: %v", err)
		}

		if !strings.Contains(content, "Go and Python") {
			t.Error("markdown content should be preserved")
		}
	})

	t.Run("output to markdown file with formatting", func(t *testing.T) {
		outputFile := filepath.Join(tempDir, "answer.md")
		mdContent := "# Answer\n\nThis is **bold** and this is *italic*.\n\n- Item 1\n- Item 2"

		err := os.WriteFile(outputFile, []byte(mdContent), 0644)
		if err != nil {
			t.Fatalf("failed to write output file: %v", err)
		}

		data, err := os.ReadFile(outputFile)
		if err != nil {
			t.Fatalf("failed to read output file: %v", err)
		}

		if string(data) != mdContent {
			t.Error("output content mismatch")
		}
	})

	t.Run("binary file handling", func(t *testing.T) {
		// Test that binary files are handled correctly
		binaryFile := filepath.Join(tempDir, "binary.bin")
		binaryContent := []byte{0x89, 0x50, 0x4E, 0x47} // PNG header

		err := os.WriteFile(binaryFile, binaryContent, 0644)
		if err != nil {
			t.Fatalf("failed to write binary file: %v", err)
		}

		content, err := getQueryFromFile(binaryFile)
		if err != nil {
			t.Fatalf("failed to read binary file: %v", err)
		}

		// Content should be read as bytes and converted to string
		if len(content) == 0 {
			t.Error("binary file should have content")
		}
	})

	t.Run("unicode content", func(t *testing.T) {
		unicodeFile := filepath.Join(tempDir, "unicode.txt")
		unicodeContent := "こんにちは世界 🌍 café naïve résumé"

		err := os.WriteFile(unicodeFile, []byte(unicodeContent), 0644)
		if err != nil {
			t.Fatalf("failed to write unicode file: %v", err)
		}

		content, err := getQueryFromFile(unicodeFile)
		if err != nil {
			t.Fatalf("failed to read unicode file: %v", err)
		}

		if content != unicodeContent {
			t.Error("unicode content should be preserved")
		}
	})

	t.Run("large file handling", func(t *testing.T) {
		largeFile := filepath.Join(tempDir, "large.txt")
		largeContent := strings.Repeat("Line of text. ", 10000)

		err := os.WriteFile(largeFile, []byte(largeContent), 0644)
		if err != nil {
			t.Fatalf("failed to write large file: %v", err)
		}

		start := time.Now()
		content, err := getQueryFromFile(largeFile)
		elapsed := time.Since(start)

		if err != nil {
			t.Fatalf("failed to read large file: %v", err)
		}

		if len(content) != len(largeContent) {
			t.Errorf("content length mismatch: got %d, want %d", len(content), len(largeContent))
		}

		// Should be able to read large file reasonably fast
		if elapsed > 5*time.Second {
			t.Errorf("reading large file took too long: %v", elapsed)
		}
	})

	t.Run("permission denied error", func(t *testing.T) {
		// Skip on Windows
		if os.Getenv("GOOS") == "windows" {
			t.Skip("Skipping permission test on Windows")
		}

		noPermFile := filepath.Join(tempDir, "noperm.txt")
		err := os.WriteFile(noPermFile, []byte("content"), 0000)
		if err != nil {
			t.Fatalf("failed to create file: %v", err)
		}
		defer os.Chmod(noPermFile, 0644)

		_, err = getQueryFromFile(noPermFile)
		if err == nil {
			t.Error("expected permission denied error")
		}
	})
}

// TestSearchOptionsBuildIntegration tests buildSearchOptions with integration scenarios
func TestSearchOptionsBuildIntegration(t *testing.T) {
	// Save state
	origCfg := cfg
	origFlagModel := flagModel
	origFlagMode := flagMode
	origFlagLanguage := flagLanguage
	origFlagSources := flagSources
	origFlagIncognito := flagIncognito

	defer func() {
		cfg = origCfg
		flagModel = origFlagModel
		flagMode = origFlagMode
		flagLanguage = origFlagLanguage
		flagSources = origFlagSources
		flagIncognito = origFlagIncognito
	}()

	t.Run("all models with correct modes", func(t *testing.T) {
		testCases := []struct {
			model    string
			mode     string
			expected models.Mode
		}{
			{"gpt51", "pro", models.ModePro},
			{"pplx_pro", "fast", models.ModeFast},
			{"gpt51_thinking", "reasoning", models.ModeReasoning},
			{"claude45sonnet", "pro", models.ModePro},
			{"experimental", "pro", models.ModePro},
		}

		for _, tc := range testCases {
			cfg = &config.Config{
				DefaultModel:    models.ModelPplxPro,
				DefaultMode:     models.ModeDefault,
				DefaultLanguage: "en-US",
				DefaultSources:  []models.Source{models.SourceWeb},
			}

			flagModel = tc.model
			flagMode = tc.mode
			flagLanguage = ""
			flagSources = ""
			flagIncognito = false

			opts := buildSearchOptions("test query")

			if opts.Model != models.Model(tc.model) {
				t.Errorf("model mismatch for %s: got %q, want %q", tc.model, opts.Model, tc.model)
			}
			if opts.Mode != tc.expected {
				t.Errorf("mode mismatch for %s: got %q, want %q", tc.model, opts.Mode, tc.expected)
			}
		}
	})

	t.Run("sources parsing", func(t *testing.T) {
		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModeDefault,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb},
		}

		flagModel = ""
		flagMode = ""
		flagLanguage = ""
		flagSources = "web,scholar,social"
		flagIncognito = false

		opts := buildSearchOptions("test query")

		if len(opts.Sources) != 3 {
			t.Errorf("expected 3 sources, got %d", len(opts.Sources))
		}

		expectedSources := []models.Source{models.SourceWeb, models.SourceScholar, models.SourceSocial}
		for i, src := range opts.Sources {
			if src != expectedSources[i] {
				t.Errorf("source %d: got %q, want %q", i, src, expectedSources[i])
			}
		}
	})

	t.Run("sources with whitespace", func(t *testing.T) {
		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModeDefault,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb},
		}

		flagModel = ""
		flagMode = ""
		flagLanguage = ""
		flagSources = " web , scholar , social "
		flagIncognito = false

		opts := buildSearchOptions("test query")

		if len(opts.Sources) != 3 {
			t.Errorf("expected 3 sources (whitespace trimmed), got %d", len(opts.Sources))
		}
	})

	t.Run("incognito flag precedence", func(t *testing.T) {
		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModeDefault,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb},
			Incognito:       false,
		}

		flagModel = ""
		flagMode = ""
		flagLanguage = ""
		flagSources = ""
		flagIncognito = true

		opts := buildSearchOptions("test query")

		if !opts.Incognito {
			t.Error("incognito flag should override config")
		}
	})

	t.Run("language override", func(t *testing.T) {
		cfg = &config.Config{
			DefaultModel:    models.ModelPplxPro,
			DefaultMode:     models.ModeDefault,
			DefaultLanguage: "en-US",
			DefaultSources:  []models.Source{models.SourceWeb},
		}

		flagModel = ""
		flagMode = ""
		flagLanguage = "es-ES"
		flagSources = ""
		flagIncognito = false

		opts := buildSearchOptions("test query")

		if opts.Language != "es-ES" {
			t.Errorf("expected language es-ES, got %q", opts.Language)
		}
	})
}

// TestSearchIntegrationWithHistory tests search integration with history
func TestSearchIntegrationWithHistory(t *testing.T) {
	tempDir := t.TempDir()
	historyFile := filepath.Join(tempDir, "history.jsonl")

	t.Run("history entry creation", func(t *testing.T) {
		hw, err := history.NewWriter(historyFile)
		if err != nil {
			t.Fatalf("failed to create history writer: %v", err)
		}

		entry := models.HistoryEntry{
			Query:    "What is Go?",
			Mode:     "pro",
			Model:    "gpt51",
			Response: "Go is a programming language developed by Google.",
		}

		hw.Append(entry)

		// Verify entry was written
		reader := history.NewReader(historyFile)
		entries, err := reader.ReadAll()
		if err != nil {
			t.Fatalf("failed to read history: %v", err)
		}

		if len(entries) != 1 {
			t.Errorf("expected 1 history entry, got %d", len(entries))
		}

		if entries[0].Query != entry.Query {
			t.Errorf("query mismatch: got %q, want %q", entries[0].Query, entry.Query)
		}
	})

	t.Run("multiple history entries", func(t *testing.T) {
		hw, err := history.NewWriter(historyFile)
		if err != nil {
			t.Fatalf("failed to create history writer: %v", err)
		}

		queries := []string{
			"Query 1",
			"Query 2",
			"Query 3",
		}

		for i, query := range queries {
			hw.Append(models.HistoryEntry{
				Query:    query,
				Mode:     "pro",
				Model:    "gpt51",
				Response: fmt.Sprintf("Response %d", i+1),
			})
		}

		reader := history.NewReader(historyFile)
		entries, err := reader.ReadAll()
		if err != nil {
			t.Fatalf("failed to read history: %v", err)
		}

		if len(entries) != 3 {
			t.Errorf("expected 3 history entries, got %d", len(entries))
		}
	})

	t.Run("history search integration", func(t *testing.T) {
		hw, err := history.NewWriter(historyFile)
		if err != nil {
			t.Fatalf("failed to create history writer: %v", err)
		}

		// Add entries with searchable terms
		entries := []models.HistoryEntry{
			{Query: "Go programming language tutorial", Mode: "pro", Model: "gpt51", Response: "Response 1"},
			{Query: "Python for beginners", Mode: "fast", Model: "pplx_pro", Response: "Response 2"},
			{Query: "Rust vs Go comparison", Mode: "reasoning", Model: "gpt51_thinking", Response: "Response 3"},
		}

		for _, entry := range entries {
			hw.Append(entry)
		}

		// Search for "Go"
		reader := history.NewReader(historyFile)
		results, err := reader.Search("Go")
		if err != nil {
			t.Fatalf("failed to search history: %v", err)
		}

		// Should find entries 1 and 3
		if len(results) != 2 {
			t.Errorf("expected 2 results for 'Go', got %d", len(results))
		}

		for _, result := range results {
			if !strings.Contains(strings.ToLower(result.Query), "go") {
				t.Errorf("search result should contain 'Go': %q", result.Query)
			}
		}
	})

	t.Run("response truncation for history", func(t *testing.T) {
		longResponse := strings.Repeat("Long response. ", 100)

		truncated := truncateResponse(longResponse, 500)

		if len(truncated) > 503 { // 500 + "..."
			t.Errorf("truncated response too long: %d characters", len(truncated))
		}

		if !strings.HasSuffix(truncated, "...") {
			t.Error("truncated response should end with '...'")
		}
	})
}

// TestCookieValidationIntegration tests cookie validation scenarios
func TestCookieValidationIntegration(t *testing.T) {
	tempDir := t.TempDir()

	t.Run("valid cookie file", func(t *testing.T) {
		cookieFile := filepath.Join(tempDir, "valid.json")
		cookieJSON := `[
			{
				"name": "next-auth.csrf-token",
				"value": "abc123",
				"domain": ".perplexity.ai",
				"path": "/"
			}
		]`

		err := os.WriteFile(cookieFile, []byte(cookieJSON), 0644)
		if err != nil {
			t.Fatalf("failed to write cookie file: %v", err)
		}

		cookies, err := auth.LoadCookiesFromFile(cookieFile)
		if err != nil {
			t.Fatalf("failed to load cookies: %v", err)
		}

		if len(cookies) != 1 {
			t.Errorf("expected 1 cookie, got %d", len(cookies))
		}

		if cookies[0].Name != "next-auth.csrf-token" {
			t.Errorf("expected cookie name 'next-auth.csrf-token', got %q", cookies[0].Name)
		}
	})

	t.Run("invalid JSON cookie file", func(t *testing.T) {
		cookieFile := filepath.Join(tempDir, "invalid.json")
		invalidJSON := `{"name": "next-auth.csrf-token", "value": "test"` // Missing closing brace

		err := os.WriteFile(cookieFile, []byte(invalidJSON), 0644)
		if err != nil {
			t.Fatalf("failed to write cookie file: %v", err)
		}

		_, err = auth.LoadCookiesFromFile(cookieFile)
		if err == nil {
			t.Error("expected error for invalid JSON, got nil")
		}
	})

	t.Run("empty cookie file", func(t *testing.T) {
		cookieFile := filepath.Join(tempDir, "empty.json")

		err := os.WriteFile(cookieFile, []byte("[]"), 0644)
		if err != nil {
			t.Fatalf("failed to write cookie file: %v", err)
		}

		cookies, err := auth.LoadCookiesFromFile(cookieFile)
		if err != nil {
			t.Fatalf("failed to load cookies: %v", err)
		}

		if len(cookies) != 0 {
			t.Errorf("expected 0 cookies, got %d", len(cookies))
		}
	})

	t.Run("missing csrf-token cookie", func(t *testing.T) {
		cookieFile := filepath.Join(tempDir, "missing_csrf.json")
		cookieJSON := `[
			{
				"name": "other-cookie",
				"value": "value",
				"domain": ".perplexity.ai"
			}
		]`

		err := os.WriteFile(cookieFile, []byte(cookieJSON), 0644)
		if err != nil {
			t.Fatalf("failed to write cookie file: %v", err)
		}

		cookies, err := auth.LoadCookiesFromFile(cookieFile)
		if err != nil {
			t.Fatalf("failed to load cookies: %v", err)
		}

		// Client should detect missing csrf-token
		// This would fail during client initialization in real usage
	})

	t.Run("Netscape format cookie file", func(t *testing.T) {
		cookieFile := filepath.Join(tempDir, "netscape.txt")
		netscapeFormat := `# Netscape HTTP Cookie File
.perplexity.ai	TRUE	/	FALSE	1735689600	next-auth.csrf-token	abc123`

		err := os.WriteFile(cookieFile, []byte(netscapeFormat), 0644)
		if err != nil {
			t.Fatalf("failed to write cookie file: %v", err)
		}

		cookies, err := auth.LoadCookiesFromFile(cookieFile)
		if err != nil {
			t.Fatalf("failed to load cookies: %v", err)
		}

		// Should parse at least one cookie
		if len(cookies) == 0 {
			t.Error("should parse cookies from Netscape format")
		}
	})
}

// TestContextCancellationIntegration tests context cancellation scenarios
func TestContextCancellationIntegration(t *testing.T) {
	t.Run("SIGINT handling simulation", func(t *testing.T) {
		// Create a channel to simulate signal handling
		sigCh := make(chan os.Signal, 1)

		// In real runQuery, this would be:
		// signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)

		// Simulate receiving SIGINT
		// sigCh <- os.Interrupt

		// Context should be cancelled
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		// Simulate cancellation
		cancel()

		// Verify context is done
		select {
		case <-ctx.Done():
			// Expected
		default:
			t.Error("context should be done after cancellation")
		}
	})

	t.Run("streaming with cancellation", func(t *testing.T) {
		chunks := []models.StreamChunk{
			{Delta: "First chunk"},
			{Delta: "Second chunk"},
			{Delta: "Third chunk"},
		}

		mockClient := NewFullStreamMockClient(chunks, nil)
		ctx, cancel := context.WithCancel(context.Background())

		ch, err := mockClient.SearchStream(ctx, models.SearchOptions{Query: "test"})
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Receive first chunk
		chunk := <-ch
		if chunk.Delta != "First chunk" {
			t.Errorf("expected 'First chunk', got %q", chunk.Delta)
		}

		// Cancel context
		cancel()

		// Should receive error chunk
		errorChunk := <-ch
		if errorChunk.Error != context.Canceled {
			t.Errorf("expected context.Canceled error, got %v", errorChunk.Error)
		}
	})
}

// TestEnvironmentVariableIntegration tests environment variable integration
func TestEnvironmentVariableIntegration(t *testing.T) {
	t.Run("config with environment variables", func(t *testing.T) {
		// Note: The config package should handle environment variables
		// This test verifies the integration point

		// In the actual application, environment variables like:
		// PERPLEXITY_DEFAULT_MODEL, PERPLEXITY_DEFAULT_MODE, etc.
		// would be read by the config package

		// This is a placeholder for env var integration testing
		// The actual implementation is in internal/config
	})

	t.Run("environment variable precedence", func(t *testing.T) {
		// Test that environment variables can override config file
		// This would be tested in integration with the config package
	})
}

// TestVerboseModeIntegration tests verbose mode integration
func TestVerboseModeIntegration(t *testing.T) {
	tempDir := t.TempDir()
	cookieFile := filepath.Join(tempDir, "cookies.json")

	cookieJSON := `[{"name": "next-auth.csrf-token", "value": "test", "domain": ".perplexity.ai"}]`
	err := os.WriteFile(cookieFile, []byte(cookieJSON), 0644)
	if err != nil {
		t.Fatalf("failed to create cookie file: %v", err)
	}

	cfg = &config.Config{
		DefaultModel:    models.ModelPplxPro,
		DefaultMode:     models.ModePro,
		DefaultLanguage: "en-US",
		DefaultSources:  []models.Source{models.SourceWeb},
		CookieFile:      cookieFile,
	}

	t.Run("verbose mode outputs query info", func(t *testing.T) {
		flagVerbose = true

		// When verbose is true, runQuery should output:
		// - Query: <query>
		// - Mode: <mode>, Model: <model>
		// - Streaming: <streaming>

		opts := buildSearchOptions("verbose test query")

		if opts.Query != "verbose test query" {
			t.Error("query should be set correctly")
		}
	})

	t.Run("verbose mode with all flags", func(t *testing.T) {
		flagVerbose = true
		flagModel = "gpt51"
		flagMode = "reasoning"
		flagSources = "web,scholar"
		flagLanguage = "pt-BR"
		flagStream = true
		flagIncognito = true

		opts := buildSearchOptions("full verbose test")

		// All options should be set correctly for verbose output
		if opts.Model != models.ModelGPT51 {
			t.Error("model should be set for verbose output")
		}
	})
}

// TestConfigFileIntegration tests config file loading integration
func TestConfigFileIntegration(t *testing.T) {
	tempDir := t.TempDir()

	// Save and restore HOME
	oldHome := os.Getenv("HOME")
	defer func() { os.Setenv("HOME", oldHome) }()
	os.Setenv("HOME", tempDir)

	t.Run("complete config file integration", func(t *testing.T) {
		// Create config directory
		configDir := filepath.Join(tempDir, ".perplexity-cli")
		err := os.MkdirAll(configDir, 0700)
		if err != nil {
			t.Fatalf("failed to create config dir: %v", err)
		}

		// Write comprehensive config
		configFile := filepath.Join(configDir, "config.json")
		configJSON := `{
			"default_model": "claude45sonnet",
			"default_mode": "reasoning",
			"default_language": "fr-FR",
			"streaming": true,
			"incognito": false,
			"history_file": "my_history.jsonl"
		}`

		err = os.WriteFile(configFile, []byte(configJSON), 0644)
		if err != nil {
			t.Fatalf("failed to write config: %v", err)
		}

		// Load config
		mgr, err := config.NewManager()
		if err != nil {
			t.Fatalf("failed to create manager: %v", err)
		}

		testCfg, err := mgr.Load()
		if err != nil {
			t.Fatalf("failed to load config: %v", err)
		}

		// Verify all fields
		if testCfg.DefaultModel != "claude45sonnet" {
			t.Errorf("default model: got %q, want %q", testCfg.DefaultModel, "claude45sonnet")
		}
		if testCfg.DefaultMode != "reasoning" {
			t.Errorf("default mode: got %q, want %q", testCfg.DefaultMode, "reasoning")
		}
		if testCfg.DefaultLanguage != "fr-FR" {
			t.Errorf("default language: got %q, want %q", testCfg.DefaultLanguage, "fr-FR")
		}
		if testCfg.Streaming != true {
			t.Errorf("streaming: got %v, want %v", testCfg.Streaming, true)
		}
		if testCfg.Incognito != false {
			t.Errorf("incognito: got %v, want %v", testCfg.Incognito, false)
		}
		if testCfg.HistoryFile != "my_history.jsonl" {
			t.Errorf("history file: got %q, want %q", testCfg.HistoryFile, "my_history.jsonl")
		}
	})

	t.Run("missing config file uses defaults", func(t *testing.T) {
		// Don't create config file

		// Load config (should use defaults)
		mgr, err := config.NewManager()
		if err != nil {
			t.Fatalf("failed to create manager: %v", err)
		}

		testCfg, err := mgr.Load()
		if err != nil {
			t.Fatalf("failed to load config: %v", err)
		}

		// Should have default values
		if testCfg.DefaultModel == "" {
			t.Error("default model should have a value")
		}
		if testCfg.DefaultMode == "" {
			t.Error("default mode should have a value")
		}
	})

	t.Run("corrupted config file", func(t *testing.T) {
		configDir := filepath.Join(tempDir, ".perplexity-cli")
		err := os.MkdirAll(configDir, 0700)
		if err != nil {
			t.Fatalf("failed to create config dir: %v", err)
		}

		configFile := filepath.Join(configDir, "config.json")
		corruptedJSON := `{"default_model": "gpt51", "default_mode": "pro"` // Missing closing brace

		err = os.WriteFile(configFile, []byte(corruptedJSON), 0644)
		if err != nil {
			t.Fatalf("failed to write corrupted config: %v", err)
		}

		// Loading corrupted config should fail or use defaults
		mgr, err := config.NewManager()
		if err != nil {
			t.Fatalf("failed to create manager: %v", err)
		}

		_, err = mgr.Load()
		// Should either fail or fall back to defaults
		// The exact behavior depends on config package implementation
	})
}
</file>
<file path="cmd/perplexity/root_test.go">
package main

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"

	http "github.com/bogdanfinn/fhttp"
	"github.com/diogo/perplexity-go/internal/config"
	"github.com/diogo/perplexity-go/internal/ui"
	"github.com/diogo/perplexity-go/pkg/models"
	"github.com/spf13/cobra"
)

// errorReader is a mock reader that always returns an error
type errorReader struct{}

func (e *errorReader) Read(p []byte) (n int, err error) {
	return 0, errors.New("mock read error")
}

// MockClient is a mock implementation of the Perplexity client for testing
type MockClient struct {
	searchResponse   *models.SearchResponse
	searchError      error
	streamChunks     []models.StreamChunk
	streamError      error
	shouldCloseError error
}

// NewMockClient creates a new mock client with optional response
func NewMockClient(resp *models.SearchResponse, err error) *MockClient {
	return &MockClient{
		searchResponse: resp,
		searchError:    err,
	}
}

// NewMockStreamClient creates a mock client with streaming response
func NewMockStreamClient(chunks []models.StreamChunk, err error) *MockClient {
	return &MockClient{
		streamChunks: chunks,
		streamError:  err,
	}
}

func (m *MockClient) Search(ctx context.Context, opts models.SearchOptions) (*models.SearchResponse, error) {
	return m.searchResponse, m.searchError
}

func (m *MockClient) SearchStream(ctx context.Context, opts models.SearchOptions) (<-chan models.StreamChunk, error) {
	ch := make(chan models.StreamChunk, len(m.streamChunks))
	if m.streamError != nil {
		// Send error chunk and close
		ch <- models.StreamChunk{Error: m.streamError}
		close(ch)
		return ch, m.streamError
	}
	// Send all chunks
	for _, chunk := range m.streamChunks {
		ch <- chunk
	}
	close(ch)
	return ch, nil
}

func (m *MockClient) Close() error {
	return m.shouldCloseError
}

func (m *MockClient) SetCookies(cookies []*http.Cookie) {}

func (m *MockClient) GetCookies() []*http.Cookie {
	return nil
}

func (m *MockClient) HasValidSession() bool {
	return true
}

func (m *MockClient) ProQueriesRemaining() int {
	return 5
}

func (m *MockClient) FileUploadsRemaining() int {
	return 10
}

// MockRenderer is a mock implementation of the UI renderer for testing
type MockRenderer struct {
	renderedMessages []string
	renderedErrors   []error
	styledResponse   string
	streamChunks     []models.StreamChunk
	webResults       []models.WebResult
}

// NewMockRenderer creates a new mock renderer
func NewMockRenderer() *ui.Renderer {
	// For testing, we'll use a real renderer but wrap methods to track calls
	return &ui.Renderer{}
}

func (m *MockRenderer) RenderMarkdown(content string) error {
	m.renderedMessages = append(m.renderedMessages, content)
	return nil
}

func (m *MockRenderer) RenderStyledResponse(content string) error {
	m.styledResponse = content
	m.renderedMessages = append(m.renderedMessages, "styled:"+content)
	return nil
}

func (m *MockRenderer) RenderResponse(resp *models.SearchResponse) error {
	if resp != nil && resp.Text != "" {
		m.styledResponse = resp.Text
		m.renderedMessages = append(m.renderedMessages, "response:"+resp.Text)
	}
	return nil
}

func (m *MockRenderer) RenderCitations(citations []models.Citation) {
	m.renderedMessages = append(m.renderedMessages, fmt.Sprintf("citations:%d", len(citations)))
}

func (m *MockRenderer) RenderWebResults(results []models.WebResult) {
	m.webResults = results
	m.renderedMessages = append(m.renderedMessages, fmt.Sprintf("webresults:%d", len(results)))
}

func (m *MockRenderer) RenderStreamChunk(chunk models.StreamChunk) {
	m.streamChunks = append(m.streamChunks, chunk)
	m.renderedMessages = append(m.renderedMessages, "streamchunk")
}

func (m *MockRenderer) RenderError(err error) {
	m.renderedErrors = append(m.renderedErrors, err)
}

func (m *MockRenderer) RenderSuccess(msg string) {
	m.renderedMessages = append(m.renderedMessages, "success:"+msg)
}

func (m *MockRenderer) RenderWarning(msg string) {
	m.renderedMessages = append(m.renderedMessages, "warning:"+msg)
}

func (m *MockRenderer) RenderInfo(msg string) {
	m.renderedMessages = append(m.renderedMessages, "info:"+msg)
}

func (m *MockRenderer) RenderTitle(title string) {
	m.renderedMessages = append(m.renderedMessages, "title:"+title)
}

func (m *MockRenderer) RenderSpinner(frame int) {
	m.renderedMessages = append(m.renderedMessages, fmt.Sprintf("spinner:%d", frame))
}

func (m *MockRenderer) ClearLine() {
	m.renderedMessages = append(m.renderedMessages, "clearline")
}

func (m *MockRenderer) NewLine() {
	m.renderedMessages = append(m.renderedMessages, "newline")
}

func TestGetQueryFromInput(t *testing.T) {
	tests := []struct {
		name       string
		args       []string
		stdin      io.Reader
		isTerminal bool
		want       string
		wantErr    bool
	}{
		{
			name:       "query from single argument",
			args:       []string{"hello world"},
			stdin:      strings.NewReader(""),
			isTerminal: true,
			want:       "hello world",
			wantErr:    false,
		},
		{
			name:       "query from multiple arguments",
			args:       []string{"what", "is", "Go?"},
			stdin:      strings.NewReader(""),
			isTerminal: true,
			want:       "what is Go?",
			wantErr:    false,
		},
		{
			name:       "query from stdin when not terminal",
			args:       []string{},
			stdin:      strings.NewReader("piped query\n"),
			isTerminal: false,
			want:       "piped query",
			wantErr:    false,
		},
		{
			name:       "query from stdin with whitespace trimmed",
			args:       []string{},
			stdin:      strings.NewReader("  trimmed query  \n\n"),
			isTerminal: false,
			want:       "trimmed query",
			wantErr:    false,
		},
		{
			name:       "empty query when terminal and no args",
			args:       []string{},
			stdin:      strings.NewReader(""),
			isTerminal: true,
			want:       "",
			wantErr:    false,
		},
		{
			name:       "empty query from empty stdin",
			args:       []string{},
			stdin:      strings.NewReader(""),
			isTerminal: false,
			want:       "",
			wantErr:    false,
		},
		{
			name:       "empty query from whitespace-only stdin",
			args:       []string{},
			stdin:      strings.NewReader("   \n\t\n  "),
			isTerminal: false,
			want:       "",
			wantErr:    false,
		},
		{
			name:       "args take precedence over stdin",
			args:       []string{"from args"},
			stdin:      strings.NewReader("from stdin"),
			isTerminal: false,
			want:       "from args",
			wantErr:    false,
		},
		{
			name:       "error reading from stdin",
			args:       []string{},
			stdin:      &errorReader{},
			isTerminal: false,
			want:       "",
			wantErr:    true,
		},
		{
			name:       "multiline stdin query",
			args:       []string{},
			stdin:      strings.NewReader("line 1\nline 2\nline 3"),
			isTerminal: false,
			want:       "line 1\nline 2\nline 3",
			wantErr:    false,
		},
		{
			name:       "large stdin input",
			args:       []string{},
			stdin:      strings.NewReader(strings.Repeat("x", 10000)),
			isTerminal: false,
			want:       strings.Repeat("x", 10000),
			wantErr:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := getQueryFromInput(tt.args, tt.stdin, tt.isTerminal)

			if (err != nil) != tt.wantErr {
				t.Errorf("getQueryFromInput() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if got != tt.want {
				t.Errorf("getQueryFromInput() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestGetQueryFromInput_BufferReader(t *testing.T) {
	// Test with bytes.Buffer (different Reader implementation)
	buf := bytes.NewBuffer([]byte("buffer query"))
	got, err := getQueryFromInput([]string{}, buf, false)

	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	if got != "buffer query" {
		t.Errorf("got %q, want %q", got, "buffer query")
	}
}

func TestTruncateResponse(t *testing.T) {
	tests := []struct {
		name   string
		input  string
		maxLen int
		want   string
	}{
		{
			name:   "string shorter than max",
			input:  "hello",
			maxLen: 10,
			want:   "hello",
		},
		{
			name:   "string equal to max",
			input:  "hello",
			maxLen: 5,
			want:   "hello",
		},
		{
			name:   "string longer than max",
			input:  "hello world",
			maxLen: 5,
			want:   "hello...",
		},
		{
			name:   "empty string",
			input:  "",
			maxLen: 10,
			want:   "",
		},
		{
			name:   "max length zero",
			input:  "hello",
			maxLen: 0,
			want:   "...",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := truncateResponse(tt.input, tt.maxLen)
			if got != tt.want {
				t.Errorf("truncateResponse(%q, %d) = %q, want %q", tt.input, tt.maxLen, got, tt.want)
			}
		})
	}
}

func TestGetQueryFromFile(t *testing.T) {
	// Create a temporary directory for test files
	tempDir := t.TempDir()

	tests := []struct {
		name        string
		fileContent string
		createFile  bool
		want        string
		wantErr     bool
		errContains string
	}{
		{
			name:        "read simple query from file",
			fileContent: "What is the capital of France?",
			createFile:  true,
			want:        "What is the capital of France?",
			wantErr:     false,
		},
		{
			name:        "read query with whitespace trimmed",
			fileContent: "  trimmed query  \n\n",
			createFile:  true,
			want:        "trimmed query",
			wantErr:     false,
		},
		{
			name:        "read multiline query",
			fileContent: "Line 1\nLine 2\nLine 3",
			createFile:  true,
			want:        "Line 1\nLine 2\nLine 3",
			wantErr:     false,
		},
		{
			name:        "empty file returns error",
			fileContent: "",
			createFile:  true,
			want:        "",
			wantErr:     true,
			errContains: "is empty",
		},
		{
			name:        "whitespace-only file returns error",
			fileContent: "   \n\t\n  ",
			createFile:  true,
			want:        "",
			wantErr:     true,
			errContains: "is empty",
		},
		{
			name:        "non-existent file returns error",
			fileContent: "",
			createFile:  false,
			want:        "",
			wantErr:     true,
			errContains: "failed to read input file",
		},
		{
			name:        "read markdown content",
			fileContent: "# Question\n\nWhat is **Go**?",
			createFile:  true,
			want:        "# Question\n\nWhat is **Go**?",
			wantErr:     false,
		},
		{
			name:        "read large content",
			fileContent: strings.Repeat("x", 10000),
			createFile:  true,
			want:        strings.Repeat("x", 10000),
			wantErr:     false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var filePath string
			if tt.createFile {
				filePath = filepath.Join(tempDir, tt.name+".txt")
				err := os.WriteFile(filePath, []byte(tt.fileContent), 0644)
				if err != nil {
					t.Fatalf("failed to create test file: %v", err)
				}
			} else {
				filePath = filepath.Join(tempDir, "nonexistent_"+tt.name+".txt")
			}

			got, err := getQueryFromFile(filePath)

			if (err != nil) != tt.wantErr {
				t.Errorf("getQueryFromFile() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr && tt.errContains != "" {
				if !strings.Contains(err.Error(), tt.errContains) {
					t.Errorf("getQueryFromFile() error = %v, should contain %q", err, tt.errContains)
				}
			}

			if got != tt.want {
				t.Errorf("getQueryFromFile() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestGetQueryFromFile_SpecialCharacters(t *testing.T) {
	tempDir := t.TempDir()

	// Test with special characters (UTF-8)
	content := "Qual é a capital do Brasil? 日本語 مرحبا"
	filePath := filepath.Join(tempDir, "special.txt")
	err := os.WriteFile(filePath, []byte(content), 0644)
	if err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}

	got, err := getQueryFromFile(filePath)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if got != content {
		t.Errorf("got %q, want %q", got, content)
	}
}

func TestGetQueryFromFile_PermissionDenied(t *testing.T) {
	// Skip on Windows as permission handling is different
	if os.Getenv("GOOS") == "windows" {
		t.Skip("Skipping permission test on Windows")
	}

	tempDir := t.TempDir()
	filePath := filepath.Join(tempDir, "noperm.txt")

	// Create file with no read permission
	err := os.WriteFile(filePath, []byte("content"), 0000)
	if err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}
	defer os.Chmod(filePath, 0644) // Cleanup

	_, err = getQueryFromFile(filePath)
	if err == nil {
		t.Error("expected error for permission denied, got nil")
	}
}

// TestQueryInputPriority tests the priority logic: -f > args > stdin
// This simulates the behavior in runQuery without requiring full integration
func TestQueryInputPriority(t *testing.T) {
	tempDir := t.TempDir()

	// Helper function that mimics the priority logic in runQuery
	getQueryWithPriority := func(inputFile string, args []string, stdin io.Reader, isTerminal bool) (string, error) {
		var query string
		var err error

		// Priority 1: -f/--file flag
		if inputFile != "" {
			query, err = getQueryFromFile(inputFile)
			if err != nil {
				return "", err
			}
		}

		// Priority 2: args or stdin
		if query == "" {
			query, err = getQueryFromInput(args, stdin, isTerminal)
			if err != nil {
				return "", err
			}
		}

		return query, nil
	}

	t.Run("file takes precedence over args", func(t *testing.T) {
		filePath := filepath.Join(tempDir, "priority1.txt")
		err := os.WriteFile(filePath, []byte("from file"), 0644)
		if err != nil {
			t.Fatalf("failed to create test file: %v", err)
		}

		got, err := getQueryWithPriority(filePath, []string{"from args"}, strings.NewReader("from stdin"), false)
		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}
		if got != "from file" {
			t.Errorf("got %q, want %q", got, "from file")
		}
	})

	t.Run("file takes precedence over stdin", func(t *testing.T) {
		filePath := filepath.Join(tempDir, "priority2.txt")
		err := os.WriteFile(filePath, []byte("from file"), 0644)
		if err != nil {
			t.Fatalf("failed to create test file: %v", err)
		}

		got, err := getQueryWithPriority(filePath, []string{}, strings.NewReader("from stdin"), false)
		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}
		if got != "from file" {
			t.Errorf("got %q, want %q", got, "from file")
		}
	})

	t.Run("args used when no file specified", func(t *testing.T) {
		got, err := getQueryWithPriority("", []string{"from args"}, strings.NewReader("from stdin"), false)
		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}
		if got != "from args" {
			t.Errorf("got %q, want %q", got, "from args")
		}
	})

	t.Run("stdin used when no file and no args", func(t *testing.T) {
		got, err := getQueryWithPriority("", []string{}, strings.NewReader("from stdin"), false)
		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}
		if got != "from stdin" {
			t.Errorf("got %q, want %q", got, "from stdin")
		}
	})

	t.Run("empty when no input sources", func(t *testing.T) {
		got, err := getQueryWithPriority("", []string{}, strings.NewReader(""), true)
		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}
		if got != "" {
			t.Errorf("got %q, want empty string", got)
		}
	})

	t.Run("file error propagates", func(t *testing.T) {
		nonExistentFile := filepath.Join(tempDir, "nonexistent.txt")
		_, err := getQueryWithPriority(nonExistentFile, []string{"from args"}, strings.NewReader("from stdin"), false)
		if err == nil {
			t.Error("expected error for non-existent file, got nil")
		}
	})
}

// TestOutputFileSaving tests that response can be saved to different file formats
func TestOutputFileSaving(t *testing.T) {
	tempDir := t.TempDir()

	testContent := "# Response\n\nThis is the **answer**."

	tests := []struct {
		name     string
		filename string
	}{
		{"markdown file", "output.md"},
		{"text file", "output.txt"},
		{"no extension", "output"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			filePath := filepath.Join(tempDir, tt.filename)

			// Simulate the saving logic from runQuery
			err := os.WriteFile(filePath, []byte(testContent), 0644)
			if err != nil {
				t.Fatalf("failed to write output file: %v", err)
			}

			// Verify file was created and content is correct
			data, err := os.ReadFile(filePath)
			if err != nil {
				t.Fatalf("failed to read output file: %v", err)
			}

			if string(data) != testContent {
				t.Errorf("got %q, want %q", string(data), testContent)
			}
		})
	}
}

// TestBuildSearchOptions tests the buildSearchOptions function
func TestBuildSearchOptions(t *testing.T) {
	// Save current global state
	origCfg := cfg
	origFlagModel := flagModel
	origFlagMode := flagMode
	origFlagLanguage := flagLanguage
	origFlagSources := flagSources
	origFlagIncognito := flagIncognito

	defer func() {
		cfg = origCfg
		flagModel = origFlagModel
		flagMode = origFlagMode
		flagLanguage = origFlagLanguage
		flagSources = origFlagSources
		flagIncognito = origFlagIncognito
	}()

	tests := []struct {
		name        string
		cfg         *config.Config
		flagModel   string
		flagMode    string
		flagLanguage string
		flagSources string
		flagIncognito bool
		query       string
		wantModel   models.Model
		wantMode    models.Mode
		wantLang    string
		wantSources []models.Source
		wantIncog   bool
	}{
		{
			name:        "uses config defaults when no flags",
			cfg:         &config.Config{DefaultModel: models.ModelPplxPro, DefaultMode: models.ModeDefault, DefaultLanguage: "en-US", DefaultSources: []models.Source{models.SourceWeb}, Incognito: false},
			flagModel:   "",
			flagMode:    "",
			flagLanguage: "",
			flagSources: "",
			flagIncognito: false,
			query:       "test query",
			wantModel:   models.ModelPplxPro,
			wantMode:    models.ModeDefault,
			wantLang:    "en-US",
			wantSources: []models.Source{models.SourceWeb},
			wantIncog:   false,
		},
		{
			name:        "overrides config with flags",
			cfg:         &config.Config{DefaultModel: models.ModelPplxPro, DefaultMode: models.ModeDefault, DefaultLanguage: "en-US", DefaultSources: []models.Source{models.SourceWeb}, Incognito: false},
			flagModel:   "gpt51",
			flagMode:    "pro",
			flagLanguage: "pt-BR",
			flagSources: "web,scholar",
			flagIncognito: true,
			query:       "test query",
			wantModel:   models.ModelGPT51,
			wantMode:    models.ModePro,
			wantLang:    "pt-BR",
			wantSources: []models.Source{models.SourceWeb, models.SourceScholar},
			wantIncog:   true,
		},
		{
			name:        "multiple sources from comma-separated string",
			cfg:         &config.Config{DefaultModel: models.ModelPplxPro, DefaultMode: models.ModeDefault, DefaultLanguage: "en-US", DefaultSources: []models.Source{models.SourceWeb}, Incognito: false},
			flagModel:   "",
			flagMode:    "",
			flagLanguage: "fr-FR",
			flagSources: " web , scholar , social ",
			flagIncognito: false,
			query:       "test query",
			wantModel:   models.ModelPplxPro,
			wantMode:    models.ModeDefault,
			wantLang:    "fr-FR",
			wantSources: []models.Source{models.SourceWeb, models.SourceScholar, models.SourceSocial},
			wantIncog:   false,
		},
		{
			name:        "reasoning mode with reasoning model",
			cfg:         &config.Config{DefaultModel: models.ModelPplxPro, DefaultMode: models.ModeDefault, DefaultLanguage: "en-US", DefaultSources: []models.Source{models.SourceWeb}, Incognito: false},
			flagModel:   "gpt51_thinking",
			flagMode:    "reasoning",
			flagLanguage: "",
			flagSources: "",
			flagIncognito: false,
			query:       "test query",
			wantModel:   models.ModelGPT51Thinking,
			wantMode:    models.ModeReasoning,
			wantLang:    "en-US",
			wantSources: []models.Source{models.SourceWeb},
			wantIncog:   false,
		},
		{
			name:        "fast mode with turbo",
			cfg:         &config.Config{DefaultModel: models.ModelPplxPro, DefaultMode: models.ModeDefault, DefaultLanguage: "en-US", DefaultSources: []models.Source{models.SourceWeb}, Incognito: false},
			flagModel:   "",
			flagMode:    "fast",
			flagLanguage: "",
			flagSources: "",
			flagIncognito: false,
			query:       "test query",
			wantModel:   models.ModelPplxPro,
			wantMode:    models.ModeFast,
			wantLang:    "en-US",
			wantSources: []models.Source{models.SourceWeb},
			wantIncog:   false,
		},
		{
			name:        "deep-research mode",
			cfg:         &config.Config{DefaultModel: models.ModelPplxPro, DefaultMode: models.ModeDefault, DefaultLanguage: "en-US", DefaultSources: []models.Source{models.SourceWeb}, Incognito: false},
			flagModel:   "",
			flagMode:    "deep-research",
			flagLanguage: "de-DE",
			flagSources: "",
			flagIncognito: true,
			query:       "test query",
			wantModel:   models.ModelPplxPro,
			wantMode:    models.ModeDeepResearch,
			wantLang:    "de-DE",
			wantSources: []models.Source{models.SourceWeb},
			wantIncog:   true,
		},
		{
			name:        "flag incognito overrides config",
			cfg:         &config.Config{DefaultModel: models.ModelPplxPro, DefaultMode: models.ModeDefault, DefaultLanguage: "en-US", DefaultSources: []models.Source{models.SourceWeb}, Incognito: false},
			flagModel:   "",
			flagMode:    "",
			flagLanguage: "",
			flagSources: "",
			flagIncognito: true,
			query:       "test query",
			wantModel:   models.ModelPplxPro,
			wantMode:    models.ModeDefault,
			wantLang:    "en-US",
			wantSources: []models.Source{models.SourceWeb},
			wantIncog:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Set global variables
			cfg = tt.cfg
			flagModel = tt.flagModel
			flagMode = tt.flagMode
			flagLanguage = tt.flagLanguage
			flagSources = tt.flagSources
			flagIncognito = tt.flagIncognito

			opts := buildSearchOptions(tt.query)

			if opts.Query != tt.query {
				t.Errorf("Query mismatch: got %q, want %q", opts.Query, tt.query)
			}
			if opts.Model != tt.wantModel {
				t.Errorf("Model mismatch: got %q, want %q", opts.Model, tt.wantModel)
			}
			if opts.Mode != tt.wantMode {
				t.Errorf("Mode mismatch: got %q, want %q", opts.Mode, tt.wantMode)
			}
			if opts.Language != tt.wantLang {
				t.Errorf("Language mismatch: got %q, want %q", opts.Language, tt.wantLang)
			}
			if len(opts.Sources) != len(tt.wantSources) {
				t.Errorf("Sources length mismatch: got %d, want %d", len(opts.Sources), len(tt.wantSources))
			} else {
				for i, s := range opts.Sources {
					if s != tt.wantSources[i] {
						t.Errorf("Source[%d] mismatch: got %q, want %q", i, s, tt.wantSources[i])
					}
				}
			}
			if opts.Incognito != tt.wantIncog {
				t.Errorf("Incognito mismatch: got %v, want %v", opts.Incognito, tt.wantIncog)
			}
		})
	}
}

// TestInitConfig tests the initConfig function
func TestInitConfig(t *testing.T) {
	t.Run("successful initialization", func(t *testing.T) {
		// Create a temporary config directory
		tempDir := t.TempDir()
		oldHome := os.Getenv("HOME")
		defer func() { os.Setenv("HOME", oldHome) }()
		os.Setenv("HOME", tempDir)

		// Reset global variables before test
		cfgMgr = nil
		cfg = nil
		render = nil

		// Call initConfig - it will try to initialize config and renderer
		// Note: initConfig calls os.Exit on error, so we can't test error paths directly
		// Instead, we test the happy path where it succeeds
		mgr, err := config.NewManager()
		if err != nil {
			t.Fatalf("failed to create manager: %v", err)
		}

		cfgMgr = mgr

		// Load config manually to verify it works
		testCfg, err := cfgMgr.Load()
		if err != nil {
			t.Fatalf("failed to load config: %v", err)
		}
		cfg = testCfg

		// Initialize renderer
		r, err := ui.NewRenderer()
		if err != nil {
			t.Fatalf("failed to create renderer: %v", err)
		}
		render = r

		// Verify initialization
		if cfgMgr == nil {
			t.Error("config manager not initialized")
		}
		if cfg == nil {
			t.Error("config not loaded")
		}
		if render == nil {
			t.Error("renderer not initialized")
		}

		// Verify config defaults
		if cfg.DefaultModel == "" {
			t.Error("default model not set")
		}
		if cfg.DefaultMode == "" {
			t.Error("default mode not set")
		}
	})

	t.Run("config with custom values", func(t *testing.T) {
		// Create a temporary config directory with custom config
		tempDir := t.TempDir()
		oldHome := os.Getenv("HOME")
		defer func() { os.Setenv("HOME", oldHome) }()
		os.Setenv("HOME", tempDir)

		// Create config directory
		configDir := filepath.Join(tempDir, ".perplexity-cli")
		err := os.MkdirAll(configDir, 0700)
		if err != nil {
			t.Fatalf("failed to create config dir: %v", err)
		}

		// Write custom config
		configFile := filepath.Join(configDir, "config.json")
		configJSON := `{
			"default_model": "gpt51",
			"default_mode": "pro",
			"default_language": "pt-BR",
			"streaming": false,
			"incognito": true
		}`
		err = os.WriteFile(configFile, []byte(configJSON), 0644)
		if err != nil {
			t.Fatalf("failed to write config: %v", err)
		}

		// Load config
		mgr, err := config.NewManager()
		if err != nil {
			t.Fatalf("failed to create manager: %v", err)
		}

		testCfg, err := mgr.Load()
		if err != nil {
			t.Fatalf("failed to load config: %v", err)
		}

		// Verify custom values were loaded
		if testCfg.DefaultModel != "gpt51" {
			t.Errorf("expected model gpt51, got %q", testCfg.DefaultModel)
		}
		if testCfg.DefaultMode != "pro" {
			t.Errorf("expected mode pro, got %q", testCfg.DefaultMode)
		}
		if testCfg.DefaultLanguage != "pt-BR" {
			t.Errorf("expected language pt-BR, got %q", testCfg.DefaultLanguage)
		}
		if testCfg.Streaming != false {
			t.Errorf("expected streaming false, got %v", testCfg.Streaming)
		}
		if testCfg.Incognito != true {
			t.Errorf("expected incognito true, got %v", testCfg.Incognito)
		}
	})
}

// TestRunQueryIntegration tests the runQuery function with integration-style tests
// These tests focus on error handling and query building logic
func TestRunQueryIntegration(t *testing.T) {
	// Create temporary files
	tempDir := t.TempDir()
	queryFile := filepath.Join(tempDir, "query.txt")
	cookieFile := filepath.Join(tempDir, "cookies.json")

	// Create test files
	err := os.WriteFile(queryFile, []byte("test query from file"), 0644)
	if err != nil {
		t.Fatalf("failed to create query file: %v", err)
	}

	err = os.WriteFile(cookieFile, []byte(`[{"name": "next-auth.csrf-token", "value": "test"}]`), 0644)
	if err != nil {
		t.Fatalf("failed to create cookie file: %v", err)
	}

	t.Run("missing cookie file error", func(t *testing.T) {
		// Setup
		cfg = &config.Config{
			DefaultModel:     models.ModelPplxPro,
			DefaultMode:      models.ModeDefault,
			DefaultLanguage:  "en-US",
			DefaultSources:   []models.Source{models.SourceWeb},
			CookieFile:       filepath.Join(tempDir, "nonexistent.json"),
		}

		// Reset flags
		flagInputFile = ""
		flagCookieFile = ""
		flagIncognito = false

		cmd := &cobra.Command{
			Use: "perplexity",
			RunE: runQuery,
		}

		// Execute - should fail due to missing cookie file
		err := runQuery(cmd, []string{"test query"})
		if err == nil {
			t.Error("expected error for missing cookie file, got nil")
		}
	})

	t.Run("empty query shows help", func(t *testing.T) {
		// Setup with cookie file
		cfg = &config.Config{
			DefaultModel:     models.ModelPplxPro,
			DefaultMode:      models.ModeDefault,
			DefaultLanguage:  "en-US",
			DefaultSources:   []models.Source{models.SourceWeb},
			CookieFile:       cookieFile,
		}

		// Reset flags - no query provided
		flagInputFile = ""
		flagCookieFile = ""
		flagIncognito = false

		cmd := &cobra.Command{
			Use: "perplexity",
			RunE: runQuery,
		}

		// Execute with no args and terminal stdin (should show help)
		err := runQuery(cmd, []string{})
		if err != nil {
			// Help() returns an error, which is expected
			// We just verify it doesn't panic
		}
	})

	t.Run("query from file", func(t *testing.T) {
		// Setup with cookie file
		cfg = &config.Config{
			DefaultModel:     models.ModelPplxPro,
			DefaultMode:      models.ModeDefault,
			DefaultLanguage:  "en-US",
			DefaultSources:   []models.Source{models.SourceWeb},
			CookieFile:       cookieFile,
		}

		// Reset flags with file input
		flagInputFile = queryFile
		flagCookieFile = ""
		flagIncognito = true
		flagStream = false

		// Verify the file can be read
		content, err := getQueryFromFile(queryFile)
		if err != nil {
			t.Fatalf("failed to read query file: %v", err)
		}
		if content != "test query from file" {
			t.Errorf("expected 'test query from file', got %q", content)
		}
	})

	t.Run("stdin input with terminal false", func(t *testing.T) {
		// Setup with cookie file
		cfg = &config.Config{
			DefaultModel:     models.ModelPplxPro,
			DefaultMode:      models.ModeDefault,
			DefaultLanguage:  "en-US",
			DefaultSources:   []models.Source{models.SourceWeb},
			CookieFile:       cookieFile,
		}

		// Reset flags - reading from stdin
		flagInputFile = ""
		flagCookieFile = ""
		flagIncognito = true
		flagStream = false

		// Test reading from stdin
		stdin := strings.NewReader("query from stdin")
		isTerminal := false

		query, err := getQueryFromInput([]string{}, stdin, isTerminal)
		if err != nil {
			t.Fatalf("failed to read from stdin: %v", err)
		}
		if query != "query from stdin" {
			t.Errorf("expected 'query from stdin', got %q", query)
		}
	})

	t.Run("verbose mode sets flags correctly", func(t *testing.T) {
		cfg = &config.Config{
			DefaultModel:     models.ModelPplxPro,
			DefaultMode:      models.ModeDefault,
			DefaultLanguage:  "en-US",
			DefaultSources:   []models.Source{models.SourceWeb},
			CookieFile:       cookieFile,
		}

		// Test buildSearchOptions with various flags
		opts := buildSearchOptions("test query")

		if opts.Model != models.ModelPplxPro {
			t.Errorf("expected model %q, got %q", models.ModelPplxPro, opts.Model)
		}
		if opts.Mode != models.ModeDefault {
			t.Errorf("expected mode %q, got %q", models.ModeDefault, opts.Mode)
		}
	})
}

// TestQueryFileWithEmptyContent tests edge case of empty file
func TestQueryFileWithEmptyContent(t *testing.T) {
	tempDir := t.TempDir()
	emptyFile := filepath.Join(tempDir, "empty.txt")

	// Create empty file
	err := os.WriteFile(emptyFile, []byte(""), 0644)
	if err != nil {
		t.Fatalf("failed to create empty file: %v", err)
	}

	// Try to read empty file - should return error
	_, err = getQueryFromFile(emptyFile)
	if err == nil {
		t.Error("expected error for empty file, got nil")
	}
	if !strings.Contains(err.Error(), "is empty") {
		t.Errorf("expected 'is empty' in error, got %v", err)
	}
}

// TestBuildSearchOptionsWithAllFlags tests buildSearchOptions with all flags set
func TestBuildSearchOptionsWithAllFlags(t *testing.T) {
	// Save current global state
	origCfg := cfg
	origFlagModel := flagModel
	origFlagMode := flagMode
	origFlagLanguage := flagLanguage
	origFlagSources := flagSources
	origFlagIncognito := flagIncognito

	defer func() {
		cfg = origCfg
		flagModel = origFlagModel
		flagMode = origFlagMode
		flagLanguage = origFlagLanguage
		flagSources = origFlagSources
		flagIncognito = origFlagIncognito
	}()

	cfg = &config.Config{
		DefaultModel:     models.ModelPplxPro,
		DefaultMode:      models.ModeDefault,
		DefaultLanguage:  "en-US",
		DefaultSources:   []models.Source{models.SourceWeb},
		Incognito:        false,
	}

	// Set all flags
	flagModel = "gpt51"
	flagMode = "pro"
	flagLanguage = "pt-BR"
	flagSources = "web,scholar,social"
	flagIncognito = true

	opts := buildSearchOptions("test query")

	if opts.Model != models.ModelGPT51 {
		t.Errorf("Expected model gpt51, got %q", opts.Model)
	}
	if opts.Mode != models.ModePro {
		t.Errorf("Expected mode pro, got %q", opts.Mode)
	}
	if opts.Language != "pt-BR" {
		t.Errorf("Expected language pt-BR, got %q", opts.Language)
	}
	if len(opts.Sources) != 3 {
		t.Errorf("Expected 3 sources, got %d", len(opts.Sources))
	}
	if opts.Incognito != true {
		t.Errorf("Expected incognito true, got %v", opts.Incognito)
	}
}

// TestTruncateResponseEdgeCases tests edge cases for truncateResponse
func TestTruncateResponseEdgeCases(t *testing.T) {
	tests := []struct {
		name   string
		input  string
		maxLen int
		want   string
	}{
		{"exact match", "hello", 5, "hello"},
		{"one less", "hello", 4, "hell..."},
		{"one more", "hello", 6, "hello"},
		{"zero length", "", 10, ""},
		{"zero max", "hello", 0, "..."},
		{"very long string", strings.Repeat("x", 1000), 10, strings.Repeat("x", 10) + "..."},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := truncateResponse(tt.input, tt.maxLen)
			if got != tt.want {
				t.Errorf("truncateResponse(%q, %d) = %q, want %q", tt.input, tt.maxLen, got, tt.want)
			}
		})
	}
}

// TestFlagParsing tests flag parsing behavior
func TestFlagParsing(t *testing.T) {
	// Test that we can parse various flag combinations
	flagTests := []struct {
		name     string
		flags    map[string]string
		validate func(models.SearchOptions) bool
	}{
		{
			name: "model flag",
			flags: map[string]string{
				"model": "gpt51",
			},
			validate: func(opts models.SearchOptions) bool {
				return opts.Model == models.ModelGPT51
			},
		},
		{
			name: "mode flag",
			flags: map[string]string{
				"mode": "reasoning",
			},
			validate: func(opts models.SearchOptions) bool {
				return opts.Mode == models.ModeReasoning
			},
		},
		{
			name: "language flag",
			flags: map[string]string{
				"language": "fr-FR",
			},
			validate: func(opts models.SearchOptions) bool {
				return opts.Language == "fr-FR"
			},
		},
		{
			name: "sources flag",
			flags: map[string]string{
				"sources": "web,scholar",
			},
			validate: func(opts models.SearchOptions) bool {
				return len(opts.Sources) == 2
			},
		},
	}

	for _, tt := range flagTests {
		t.Run(tt.name, func(t *testing.T) {
			// Save and restore global state
			origCfg := cfg
			origFlagModel := flagModel
			origFlagMode := flagMode
			origFlagLanguage := flagLanguage
			origFlagSources := flagSources

			defer func() {
				cfg = origCfg
				flagModel = origFlagModel
				flagMode = origFlagMode
				flagLanguage = origFlagLanguage
				flagSources = origFlagSources
			}()

			cfg = &config.Config{
				DefaultModel:     models.ModelPplxPro,
				DefaultMode:      models.ModeDefault,
				DefaultLanguage:  "en-US",
				DefaultSources:   []models.Source{models.SourceWeb},
			}

			// Set flags
			flagModel = tt.flags["model"]
			flagMode = tt.flags["mode"]
			flagLanguage = tt.flags["language"]
			flagSources = tt.flags["sources"]

			opts := buildSearchOptions("test")
			if !tt.validate(opts) {
				t.Errorf("Flag validation failed for %s", tt.name)
			}
		})
	}
}

// TestExecute tests the Execute function
func TestExecute(t *testing.T) {
	// Save original rootCmd
	origRootCmd := rootCmd

	defer func() {
		rootCmd = origRootCmd
	}()

	t.Run("successful execution", func(t *testing.T) {
		// This is a basic test of the Execute function
		// In practice, Execute just calls rootCmd.Execute()
		// which is tested through the Cobra testing mechanisms
		if rootCmd == nil {
			t.Error("rootCmd not initialized")
		}
	})

	t.Run("with help flag", func(t *testing.T) {
		// Test that --help flag works
		// This would normally trigger help output
		// For now, just verify the command is set up correctly
		if rootCmd.Use != "perplexity [query]" {
			t.Errorf("unexpected use string: %q", rootCmd.Use)
		}
	})
}
</file>
<file path="cmd/perplexity/version.go">
package main

import (
	"fmt"
	"runtime"

	"github.com/spf13/cobra"
)

// Version information (set via ldflags during build).
var (
	Version   = "1.0.0"
	GitCommit = "unknown"
	BuildDate = "unknown"
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print version information",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Printf("perplexity %s\n", Version)
		fmt.Printf("  Git commit: %s\n", GitCommit)
		fmt.Printf("  Built:      %s\n", BuildDate)
		fmt.Printf("  Go version: %s\n", runtime.Version())
		fmt.Printf("  OS/Arch:    %s/%s\n", runtime.GOOS, runtime.GOARCH)
	},
}
</file>
<file path="internal/auth/cookies.go">
// Package auth handles authentication and cookie management.
package auth

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	http "github.com/bogdanfinn/fhttp"
)

// JSONCookie represents a cookie in JSON format (browser export).
type JSONCookie struct {
	Name     string  `json:"name"`
	Value    string  `json:"value"`
	Domain   string  `json:"domain"`
	Path     string  `json:"path"`
	Expires  float64 `json:"expirationDate,omitempty"`
	Secure   bool    `json:"secure"`
	HTTPOnly bool    `json:"httpOnly"`
	SameSite string  `json:"sameSite,omitempty"`
}

// LoadCookiesFromFile loads cookies from a JSON file.
func LoadCookiesFromFile(path string) ([]*http.Cookie, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read cookie file: %w", err)
	}

	var jsonCookies []JSONCookie
	if err := json.Unmarshal(data, &jsonCookies); err != nil {
		return nil, fmt.Errorf("failed to parse cookie JSON: %w", err)
	}

	cookies := make([]*http.Cookie, 0, len(jsonCookies))
	for _, jc := range jsonCookies {
		// Only include Perplexity cookies
		if !strings.Contains(jc.Domain, "perplexity.ai") {
			continue
		}

		cookie := &http.Cookie{
			Name:     jc.Name,
			Value:    jc.Value,
			Domain:   jc.Domain,
			Path:     jc.Path,
			Secure:   jc.Secure,
			HttpOnly: jc.HTTPOnly,
		}

		// Convert expiration timestamp
		if jc.Expires > 0 {
			cookie.Expires = time.Unix(int64(jc.Expires), 0)
		}

		// Parse SameSite
		switch strings.ToLower(jc.SameSite) {
		case "strict":
			cookie.SameSite = http.SameSiteStrictMode
		case "lax":
			cookie.SameSite = http.SameSiteLaxMode
		case "none":
			cookie.SameSite = http.SameSiteNoneMode
		default:
			cookie.SameSite = http.SameSiteDefaultMode
		}

		cookies = append(cookies, cookie)
	}

	return cookies, nil
}

// LoadCookiesFromNetscape loads cookies from Netscape format file.
func LoadCookiesFromNetscape(path string) ([]*http.Cookie, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open cookie file: %w", err)
	}
	defer file.Close()

	var cookies []*http.Cookie
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Netscape format: domain, tailmatch, path, secure, expiration, name, value
		fields := strings.Split(line, "\t")
		if len(fields) < 7 {
			continue
		}

		domain := fields[0]
		// tailmatch := fields[1] == "TRUE"
		path := fields[2]
		secure := fields[3] == "TRUE"
		expiration := fields[4]
		name := fields[5]
		value := fields[6]

		// Only include Perplexity cookies
		if !strings.Contains(domain, "perplexity.ai") {
			continue
		}

		cookie := &http.Cookie{
			Name:   name,
			Value:  value,
			Domain: domain,
			Path:   path,
			Secure: secure,
		}

		// Parse expiration
		if expiration != "0" {
			var exp int64
			fmt.Sscanf(expiration, "%d", &exp)
			if exp > 0 {
				cookie.Expires = time.Unix(exp, 0)
			}
		}

		cookies = append(cookies, cookie)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading cookie file: %w", err)
	}

	return cookies, nil
}

// GetDefaultCookiePath returns the default cookie file path.
func GetDefaultCookiePath() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("failed to get home directory: %w", err)
	}
	return filepath.Join(home, ".perplexity-cli", "cookies.json"), nil
}

// SaveCookiesToFile saves cookies to a JSON file.
func SaveCookiesToFile(cookies []*http.Cookie, path string) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	jsonCookies := make([]JSONCookie, 0, len(cookies))
	for _, c := range cookies {
		jc := JSONCookie{
			Name:     c.Name,
			Value:    c.Value,
			Domain:   c.Domain,
			Path:     c.Path,
			Secure:   c.Secure,
			HTTPOnly: c.HttpOnly,
		}

		if !c.Expires.IsZero() {
			jc.Expires = float64(c.Expires.Unix())
		}

		switch c.SameSite {
		case http.SameSiteStrictMode:
			jc.SameSite = "Strict"
		case http.SameSiteLaxMode:
			jc.SameSite = "Lax"
		case http.SameSiteNoneMode:
			jc.SameSite = "None"
		}

		jsonCookies = append(jsonCookies, jc)
	}

	data, err := json.MarshalIndent(jsonCookies, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal cookies: %w", err)
	}

	// Write with restricted permissions
	if err := os.WriteFile(path, data, 0600); err != nil {
		return fmt.Errorf("failed to write cookie file: %w", err)
	}

	return nil
}

// HasCSRFToken checks if cookies contain a valid CSRF token.
func HasCSRFToken(cookies []*http.Cookie) bool {
	for _, c := range cookies {
		if c.Name == "next-auth.csrf-token" && c.Value != "" {
			return true
		}
	}
	return false
}

// ExtractCSRFToken extracts the CSRF token value from cookies.
func ExtractCSRFToken(cookies []*http.Cookie) string {
	for _, c := range cookies {
		if c.Name == "next-auth.csrf-token" {
			// Token format: "value|hash"
			value := c.Value
			if idx := strings.Index(value, "|"); idx != -1 {
				return value[:idx]
			}
			return value
		}
	}
	return ""
}

// CookieMap converts cookie slice to map for easier access.
func CookieMap(cookies []*http.Cookie) map[string]string {
	m := make(map[string]string, len(cookies))
	for _, c := range cookies {
		m[c.Name] = c.Value
	}
	return m
}
</file>
<file path="internal/auth/cookies_test.go">
package auth

import (
	"os"
	"path/filepath"
	"testing"

	http "github.com/bogdanfinn/fhttp"
)

func TestLoadCookiesFromFile(t *testing.T) {
	// Create a temporary cookie file
	tmpDir := t.TempDir()
	cookieFile := filepath.Join(tmpDir, "cookies.json")

	// Write test cookies
	cookieJSON := `[
		{
			"name": "test_cookie",
			"value": "test_value",
			"domain": ".perplexity.ai",
			"path": "/",
			"secure": true,
			"httpOnly": true,
			"sameSite": "Lax"
		},
		{
			"name": "next-auth.csrf-token",
			"value": "csrf_token_value|hash",
			"domain": ".perplexity.ai",
			"path": "/"
		},
		{
			"name": "other_cookie",
			"value": "other_value",
			"domain": ".example.com",
			"path": "/"
		}
	]`

	if err := os.WriteFile(cookieFile, []byte(cookieJSON), 0644); err != nil {
		t.Fatalf("Failed to write test cookie file: %v", err)
	}

	cookies, err := LoadCookiesFromFile(cookieFile)
	if err != nil {
		t.Fatalf("LoadCookiesFromFile() error = %v", err)
	}

	// Should only have 2 cookies (perplexity.ai domain)
	if len(cookies) != 2 {
		t.Errorf("len(cookies) = %d, want 2", len(cookies))
	}

	// Check first cookie
	found := false
	for _, c := range cookies {
		if c.Name == "test_cookie" {
			found = true
			if c.Value != "test_value" {
				t.Errorf("cookie.Value = %q, want %q", c.Value, "test_value")
			}
			if !c.Secure {
				t.Error("cookie.Secure should be true")
			}
			if !c.HttpOnly {
				t.Error("cookie.HttpOnly should be true")
			}
		}
	}
	if !found {
		t.Error("test_cookie not found")
	}
}

func TestLoadCookiesFromFile_NotFound(t *testing.T) {
	_, err := LoadCookiesFromFile("/nonexistent/path/cookies.json")
	if err == nil {
		t.Error("Expected error for nonexistent file")
	}
}

func TestLoadCookiesFromFile_InvalidJSON(t *testing.T) {
	tmpDir := t.TempDir()
	cookieFile := filepath.Join(tmpDir, "invalid.json")

	if err := os.WriteFile(cookieFile, []byte("not valid json"), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	_, err := LoadCookiesFromFile(cookieFile)
	if err == nil {
		t.Error("Expected error for invalid JSON")
	}
}

func TestHasCSRFToken(t *testing.T) {
	tests := []struct {
		name    string
		cookies []*http.Cookie
		want    bool
	}{
		{
			name: "with CSRF token",
			cookies: []*http.Cookie{
				{Name: "next-auth.csrf-token", Value: "token|hash"},
			},
			want: true,
		},
		{
			name: "without CSRF token",
			cookies: []*http.Cookie{
				{Name: "other_cookie", Value: "value"},
			},
			want: false,
		},
		{
			name: "empty CSRF token",
			cookies: []*http.Cookie{
				{Name: "next-auth.csrf-token", Value: ""},
			},
			want: false,
		},
		{
			name:    "nil cookies",
			cookies: nil,
			want:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := HasCSRFToken(tt.cookies)
			if got != tt.want {
				t.Errorf("HasCSRFToken() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestExtractCSRFToken(t *testing.T) {
	tests := []struct {
		name    string
		cookies []*http.Cookie
		want    string
	}{
		{
			name: "token with hash",
			cookies: []*http.Cookie{
				{Name: "next-auth.csrf-token", Value: "mytoken|somehash"},
			},
			want: "mytoken",
		},
		{
			name: "token without hash",
			cookies: []*http.Cookie{
				{Name: "next-auth.csrf-token", Value: "justtoken"},
			},
			want: "justtoken",
		},
		{
			name: "no token",
			cookies: []*http.Cookie{
				{Name: "other", Value: "value"},
			},
			want: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ExtractCSRFToken(tt.cookies)
			if got != tt.want {
				t.Errorf("ExtractCSRFToken() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestCookieMap(t *testing.T) {
	cookies := []*http.Cookie{
		{Name: "cookie1", Value: "value1"},
		{Name: "cookie2", Value: "value2"},
		{Name: "cookie3", Value: "value3"},
	}

	m := CookieMap(cookies)

	if len(m) != 3 {
		t.Errorf("len(map) = %d, want 3", len(m))
	}
	if m["cookie1"] != "value1" {
		t.Errorf("map[cookie1] = %q, want %q", m["cookie1"], "value1")
	}
	if m["cookie2"] != "value2" {
		t.Errorf("map[cookie2] = %q, want %q", m["cookie2"], "value2")
	}
}

func TestSaveCookiesToFile(t *testing.T) {
	tmpDir := t.TempDir()
	cookieFile := filepath.Join(tmpDir, "saved_cookies.json")

	cookies := []*http.Cookie{
		{
			Name:     "test_cookie",
			Value:    "test_value",
			Domain:   ".perplexity.ai",
			Path:     "/",
			Secure:   true,
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
		},
	}

	if err := SaveCookiesToFile(cookies, cookieFile); err != nil {
		t.Fatalf("SaveCookiesToFile() error = %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(cookieFile); os.IsNotExist(err) {
		t.Error("Cookie file was not created")
	}

	// Load and verify
	loaded, err := LoadCookiesFromFile(cookieFile)
	if err != nil {
		t.Fatalf("Failed to load saved cookies: %v", err)
	}

	if len(loaded) != 1 {
		t.Errorf("len(loaded) = %d, want 1", len(loaded))
	}
	if loaded[0].Name != "test_cookie" {
		t.Errorf("loaded[0].Name = %q, want %q", loaded[0].Name, "test_cookie")
	}
}

func TestGetDefaultCookiePath(t *testing.T) {
	path, err := GetDefaultCookiePath()
	if err != nil {
		t.Fatalf("GetDefaultCookiePath() error = %v", err)
	}

	if path == "" {
		t.Error("GetDefaultCookiePath() returned empty path")
	}

	// Should contain .perplexity-cli
	if !filepath.IsAbs(path) {
		t.Error("Path should be absolute")
	}
}

func TestLoadCookiesFromNetscape(t *testing.T) {
	tmpDir := t.TempDir()
	netscapeFile := filepath.Join(tmpDir, "cookies.txt")

	netscapeContent := `# Netscape HTTP Cookie File
.perplexity.ai	TRUE	/	TRUE	1735689600	session	session_value
.perplexity.ai	TRUE	/	FALSE	0	test	test_value
.example.com	TRUE	/	TRUE	1735689600	other	other_value
`

	if err := os.WriteFile(netscapeFile, []byte(netscapeContent), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	cookies, err := LoadCookiesFromNetscape(netscapeFile)
	if err != nil {
		t.Fatalf("LoadCookiesFromNetscape() error = %v", err)
	}

	// Should only have 2 cookies (perplexity.ai domain)
	if len(cookies) != 2 {
		t.Errorf("len(cookies) = %d, want 2", len(cookies))
	}

	// Check session cookie
	found := false
	for _, c := range cookies {
		if c.Name == "session" {
			found = true
			if c.Value != "session_value" {
				t.Errorf("cookie.Value = %q, want %q", c.Value, "session_value")
			}
			if !c.Secure {
				t.Error("cookie.Secure should be true")
			}
		}
	}
	if !found {
		t.Error("session cookie not found")
	}
}
</file>
<file path="internal/config/manager.go">
// Package config handles configuration management.
package config

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/diogo/perplexity-go/pkg/models"
	"github.com/spf13/viper"
)

const (
	configDirName  = ".perplexity-cli"
	configFileName = "config"
	configFileType = "json"
)

// Config holds all configuration options.
type Config struct {
	DefaultModel    models.Model    `mapstructure:"default_model"`
	DefaultMode     models.Mode     `mapstructure:"default_mode"`
	DefaultLanguage string          `mapstructure:"default_language"`
	DefaultSources  []models.Source `mapstructure:"default_sources"`
	Streaming       bool            `mapstructure:"streaming"`
	Incognito       bool            `mapstructure:"incognito"`
	CookieFile      string          `mapstructure:"cookie_file"`
	HistoryFile     string          `mapstructure:"history_file"`
}

// Manager handles configuration loading and saving.
type Manager struct {
	v       *viper.Viper
	cfgDir  string
	cfgFile string
}

// NewManager creates a new configuration manager.
func NewManager() (*Manager, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get home directory: %w", err)
	}

	cfgDir := filepath.Join(home, configDirName)
	cfgFile := filepath.Join(cfgDir, configFileName+"."+configFileType)

	m := &Manager{
		v:       viper.New(),
		cfgDir:  cfgDir,
		cfgFile: cfgFile,
	}

	// Set defaults
	m.setDefaults()

	// Setup viper
	m.v.SetConfigName(configFileName)
	m.v.SetConfigType(configFileType)
	m.v.AddConfigPath(cfgDir)
	m.v.AddConfigPath(".")

	// Environment variable support
	m.v.SetEnvPrefix("PERPLEXITY")
	m.v.AutomaticEnv()
	m.v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

	return m, nil
}

// setDefaults sets default configuration values.
func (m *Manager) setDefaults() {
	m.v.SetDefault("default_model", string(models.ModelPplxPro))
	m.v.SetDefault("default_mode", string(models.ModeDefault))
	m.v.SetDefault("default_language", "en-US")
	m.v.SetDefault("default_sources", []string{string(models.SourceWeb)})
	m.v.SetDefault("streaming", true)
	m.v.SetDefault("incognito", false)
	m.v.SetDefault("cookie_file", filepath.Join(m.cfgDir, "cookies.json"))
	m.v.SetDefault("history_file", filepath.Join(m.cfgDir, "history.jsonl"))
}

// Load reads configuration from file and environment.
func (m *Manager) Load() (*Config, error) {
	// Create config directory if not exists
	if err := os.MkdirAll(m.cfgDir, 0700); err != nil {
		return nil, fmt.Errorf("failed to create config directory: %w", err)
	}

	// Try to read config file (ignore if not exists)
	if err := m.v.ReadInConfig(); err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
			// Only return error if it's not "file not found"
			return nil, fmt.Errorf("failed to read config: %w", err)
		}
	}

	cfg := &Config{}

	// Manual parsing to handle type conversions
	cfg.DefaultModel = models.Model(m.v.GetString("default_model"))
	cfg.DefaultMode = models.Mode(m.v.GetString("default_mode"))
	cfg.DefaultLanguage = m.v.GetString("default_language")
	cfg.Streaming = m.v.GetBool("streaming")
	cfg.Incognito = m.v.GetBool("incognito")
	cfg.CookieFile = m.v.GetString("cookie_file")
	cfg.HistoryFile = m.v.GetString("history_file")

	// Parse sources
	sourcesRaw := m.v.GetStringSlice("default_sources")
	if len(sourcesRaw) == 0 {
		// Try as comma-separated string
		sourcesStr := m.v.GetString("default_sources")
		if sourcesStr != "" {
			sourcesRaw = strings.Split(sourcesStr, ",")
		}
	}
	cfg.DefaultSources = parseSources(sourcesRaw)

	// Validate configuration
	if err := m.validate(cfg); err != nil {
		return nil, err
	}

	return cfg, nil
}

// Save writes configuration to file.
func (m *Manager) Save(cfg *Config) error {
	// Create config directory if not exists
	if err := os.MkdirAll(m.cfgDir, 0700); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	m.v.Set("default_model", string(cfg.DefaultModel))
	m.v.Set("default_mode", string(cfg.DefaultMode))
	m.v.Set("default_language", cfg.DefaultLanguage)
	m.v.Set("streaming", cfg.Streaming)
	m.v.Set("incognito", cfg.Incognito)
	m.v.Set("cookie_file", cfg.CookieFile)
	m.v.Set("history_file", cfg.HistoryFile)

	sources := make([]string, len(cfg.DefaultSources))
	for i, s := range cfg.DefaultSources {
		sources[i] = string(s)
	}
	m.v.Set("default_sources", sources)

	return m.v.WriteConfigAs(m.cfgFile)
}

// validate checks configuration values.
func (m *Manager) validate(cfg *Config) error {
	// Validate model
	if cfg.DefaultModel != "" && !models.IsValidModel(cfg.DefaultModel) {
		return fmt.Errorf("invalid model: %s", cfg.DefaultModel)
	}

	// Validate mode
	if cfg.DefaultMode != "" && !models.IsValidMode(cfg.DefaultMode) {
		return fmt.Errorf("invalid mode: %s", cfg.DefaultMode)
	}

	// Validate language format (xx-XX)
	if cfg.DefaultLanguage != "" && !isValidLanguage(cfg.DefaultLanguage) {
		return fmt.Errorf("invalid language format: %s (expected xx-XX)", cfg.DefaultLanguage)
	}

	// Validate sources
	for _, s := range cfg.DefaultSources {
		if !models.IsValidSource(s) {
			return fmt.Errorf("invalid source: %s", s)
		}
	}

	return nil
}

// GetConfigDir returns the configuration directory path.
func (m *Manager) GetConfigDir() string {
	return m.cfgDir
}

// GetConfigFile returns the configuration file path.
func (m *Manager) GetConfigFile() string {
	return m.cfgFile
}

// parseSources converts string slice to Source slice.
func parseSources(raw []string) []models.Source {
	sources := make([]models.Source, 0, len(raw))
	seen := make(map[models.Source]bool)

	for _, s := range raw {
		s = strings.TrimSpace(s)
		source := models.Source(s)
		if models.IsValidSource(source) && !seen[source] {
			sources = append(sources, source)
			seen[source] = true
		}
	}

	if len(sources) == 0 {
		return []models.Source{models.SourceWeb}
	}

	return sources
}

// isValidLanguage checks if the language format is valid (xx-XX).
var languageRegex = regexp.MustCompile(`^[a-z]{2}-[A-Z]{2}$`)

func isValidLanguage(lang string) bool {
	return languageRegex.MatchString(lang)
}

// ParseBoolean parses boolean strings (true, false, 1, 0, yes, no, on, off).
func ParseBoolean(value string, defaultValue bool) bool {
	value = strings.TrimSpace(strings.ToLower(value))
	switch value {
	case "true", "1", "yes", "on":
		return true
	case "false", "0", "no", "off":
		return false
	default:
		return defaultValue
	}
}
</file>
<file path="internal/config/manager_test.go">
package config

import (
	"testing"

	"github.com/diogo/perplexity-go/pkg/models"
)

func TestParseBoolean(t *testing.T) {
	tests := []struct {
		name         string
		value        string
		defaultValue bool
		want         bool
	}{
		{"true lowercase", "true", false, true},
		{"TRUE uppercase", "TRUE", false, true},
		{"True mixed", "True", false, true},
		{"1", "1", false, true},
		{"yes", "yes", false, true},
		{"YES", "YES", false, true},
		{"on", "on", false, true},
		{"ON", "ON", false, true},
		{"false lowercase", "false", true, false},
		{"FALSE uppercase", "FALSE", true, false},
		{"0", "0", true, false},
		{"no", "no", true, false},
		{"off", "off", true, false},
		{"invalid with default true", "invalid", true, true},
		{"invalid with default false", "invalid", false, false},
		{"empty with default true", "", true, true},
		{"empty with default false", "", false, false},
		{"whitespace", "  true  ", false, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ParseBoolean(tt.value, tt.defaultValue)
			if got != tt.want {
				t.Errorf("ParseBoolean(%q, %v) = %v, want %v", tt.value, tt.defaultValue, got, tt.want)
			}
		})
	}
}

func TestIsValidLanguage(t *testing.T) {
	tests := []struct {
		name string
		lang string
		want bool
	}{
		{"valid en-US", "en-US", true},
		{"valid pt-BR", "pt-BR", true},
		{"valid fr-FR", "fr-FR", true},
		{"valid de-DE", "de-DE", true},
		{"valid es-ES", "es-ES", true},
		{"invalid underscore", "en_US", false},
		{"invalid lowercase region", "en-us", false},
		{"invalid uppercase lang", "EN-US", false},
		{"invalid no region", "en", false},
		{"invalid too short", "e-US", false},
		{"invalid too long", "eng-USA", false},
		{"empty", "", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := isValidLanguage(tt.lang)
			if got != tt.want {
				t.Errorf("isValidLanguage(%q) = %v, want %v", tt.lang, got, tt.want)
			}
		})
	}
}

func TestParseSources(t *testing.T) {
	tests := []struct {
		name string
		raw  []string
		want []models.Source
	}{
		{
			name: "single web",
			raw:  []string{"web"},
			want: []models.Source{models.SourceWeb},
		},
		{
			name: "multiple sources",
			raw:  []string{"web", "scholar", "social"},
			want: []models.Source{models.SourceWeb, models.SourceScholar, models.SourceSocial},
		},
		{
			name: "with whitespace",
			raw:  []string{"  web  ", " scholar "},
			want: []models.Source{models.SourceWeb, models.SourceScholar},
		},
		{
			name: "with duplicates",
			raw:  []string{"web", "web", "scholar"},
			want: []models.Source{models.SourceWeb, models.SourceScholar},
		},
		{
			name: "empty returns default",
			raw:  []string{},
			want: []models.Source{models.SourceWeb},
		},
		{
			name: "invalid sources filtered",
			raw:  []string{"web", "invalid", "scholar"},
			want: []models.Source{models.SourceWeb, models.SourceScholar},
		},
		{
			name: "all invalid returns default",
			raw:  []string{"invalid1", "invalid2"},
			want: []models.Source{models.SourceWeb},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := parseSources(tt.raw)
			if len(got) != len(tt.want) {
				t.Errorf("parseSources() returned %d sources, want %d", len(got), len(tt.want))
				return
			}
			for i, s := range got {
				if s != tt.want[i] {
					t.Errorf("parseSources()[%d] = %q, want %q", i, s, tt.want[i])
				}
			}
		})
	}
}

func TestNewManager(t *testing.T) {
	mgr, err := NewManager()
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	if mgr.cfgDir == "" {
		t.Error("cfgDir should not be empty")
	}
	if mgr.cfgFile == "" {
		t.Error("cfgFile should not be empty")
	}
	if mgr.v == nil {
		t.Error("viper instance should not be nil")
	}
}

func TestManagerGetPaths(t *testing.T) {
	mgr, err := NewManager()
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	dir := mgr.GetConfigDir()
	if dir == "" {
		t.Error("GetConfigDir() returned empty string")
	}

	file := mgr.GetConfigFile()
	if file == "" {
		t.Error("GetConfigFile() returned empty string")
	}
}

func TestManagerLoad(t *testing.T) {
	mgr, err := NewManager()
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	// Load should work even without config file (uses defaults)
	cfg, err := mgr.Load()
	if err != nil {
		t.Fatalf("Load() error = %v", err)
	}

	if cfg.DefaultModel == "" {
		t.Error("DefaultModel should have a default value")
	}
	if cfg.DefaultMode == "" {
		t.Error("DefaultMode should have a default value")
	}
	if cfg.DefaultLanguage == "" {
		t.Error("DefaultLanguage should have a default value")
	}
}

func TestManagerValidate(t *testing.T) {
	mgr, err := NewManager()
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	tests := []struct {
		name    string
		cfg     *Config
		wantErr bool
	}{
		{
			name: "valid config",
			cfg: &Config{
				DefaultModel:    models.ModelPplxPro,
				DefaultMode:     models.ModeDefault,
				DefaultLanguage: "en-US",
				DefaultSources:  []models.Source{models.SourceWeb},
			},
			wantErr: false,
		},
		{
			name: "invalid model",
			cfg: &Config{
				DefaultModel: models.Model("invalid_model"),
			},
			wantErr: true,
		},
		{
			name: "invalid mode",
			cfg: &Config{
				DefaultMode: models.Mode("invalid_mode"),
			},
			wantErr: true,
		},
		{
			name: "invalid language format",
			cfg: &Config{
				DefaultLanguage: "en_US", // underscore instead of dash
			},
			wantErr: true,
		},
		{
			name: "invalid source",
			cfg: &Config{
				DefaultSources: []models.Source{models.Source("invalid_source")},
			},
			wantErr: true,
		},
		{
			name: "empty config (uses defaults)",
			cfg: &Config{
				DefaultModel:   "",
				DefaultMode:    "",
				DefaultSources: nil,
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := mgr.validate(tt.cfg)
			if (err != nil) != tt.wantErr {
				t.Errorf("validate() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
</file>
<file path="internal/history/writer.go">
// Package history manages query history.
package history

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/diogo/perplexity-go/pkg/models"
)

// Writer handles writing history entries.
type Writer struct {
	path string
}

// NewWriter creates a new history writer.
func NewWriter(path string) (*Writer, error) {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0700); err != nil {
		return nil, fmt.Errorf("failed to create history directory: %w", err)
	}

	return &Writer{path: path}, nil
}

// Append adds a new entry to the history file.
func (w *Writer) Append(entry models.HistoryEntry) error {
	// Open file in append mode
	file, err := os.OpenFile(w.path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		return fmt.Errorf("failed to open history file: %w", err)
	}
	defer file.Close()

	// Set timestamp if not set
	if entry.Timestamp.IsZero() {
		entry.Timestamp = time.Now()
	}

	// Marshal to JSON
	data, err := json.Marshal(entry)
	if err != nil {
		return fmt.Errorf("failed to marshal history entry: %w", err)
	}

	// Write with newline
	if _, err := file.Write(append(data, '\n')); err != nil {
		return fmt.Errorf("failed to write history entry: %w", err)
	}

	return nil
}

// Reader handles reading history entries.
type Reader struct {
	path string
}

// NewReader creates a new history reader.
func NewReader(path string) *Reader {
	return &Reader{path: path}
}

// ReadAll reads all history entries.
func (r *Reader) ReadAll() ([]models.HistoryEntry, error) {
	file, err := os.Open(r.path)
	if err != nil {
		if os.IsNotExist(err) {
			return []models.HistoryEntry{}, nil
		}
		return nil, fmt.Errorf("failed to open history file: %w", err)
	}
	defer file.Close()

	var entries []models.HistoryEntry
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		if line == "" {
			continue
		}

		var entry models.HistoryEntry
		if err := json.Unmarshal([]byte(line), &entry); err != nil {
			// Skip malformed lines
			continue
		}
		entries = append(entries, entry)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading history: %w", err)
	}

	return entries, nil
}

// ReadLast reads the last n entries.
func (r *Reader) ReadLast(n int) ([]models.HistoryEntry, error) {
	entries, err := r.ReadAll()
	if err != nil {
		return nil, err
	}

	if len(entries) <= n {
		return entries, nil
	}

	return entries[len(entries)-n:], nil
}

// Clear removes all history entries.
func (r *Reader) Clear() error {
	// Truncate the file
	return os.Truncate(r.path, 0)
}

// Search finds entries matching the query.
func (r *Reader) Search(query string) ([]models.HistoryEntry, error) {
	entries, err := r.ReadAll()
	if err != nil {
		return nil, err
	}

	var results []models.HistoryEntry
	for _, entry := range entries {
		if containsIgnoreCase(entry.Query, query) {
			results = append(results, entry)
		}
	}

	return results, nil
}

// containsIgnoreCase checks if s contains substr (case-insensitive).
func containsIgnoreCase(s, substr string) bool {
	return len(s) >= len(substr) &&
		(s == substr || containsLower(toLower(s), toLower(substr)))
}

func toLower(s string) string {
	b := make([]byte, len(s))
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c >= 'A' && c <= 'Z' {
			c += 'a' - 'A'
		}
		b[i] = c
	}
	return string(b)
}

func containsLower(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
</file>
<file path="internal/history/writer_test.go">
package history

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/diogo/perplexity-go/pkg/models"
)

func TestNewWriter(t *testing.T) {
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "subdir", "history.jsonl")

	w, err := NewWriter(path)
	if err != nil {
		t.Fatalf("NewWriter() error = %v", err)
	}

	if w.path != path {
		t.Errorf("path = %q, want %q", w.path, path)
	}

	// Verify directory was created
	dir := filepath.Dir(path)
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		t.Error("Directory was not created")
	}
}

func TestWriterAppend(t *testing.T) {
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "history.jsonl")

	w, err := NewWriter(path)
	if err != nil {
		t.Fatalf("NewWriter() error = %v", err)
	}

	entry := models.HistoryEntry{
		Query:    "test query",
		Mode:     "default",
		Model:    "pplx_pro",
		Response: "test response",
	}

	if err := w.Append(entry); err != nil {
		t.Fatalf("Append() error = %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(path); os.IsNotExist(err) {
		t.Error("History file was not created")
	}

	// Read and verify
	reader := NewReader(path)
	entries, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	if len(entries) != 1 {
		t.Fatalf("len(entries) = %d, want 1", len(entries))
	}

	if entries[0].Query != "test query" {
		t.Errorf("Query = %q, want %q", entries[0].Query, "test query")
	}
	if entries[0].Timestamp.IsZero() {
		t.Error("Timestamp should be set automatically")
	}
}

func TestWriterAppendMultiple(t *testing.T) {
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "history.jsonl")

	w, err := NewWriter(path)
	if err != nil {
		t.Fatalf("NewWriter() error = %v", err)
	}

	for i := 0; i < 5; i++ {
		entry := models.HistoryEntry{
			Query: "query " + string(rune('0'+i)),
			Mode:  "default",
		}
		if err := w.Append(entry); err != nil {
			t.Fatalf("Append() error = %v", err)
		}
	}

	reader := NewReader(path)
	entries, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	if len(entries) != 5 {
		t.Errorf("len(entries) = %d, want 5", len(entries))
	}
}

func TestReaderReadAll(t *testing.T) {
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "history.jsonl")

	// Write test data
	content := `{"timestamp":"2024-01-01T10:00:00Z","query":"query1","mode":"default"}
{"timestamp":"2024-01-01T11:00:00Z","query":"query2","mode":"fast"}
`
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	reader := NewReader(path)
	entries, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	if len(entries) != 2 {
		t.Fatalf("len(entries) = %d, want 2", len(entries))
	}

	if entries[0].Query != "query1" {
		t.Errorf("entries[0].Query = %q, want %q", entries[0].Query, "query1")
	}
	if entries[1].Query != "query2" {
		t.Errorf("entries[1].Query = %q, want %q", entries[1].Query, "query2")
	}
}

func TestReaderReadAllEmpty(t *testing.T) {
	reader := NewReader("/nonexistent/path/history.jsonl")
	entries, err := reader.ReadAll()
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	if len(entries) != 0 {
		t.Errorf("len(entries) = %d, want 0", len(entries))
	}
}

func TestReaderReadLast(t *testing.T) {
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "history.jsonl")

	w, _ := NewWriter(path)
	for i := 0; i < 10; i++ {
		w.Append(models.HistoryEntry{
			Query:     "query " + string(rune('0'+i)),
			Timestamp: time.Now().Add(time.Duration(i) * time.Hour),
		})
	}

	reader := NewReader(path)

	// Read last 3
	entries, err := reader.ReadLast(3)
	if err != nil {
		t.Fatalf("ReadLast() error = %v", err)
	}

	if len(entries) != 3 {
		t.Errorf("len(entries) = %d, want 3", len(entries))
	}

	// Read more than available
	entries, err = reader.ReadLast(20)
	if err != nil {
		t.Fatalf("ReadLast() error = %v", err)
	}

	if len(entries) != 10 {
		t.Errorf("len(entries) = %d, want 10", len(entries))
	}
}

func TestReaderSearch(t *testing.T) {
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "history.jsonl")

	w, _ := NewWriter(path)
	w.Append(models.HistoryEntry{Query: "how to cook pasta"})
	w.Append(models.HistoryEntry{Query: "best restaurants nearby"})
	w.Append(models.HistoryEntry{Query: "pasta recipes italian"})
	w.Append(models.HistoryEntry{Query: "weather tomorrow"})

	reader := NewReader(path)

	// Search for "pasta"
	entries, err := reader.Search("pasta")
	if err != nil {
		t.Fatalf("Search() error = %v", err)
	}

	if len(entries) != 2 {
		t.Errorf("len(entries) = %d, want 2", len(entries))
	}

	// Case insensitive search
	entries, err = reader.Search("PASTA")
	if err != nil {
		t.Fatalf("Search() error = %v", err)
	}

	if len(entries) != 2 {
		t.Errorf("len(entries) = %d, want 2 (case insensitive)", len(entries))
	}

	// Search no results
	entries, err = reader.Search("nonexistent")
	if err != nil {
		t.Fatalf("Search() error = %v", err)
	}

	if len(entries) != 0 {
		t.Errorf("len(entries) = %d, want 0", len(entries))
	}
}

func TestReaderClear(t *testing.T) {
	tmpDir := t.TempDir()
	path := filepath.Join(tmpDir, "history.jsonl")

	w, _ := NewWriter(path)
	w.Append(models.HistoryEntry{Query: "test"})
	w.Append(models.HistoryEntry{Query: "test2"})

	reader := NewReader(path)

	// Verify entries exist
	entries, _ := reader.ReadAll()
	if len(entries) != 2 {
		t.Fatalf("Expected 2 entries before clear")
	}

	// Clear
	if err := reader.Clear(); err != nil {
		t.Fatalf("Clear() error = %v", err)
	}

	// Verify empty
	entries, _ = reader.ReadAll()
	if len(entries) != 0 {
		t.Errorf("len(entries) = %d, want 0 after clear", len(entries))
	}
}

func TestContainsIgnoreCase(t *testing.T) {
	tests := []struct {
		s      string
		substr string
		want   bool
	}{
		{"Hello World", "world", true},
		{"Hello World", "WORLD", true},
		{"Hello World", "World", true},
		{"Hello World", "xyz", false},
		{"hello", "hello", true},
		{"hello", "HELLO", true},
		{"short", "longer", false},
		{"", "test", false},
		{"test", "", true},
	}

	for _, tt := range tests {
		got := containsIgnoreCase(tt.s, tt.substr)
		if got != tt.want {
			t.Errorf("containsIgnoreCase(%q, %q) = %v, want %v", tt.s, tt.substr, got, tt.want)
		}
	}
}
</file>
<file path="internal/ui/config_menu.go">
package ui

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogo/perplexity-go/internal/config"
	"github.com/diogo/perplexity-go/pkg/models"
)

// customKeyMap returns a keymap that includes ESC as a quit key.
func customKeyMap() *huh.KeyMap {
	km := huh.NewDefaultKeyMap()
	km.Quit = key.NewBinding(
		key.WithKeys("esc", "ctrl+c"),
		key.WithHelp("esc", "back"),
	)
	return km
}

// ConfigMenuItem represents a configuration option in the menu.
type ConfigMenuItem struct {
	Key         string
	Label       string
	Description string
	Value       string
}

// RunInteractiveConfig displays an interactive configuration menu.
func RunInteractiveConfig(cfg *config.Config, cfgMgr *config.Manager) error {
	for {
		// Build menu items with current values
		items := buildConfigMenuItems(cfg)

		// Create options for the select menu
		options := make([]huh.Option[string], len(items)+2)
		for i, item := range items {
			label := fmt.Sprintf("%-18s %s", item.Label, DimStyle.Render(item.Value))
			options[i] = huh.NewOption(label, item.Key)
		}
		options[len(items)] = huh.NewOption(SuccessStyle.Render("Save and exit"), "save")
		options[len(items)+1] = huh.NewOption(WarningStyle.Render("Reset to defaults"), "reset")

		var selected string
		selectForm := huh.NewForm(
			huh.NewGroup(
				huh.NewSelect[string]().
					Title("Configuration").
					Description("Select an option to modify").
					Options(options...).
					Value(&selected),
			),
		)

		if err := selectForm.Run(); err != nil {
			if err == huh.ErrUserAborted {
				return nil // User pressed ESC, exit the loop to return
			}
			return err
		}

		switch selected {
		case "save":
			if err := cfgMgr.Save(cfg); err != nil {
				return fmt.Errorf("failed to save config: %w", err)
			}
			fmt.Println(SuccessStyle.Render("Configuration saved!"))
			return nil

		case "reset":
			if err := handleReset(cfg); err != nil {
				return err
			}

		default:
			if err := handleConfigEdit(cfg, selected); err != nil {
				return err
			}
		}
	}
}

func buildConfigMenuItems(cfg *config.Config) []ConfigMenuItem {
	sources := make([]string, len(cfg.DefaultSources))
	for i, s := range cfg.DefaultSources {
		sources[i] = string(s)
	}

	return []ConfigMenuItem{
		{
			Key:         "default_model",
			Label:       "Model",
			Description: "Default AI model",
			Value:       string(cfg.DefaultModel),
		},
		{
			Key:         "default_mode",
			Label:       "Mode",
			Description: "Default search mode",
			Value:       string(cfg.DefaultMode),
		},
		{
			Key:         "default_language",
			Label:       "Language",
			Description: "Response language (e.g., en-US)",
			Value:       cfg.DefaultLanguage,
		},
		{
			Key:         "default_sources",
			Label:       "Sources",
			Description: "Search sources",
			Value:       strings.Join(sources, ", "),
		},
		{
			Key:         "streaming",
			Label:       "Streaming",
			Description: "Enable streaming output",
			Value:       fmt.Sprintf("%v", cfg.Streaming),
		},
		{
			Key:         "incognito",
			Label:       "Incognito",
			Description: "Don't save to history",
			Value:       fmt.Sprintf("%v", cfg.Incognito),
		},
		{
			Key:         "cookie_file",
			Label:       "Cookie file",
			Description: "Path to cookies file",
			Value:       cfg.CookieFile,
		},
		{
			Key:         "history_file",
			Label:       "History file",
			Description: "Path to history file",
			Value:       cfg.HistoryFile,
		},
	}
}

func handleConfigEdit(cfg *config.Config, key string) error {
	switch key {
	case "default_model":
		return editModel(cfg)
	case "default_mode":
		return editMode(cfg)
	case "default_language":
		return editLanguage(cfg)
	case "default_sources":
		return editSources(cfg)
	case "streaming":
		return editBool(cfg, "streaming", "Enable streaming output?", &cfg.Streaming)
	case "incognito":
		return editBool(cfg, "incognito", "Enable incognito mode?", &cfg.Incognito)
	case "cookie_file":
		return editString("Cookie file path", &cfg.CookieFile)
	case "history_file":
		return editString("History file path", &cfg.HistoryFile)
	}
	return nil
}

func editModel(cfg *config.Config) error {
	options := make([]huh.Option[string], len(models.AvailableModels))
	for i, m := range models.AvailableModels {
		options[i] = huh.NewOption(string(m), string(m))
	}

	var selected string
	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Select Model").
				Description("Choose the default AI model (Esc to go back)").
				Options(options...).
				Value(&selected),
		),
	).WithKeyMap(customKeyMap())

	if err := form.Run(); err != nil {
		if err == huh.ErrUserAborted {
			return nil
		}
		return err
	}

	cfg.DefaultModel = models.Model(selected)
	return nil
}

func editMode(cfg *config.Config) error {
	modes := []models.Mode{
		models.ModeFast,
		models.ModePro,
		models.ModeReasoning,
		models.ModeDeepResearch,
		models.ModeDefault,
	}

	options := make([]huh.Option[string], len(modes))
	for i, m := range modes {
		desc := getModeDescription(m)
		options[i] = huh.NewOption(fmt.Sprintf("%-15s %s", string(m), DimStyle.Render(desc)), string(m))
	}

	var selected string
	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Select Mode").
				Description("Choose the default search mode (Esc to go back)").
				Options(options...).
				Value(&selected),
		),
	).WithKeyMap(customKeyMap())

	if err := form.Run(); err != nil {
		if err == huh.ErrUserAborted {
			return nil
		}
		return err
	}

	cfg.DefaultMode = models.Mode(selected)
	return nil
}

func getModeDescription(m models.Mode) string {
	switch m {
	case models.ModeFast:
		return "Quick responses"
	case models.ModePro:
		return "Balanced quality"
	case models.ModeReasoning:
		return "Deep analysis"
	case models.ModeDeepResearch:
		return "Comprehensive research"
	case models.ModeDefault:
		return "Standard mode"
	default:
		return ""
	}
}

func editLanguage(cfg *config.Config) error {
	commonLanguages := []struct {
		code string
		name string
	}{
		{"en-US", "English (US)"},
		{"en-GB", "English (UK)"},
		{"pt-BR", "Portuguese (Brazil)"},
		{"pt-PT", "Portuguese (Portugal)"},
		{"es-ES", "Spanish (Spain)"},
		{"es-MX", "Spanish (Mexico)"},
		{"fr-FR", "French"},
		{"de-DE", "German"},
		{"it-IT", "Italian"},
		{"ja-JP", "Japanese"},
		{"ko-KR", "Korean"},
		{"zh-CN", "Chinese (Simplified)"},
		{"zh-TW", "Chinese (Traditional)"},
	}

	options := make([]huh.Option[string], len(commonLanguages)+1)
	for i, lang := range commonLanguages {
		options[i] = huh.NewOption(fmt.Sprintf("%-7s %s", lang.code, lang.name), lang.code)
	}
	options[len(commonLanguages)] = huh.NewOption("Other (enter custom)", "custom")

	var selected string
	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Select Language").
				Description("Choose the response language (Esc to go back)").
				Options(options...).
				Value(&selected),
		),
	).WithKeyMap(customKeyMap())

	if err := form.Run(); err != nil {
		if err == huh.ErrUserAborted {
			return nil
		}
		return err
	}

	if selected == "custom" {
		var customLang string
		inputForm := huh.NewForm(
			huh.NewGroup(
				huh.NewInput().
					Title("Custom Language").
					Description("Enter language code, e.g., en-US (Esc to go back)").
					Placeholder("xx-XX").
					Value(&customLang).
					Validate(func(s string) error {
						if len(s) != 5 || s[2] != '-' {
							return fmt.Errorf("invalid format, use xx-XX")
						}
						return nil
					}),
			),
		).WithKeyMap(customKeyMap())

		if err := inputForm.Run(); err != nil {
			if err == huh.ErrUserAborted {
				return nil
			}
			return err
		}
		cfg.DefaultLanguage = customLang
	} else {
		cfg.DefaultLanguage = selected
	}

	return nil
}

func editSources(cfg *config.Config) error {
	currentSources := make(map[models.Source]bool)
	for _, s := range cfg.DefaultSources {
		currentSources[s] = true
	}

	var selected []string
	options := make([]huh.Option[string], len(models.AvailableSources))
	for i, s := range models.AvailableSources {
		options[i] = huh.NewOption(string(s), string(s))
	}

	// Pre-select current sources
	for _, s := range cfg.DefaultSources {
		selected = append(selected, string(s))
	}

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewMultiSelect[string]().
				Title("Select Sources").
				Description("Choose search sources, at least one (Esc to go back)").
				Options(options...).
				Value(&selected).
				Validate(func(s []string) error {
					if len(s) == 0 {
						return fmt.Errorf("select at least one source")
					}
					return nil
				}),
		),
	).WithKeyMap(customKeyMap())

	if err := form.Run(); err != nil {
		if err == huh.ErrUserAborted {
			return nil
		}
		return err
	}

	cfg.DefaultSources = make([]models.Source, len(selected))
	for i, s := range selected {
		cfg.DefaultSources[i] = models.Source(s)
	}

	return nil
}

func editBool(cfg *config.Config, name, title string, value *bool) error {
	options := []huh.Option[bool]{
		huh.NewOption("Yes", true),
		huh.NewOption("No", false),
	}

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[bool]().
				Title(title + " (Esc to go back)").
				Options(options...).
				Value(value),
		),
	).WithKeyMap(customKeyMap())

	if err := form.Run(); err != nil {
		if err == huh.ErrUserAborted {
			return nil
		}
		return err
	}

	return nil
}

func editString(title string, value *string) error {
	form := huh.NewForm(
		huh.NewGroup(
			huh.NewInput().
				Title(title + " (Esc to go back)").
				Value(value),
		),
	).WithKeyMap(customKeyMap())

	if err := form.Run(); err != nil {
		if err == huh.ErrUserAborted {
			return nil
		}
		return err
	}

	return nil
}

func handleReset(cfg *config.Config) error {
	var confirm bool
	form := huh.NewForm(
		huh.NewGroup(
			huh.NewConfirm().
				Title("Reset Configuration (Esc to go back)").
				Description("Are you sure you want to reset all settings to defaults?").
				Affirmative("Yes, reset").
				Negative("Cancel").
				Value(&confirm),
		),
	).WithKeyMap(customKeyMap())

	if err := form.Run(); err != nil {
		if err == huh.ErrUserAborted {
			return nil
		}
		return err
	}

	if confirm {
		cfg.DefaultModel = models.ModelPplxPro
		cfg.DefaultMode = models.ModeDefault
		cfg.DefaultLanguage = "en-US"
		cfg.DefaultSources = []models.Source{models.SourceWeb}
		cfg.Streaming = true
		cfg.Incognito = false
		fmt.Println(lipgloss.NewStyle().Foreground(lipgloss.Color("214")).Render("Configuration reset to defaults"))
	}

	return nil
}
</file>
<file path="internal/ui/config_menu_test.go">
package ui

import (
	"testing"

	"github.com/diogo/perplexity-go/internal/config"
	"github.com/diogo/perplexity-go/pkg/models"
)

func TestBuildConfigMenuItems(t *testing.T) {
	cfg := &config.Config{
		DefaultModel:    models.ModelGPT51,
		DefaultMode:     models.ModePro,
		DefaultLanguage: "pt-BR",
		DefaultSources:  []models.Source{models.SourceWeb, models.SourceScholar},
		Streaming:       true,
		Incognito:       false,
		CookieFile:      "/path/to/cookies.json",
		HistoryFile:     "/path/to/history.jsonl",
	}

	items := buildConfigMenuItems(cfg)

	if len(items) != 8 {
		t.Errorf("Expected 8 menu items, got %d", len(items))
	}

	// Verify each item
	expectedItems := map[string]string{
		"default_model":    "gpt51",
		"default_mode":     "pro",
		"default_language": "pt-BR",
		"default_sources":  "web, scholar",
		"streaming":        "true",
		"incognito":        "false",
		"cookie_file":      "/path/to/cookies.json",
		"history_file":     "/path/to/history.jsonl",
	}

	for _, item := range items {
		expected, ok := expectedItems[item.Key]
		if !ok {
			t.Errorf("Unexpected menu item key: %s", item.Key)
			continue
		}
		if item.Value != expected {
			t.Errorf("Item %s: expected value %q, got %q", item.Key, expected, item.Value)
		}
	}
}

func TestBuildConfigMenuItems_EmptySources(t *testing.T) {
	cfg := &config.Config{
		DefaultSources: []models.Source{},
	}

	items := buildConfigMenuItems(cfg)

	// Find sources item
	var sourcesItem ConfigMenuItem
	for _, item := range items {
		if item.Key == "default_sources" {
			sourcesItem = item
			break
		}
	}

	if sourcesItem.Value != "" {
		t.Errorf("Expected empty sources value, got %q", sourcesItem.Value)
	}
}

func TestGetModeDescription(t *testing.T) {
	tests := []struct {
		mode     models.Mode
		expected string
	}{
		{models.ModeFast, "Quick responses"},
		{models.ModePro, "Balanced quality"},
		{models.ModeReasoning, "Deep analysis"},
		{models.ModeDeepResearch, "Comprehensive research"},
		{models.ModeDefault, "Standard mode"},
		{models.Mode("unknown"), ""},
	}

	for _, tt := range tests {
		t.Run(string(tt.mode), func(t *testing.T) {
			result := getModeDescription(tt.mode)
			if result != tt.expected {
				t.Errorf("getModeDescription(%s) = %q, want %q", tt.mode, result, tt.expected)
			}
		})
	}
}

func TestConfigMenuItem_Fields(t *testing.T) {
	item := ConfigMenuItem{
		Key:         "test_key",
		Label:       "Test Label",
		Description: "Test Description",
		Value:       "test_value",
	}

	if item.Key != "test_key" {
		t.Errorf("Key = %q, want %q", item.Key, "test_key")
	}
	if item.Label != "Test Label" {
		t.Errorf("Label = %q, want %q", item.Label, "Test Label")
	}
	if item.Description != "Test Description" {
		t.Errorf("Description = %q, want %q", item.Description, "Test Description")
	}
	if item.Value != "test_value" {
		t.Errorf("Value = %q, want %q", item.Value, "test_value")
	}
}

func TestHandleReset_ConfigValues(t *testing.T) {
	cfg := &config.Config{
		DefaultModel:    models.ModelGPT51,
		DefaultMode:     models.ModeReasoning,
		DefaultLanguage: "pt-BR",
		DefaultSources:  []models.Source{models.SourceScholar},
		Streaming:       false,
		Incognito:       true,
	}

	// Reset to defaults (simulating what handleReset does when confirmed)
	cfg.DefaultModel = models.ModelPplxPro
	cfg.DefaultMode = models.ModeDefault
	cfg.DefaultLanguage = "en-US"
	cfg.DefaultSources = []models.Source{models.SourceWeb}
	cfg.Streaming = true
	cfg.Incognito = false

	// Verify reset values
	if cfg.DefaultModel != models.ModelPplxPro {
		t.Errorf("DefaultModel = %q, want %q", cfg.DefaultModel, models.ModelPplxPro)
	}
	if cfg.DefaultMode != models.ModeDefault {
		t.Errorf("DefaultMode = %q, want %q", cfg.DefaultMode, models.ModeDefault)
	}
	if cfg.DefaultLanguage != "en-US" {
		t.Errorf("DefaultLanguage = %q, want %q", cfg.DefaultLanguage, "en-US")
	}
	if len(cfg.DefaultSources) != 1 || cfg.DefaultSources[0] != models.SourceWeb {
		t.Errorf("DefaultSources = %v, want [web]", cfg.DefaultSources)
	}
	if !cfg.Streaming {
		t.Error("Streaming should be true after reset")
	}
	if cfg.Incognito {
		t.Error("Incognito should be false after reset")
	}
}

func TestBuildConfigMenuItems_AllModels(t *testing.T) {
	// Test with each available model
	for _, model := range models.AvailableModels {
		cfg := &config.Config{
			DefaultModel: model,
		}

		items := buildConfigMenuItems(cfg)

		// Find model item
		var modelItem ConfigMenuItem
		for _, item := range items {
			if item.Key == "default_model" {
				modelItem = item
				break
			}
		}

		if modelItem.Value != string(model) {
			t.Errorf("Model %s: expected value %q, got %q", model, string(model), modelItem.Value)
		}
	}
}

func TestBuildConfigMenuItems_AllModes(t *testing.T) {
	modes := []models.Mode{
		models.ModeFast,
		models.ModePro,
		models.ModeReasoning,
		models.ModeDeepResearch,
		models.ModeDefault,
	}

	for _, mode := range modes {
		cfg := &config.Config{
			DefaultMode: mode,
		}

		items := buildConfigMenuItems(cfg)

		// Find mode item
		var modeItem ConfigMenuItem
		for _, item := range items {
			if item.Key == "default_mode" {
				modeItem = item
				break
			}
		}

		if modeItem.Value != string(mode) {
			t.Errorf("Mode %s: expected value %q, got %q", mode, string(mode), modeItem.Value)
		}
	}
}

func TestBuildConfigMenuItems_AllSources(t *testing.T) {
	cfg := &config.Config{
		DefaultSources: models.AvailableSources,
	}

	items := buildConfigMenuItems(cfg)

	// Find sources item
	var sourcesItem ConfigMenuItem
	for _, item := range items {
		if item.Key == "default_sources" {
			sourcesItem = item
			break
		}
	}

	// Should contain all sources
	expectedValue := "web, scholar, social"
	if sourcesItem.Value != expectedValue {
		t.Errorf("Sources value = %q, want %q", sourcesItem.Value, expectedValue)
	}
}

func TestConfigMenuItemLabels(t *testing.T) {
	cfg := &config.Config{}
	items := buildConfigMenuItems(cfg)

	expectedLabels := map[string]string{
		"default_model":    "Model",
		"default_mode":     "Mode",
		"default_language": "Language",
		"default_sources":  "Sources",
		"streaming":        "Streaming",
		"incognito":        "Incognito",
		"cookie_file":      "Cookie file",
		"history_file":     "History file",
	}

	for _, item := range items {
		expected, ok := expectedLabels[item.Key]
		if !ok {
			t.Errorf("Unexpected item key: %s", item.Key)
			continue
		}
		if item.Label != expected {
			t.Errorf("Item %s: expected label %q, got %q", item.Key, expected, item.Label)
		}
	}
}

func TestBuildConfigMenuItems_BooleanValues(t *testing.T) {
	tests := []struct {
		name       string
		streaming  bool
		incognito  bool
		expStream  string
		expIncog   string
	}{
		{"both_true", true, true, "true", "true"},
		{"both_false", false, false, "false", "false"},
		{"mixed", true, false, "true", "false"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := &config.Config{
				Streaming: tt.streaming,
				Incognito: tt.incognito,
			}

			items := buildConfigMenuItems(cfg)

			var streamingValue, incognitoValue string
			for _, item := range items {
				if item.Key == "streaming" {
					streamingValue = item.Value
				}
				if item.Key == "incognito" {
					incognitoValue = item.Value
				}
			}

			if streamingValue != tt.expStream {
				t.Errorf("Streaming = %q, want %q", streamingValue, tt.expStream)
			}
			if incognitoValue != tt.expIncog {
				t.Errorf("Incognito = %q, want %q", incognitoValue, tt.expIncog)
			}
		})
	}
}
</file>
<file path="internal/ui/renderer.go">
// Package ui handles terminal output and formatting.
package ui

import (
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/charmbracelet/glamour"
	"github.com/charmbracelet/lipgloss"
	"github.com/diogo/perplexity-go/pkg/models"
)

// Renderer handles terminal output formatting.
type Renderer struct {
	out       io.Writer
	mdRender  *glamour.TermRenderer
	width     int
	useColors bool
}

// Styles for different output elements.
var (
	// Custom Warm Colors for Theme
	WarmColorPrimary = lipgloss.Color("#F9C74F") // Light orange/yellow
	WarmColorDark    = lipgloss.Color("#E36414") // Darker orange
	WarmColorBg      = lipgloss.Color("#1E1E1E") // Dark background for code

	TitleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(WarmColorPrimary).
			MarginBottom(1)

	InfoStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("241"))

	ErrorStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("196"))

	SuccessStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("82"))

	WarningStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("214"))

	SpinnerStyle = lipgloss.NewStyle().
		Foreground(WarmColorPrimary)

	// Style for the main response container (border, padding)
	ResponseContainerStyle = lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(WarmColorPrimary).
		Padding(1, 2).
		Margin(1, 0, 0, 0)

	CitationStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Underline(true)

	DimStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("245"))

	SpinnerChars = []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}
)

// NewRenderer creates a new output renderer.
func NewRenderer() (*Renderer, error) {
	return NewRendererWithOptions(os.Stdout, 80, true)
}

// NewRendererWithOptions creates a renderer with custom options.
func NewRendererWithOptions(out io.Writer, width int, useColors bool) (*Renderer, error) {
	style := "dark"
	if !useColors {
		style = "notty"
	}

	mdRender, err := glamour.NewTermRenderer(
		glamour.WithAutoStyle(),
		glamour.WithStylePath("dracula"), // A good warm-ish, dark theme for code highlighting
		glamour.WithWordWrap(width),
		glamour.WithStylePath(style),
	)
	if err != nil {
		// Fallback to basic renderer
		mdRender, _ = glamour.NewTermRenderer(
			glamour.WithWordWrap(width),
		)
	}

	return &Renderer{
		out:       out,
		mdRender:  mdRender,
		width:     width,
		useColors: useColors,
	}, nil
}

// RenderMarkdown renders markdown content.
func (r *Renderer) RenderMarkdown(content string) error {
	if r.mdRender == nil {
		// Fallback: print raw content
		fmt.Fprintln(r.out, content)
		return nil
	}

	rendered, err := r.mdRender.Render(content)
	if err != nil {
		// Fallback to raw content on error
		fmt.Fprintln(r.out, content)
		return nil
	}

	fmt.Fprint(r.out, rendered)
	return nil
}

// RenderStyledResponse renders content inside the stylized container with Markdown formatting.
func (r *Renderer) RenderStyledResponse(content string) error {
	if r.mdRender == nil {
		fmt.Fprintln(r.out, content)
		return nil
	}
	// 1. Render Markdown content internally using glamour
	rendered, err := r.mdRender.Render(content)
	if err != nil {
		return r.RenderMarkdown(content) // Fallback to basic markdown render
	}
	// 2. Wrap the rendered content in the container style
	styledContent := ResponseContainerStyle.
		Width(r.width).
		Foreground(lipgloss.Color("252")). // Light gray text for readability inside the box
		Render(rendered)
	fmt.Fprintln(r.out, styledContent)
	return nil
}

// RenderResponse renders a complete search response.
func (r *Renderer) RenderResponse(resp *models.SearchResponse) error {
	// First check for new format with direct Text and WebResults
	if resp.Text != "" {
		if err := r.RenderStyledResponse(resp.Text); err != nil {
			return err
		}

		// Render web results from new format
		if len(resp.WebResults) > 0 {
			r.RenderWebResults(resp.WebResults)
		}
		return nil
	}

	// Fallback: Find and render markdown blocks (legacy format)
	for _, block := range resp.Blocks {
		if block.MarkdownBlock != nil {
			if err := r.RenderStyledResponse(block.MarkdownBlock.Answer); err != nil {
				return err
			}

			// Render citations if present
			if len(block.MarkdownBlock.Citations) > 0 {
				r.RenderCitations(block.MarkdownBlock.Citations)
			}
		}
	}

	return nil
}

// RenderCitations renders source citations.
func (r *Renderer) RenderCitations(citations []models.Citation) {
	if len(citations) == 0 {
		return
	}

	fmt.Fprintln(r.out)
	fmt.Fprintln(r.out, DimStyle.Render("Sources:"))

	for i, cite := range citations {
		title := cite.Title
		if title == "" {
			title = cite.URL
		}

		num := fmt.Sprintf("[%d]", i+1)
		fmt.Fprintf(r.out, "%s %s\n", DimStyle.Render(num), CitationStyle.Render(title))
		if cite.URL != "" && cite.URL != title {
			fmt.Fprintf(r.out, "    %s\n", DimStyle.Render(cite.URL))
		}
	}
}

// RenderWebResults renders web search results from new API format.
func (r *Renderer) RenderWebResults(results []models.WebResult) {
	if len(results) == 0 {
		return
	}

	// Filter out internal calculator results
	var filteredResults []models.WebResult
	for _, wr := range results {
		if wr.URL != "https://perplexity.ai" && wr.URL != "" {
			filteredResults = append(filteredResults, wr)
		}
	}

	if len(filteredResults) == 0 {
		return
	}

	fmt.Fprintln(r.out)
	fmt.Fprintln(r.out, DimStyle.Render("Sources:"))

	for i, wr := range filteredResults {
		title := wr.Title
		if title == "" {
			title = wr.Name
		}
		if title == "" {
			title = wr.URL
		}

		num := fmt.Sprintf("[%d]", i+1)
		fmt.Fprintf(r.out, "%s %s\n", DimStyle.Render(num), CitationStyle.Render(title))
		if wr.URL != "" && wr.URL != title {
			fmt.Fprintf(r.out, "    %s\n", DimStyle.Render(wr.URL))
		}
	}
}

// RenderStreamChunk renders a streaming chunk (token-by-token).
func (r *Renderer) RenderStreamChunk(chunk models.StreamChunk) {
	if chunk.Delta != "" {
		fmt.Fprint(r.out, chunk.Delta)
	} else if chunk.Text != "" {
		fmt.Fprint(r.out, chunk.Text)
	}
}

// RenderError renders an error message.
func (r *Renderer) RenderError(err error) {
	if r.useColors {
		fmt.Fprintln(r.out, ErrorStyle.Render("Error: "+err.Error()))
	} else {
		fmt.Fprintln(r.out, "Error: "+err.Error())
	}
}

// RenderSuccess renders a success message.
func (r *Renderer) RenderSuccess(msg string) {
	if r.useColors {
		fmt.Fprintln(r.out, SuccessStyle.Render(msg))
	} else {
		fmt.Fprintln(r.out, msg)
	}
}

// RenderWarning renders a warning message.
func (r *Renderer) RenderWarning(msg string) {
	if r.useColors {
		fmt.Fprintln(r.out, WarningStyle.Render("Warning: "+msg))
	} else {
		fmt.Fprintln(r.out, "Warning: "+msg)
	}
}

// RenderInfo renders an info message.
func (r *Renderer) RenderInfo(msg string) {
	if r.useColors {
		fmt.Fprintln(r.out, InfoStyle.Render(msg))
	} else {
		fmt.Fprintln(r.out, msg)
	}
}

// RenderTitle renders a title.
func (r *Renderer) RenderTitle(title string) {
	if r.useColors {
		fmt.Fprintln(r.out, TitleStyle.Render(title))
	} else {
		fmt.Fprintln(r.out, strings.ToUpper(title))
		fmt.Fprintln(r.out, strings.Repeat("=", len(title)))
	}
}

// RenderSpinner renders a spinner character.
func (r *Renderer) RenderSpinner(frame int) {
	idx := frame % len(SpinnerChars)
	fmt.Fprintf(r.out, "\r%s ", SpinnerStyle.Render(SpinnerChars[idx]))
}

// ClearLine clears the current line.
func (r *Renderer) ClearLine() {
	fmt.Fprint(r.out, "\r\033[K")
}

// NewLine prints a newline.
func (r *Renderer) NewLine() {
	fmt.Fprintln(r.out)
}
</file>
<file path="internal/ui/renderer_test.go">
package ui

import (
	"bytes"
	"errors"
	"strings"
	"testing"

	"github.com/diogo/perplexity-go/pkg/models"
)

func TestNewRenderer(t *testing.T) {
	r, err := NewRenderer()
	if err != nil {
		t.Fatalf("NewRenderer() error = %v", err)
	}
	if r == nil {
		t.Fatal("NewRenderer() returned nil")
	}
	if r.width != 80 {
		t.Errorf("width = %d, want 80", r.width)
	}
	if !r.useColors {
		t.Error("useColors should be true by default")
	}
}

func TestNewRendererWithOptions(t *testing.T) {
	var buf bytes.Buffer

	r, err := NewRendererWithOptions(&buf, 120, false)
	if err != nil {
		t.Fatalf("NewRendererWithOptions() error = %v", err)
	}

	if r.width != 120 {
		t.Errorf("width = %d, want 120", r.width)
	}
	if r.useColors {
		t.Error("useColors should be false")
	}
}

func TestRenderMarkdown(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	err := r.RenderMarkdown("# Hello World\n\nThis is a test.")
	if err != nil {
		t.Fatalf("RenderMarkdown() error = %v", err)
	}

	output := buf.String()
	if output == "" {
		t.Error("Output should not be empty")
	}
}

func TestRenderStreamChunk(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with delta
	chunk := models.StreamChunk{Delta: "Hello "}
	r.RenderStreamChunk(chunk)

	if buf.String() != "Hello " {
		t.Errorf("Output = %q, want %q", buf.String(), "Hello ")
	}

	// Test with text
	buf.Reset()
	chunk = models.StreamChunk{Text: "World"}
	r.RenderStreamChunk(chunk)

	if buf.String() != "World" {
		t.Errorf("Output = %q, want %q", buf.String(), "World")
	}
}

func TestRenderError(t *testing.T) {
	var buf bytes.Buffer

	// With colors
	r, _ := NewRendererWithOptions(&buf, 80, true)
	r.RenderError(errors.New("test error"))
	if !strings.Contains(buf.String(), "test error") {
		t.Error("Output should contain error message")
	}

	// Without colors
	buf.Reset()
	r, _ = NewRendererWithOptions(&buf, 80, false)
	r.RenderError(errors.New("test error"))
	if buf.String() != "Error: test error\n" {
		t.Errorf("Output = %q, want %q", buf.String(), "Error: test error\n")
	}
}

func TestRenderSuccess(t *testing.T) {
	var buf bytes.Buffer

	// With colors
	r, _ := NewRendererWithOptions(&buf, 80, true)
	r.RenderSuccess("Operation completed")
	if !strings.Contains(buf.String(), "Operation completed") {
		t.Error("Output should contain success message")
	}

	// Without colors
	buf.Reset()
	r, _ = NewRendererWithOptions(&buf, 80, false)
	r.RenderSuccess("Operation completed")
	if buf.String() != "Operation completed\n" {
		t.Errorf("Output = %q, want %q", buf.String(), "Operation completed\n")
	}
}

func TestRenderWarning(t *testing.T) {
	var buf bytes.Buffer

	// With colors
	r, _ := NewRendererWithOptions(&buf, 80, true)
	r.RenderWarning("Be careful")
	if !strings.Contains(buf.String(), "Be careful") {
		t.Error("Output should contain warning message")
	}

	// Without colors
	buf.Reset()
	r, _ = NewRendererWithOptions(&buf, 80, false)
	r.RenderWarning("Be careful")
	if buf.String() != "Warning: Be careful\n" {
		t.Errorf("Output = %q, want %q", buf.String(), "Warning: Be careful\n")
	}
}

func TestRenderInfo(t *testing.T) {
	var buf bytes.Buffer

	// With colors
	r, _ := NewRendererWithOptions(&buf, 80, true)
	r.RenderInfo("Some information")
	if !strings.Contains(buf.String(), "Some information") {
		t.Error("Output should contain info message")
	}

	// Without colors
	buf.Reset()
	r, _ = NewRendererWithOptions(&buf, 80, false)
	r.RenderInfo("Some information")
	if buf.String() != "Some information\n" {
		t.Errorf("Output = %q, want %q", buf.String(), "Some information\n")
	}
}

func TestRenderTitle(t *testing.T) {
	var buf bytes.Buffer

	// With colors
	r, _ := NewRendererWithOptions(&buf, 80, true)
	r.RenderTitle("My Title")
	if !strings.Contains(buf.String(), "My Title") {
		t.Error("Output should contain title")
	}

	// Without colors
	buf.Reset()
	r, _ = NewRendererWithOptions(&buf, 80, false)
	r.RenderTitle("My Title")
	output := buf.String()
	if !strings.Contains(output, "MY TITLE") {
		t.Error("Output should contain uppercase title")
	}
	if !strings.Contains(output, "========") {
		t.Error("Output should contain underline")
	}
}

func TestRenderCitations(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	citations := []models.Citation{
		{URL: "https://example.com/1", Title: "Example 1"},
		{URL: "https://example.com/2", Title: "Example 2"},
	}

	r.RenderCitations(citations)

	output := buf.String()
	if !strings.Contains(output, "Sources:") {
		t.Error("Output should contain 'Sources:' header")
	}
	if !strings.Contains(output, "[1]") {
		t.Error("Output should contain citation number [1]")
	}
	if !strings.Contains(output, "[2]") {
		t.Error("Output should contain citation number [2]")
	}
	if !strings.Contains(output, "Example 1") {
		t.Error("Output should contain citation title")
	}
}

func TestRenderCitationsEmpty(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	r.RenderCitations(nil)
	if buf.String() != "" {
		t.Error("Empty citations should produce no output")
	}

	r.RenderCitations([]models.Citation{})
	if buf.String() != "" {
		t.Error("Empty citations slice should produce no output")
	}
}

func TestRenderCitationsURLOnly(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	citations := []models.Citation{
		{URL: "https://example.com/page"},
	}

	r.RenderCitations(citations)

	output := buf.String()
	if !strings.Contains(output, "https://example.com/page") {
		t.Error("Output should contain URL when no title")
	}
}

func TestRenderSpinner(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, true)

	for i := 0; i < len(SpinnerChars)+1; i++ {
		buf.Reset()
		r.RenderSpinner(i)
		output := buf.String()
		if !strings.HasPrefix(output, "\r") {
			t.Error("Spinner should start with carriage return")
		}
	}
}

func TestClearLine(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, true)

	r.ClearLine()
	if !strings.Contains(buf.String(), "\r") {
		t.Error("ClearLine should contain carriage return")
	}
}

func TestNewLine(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, true)

	r.NewLine()
	if buf.String() != "\n" {
		t.Errorf("NewLine() output = %q, want %q", buf.String(), "\n")
	}
}

func TestRenderResponse(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	resp := &models.SearchResponse{
		Blocks: []models.ResponseBlock{
			{
				MarkdownBlock: &models.MarkdownBlock{
					Answer: "This is the answer.",
					Citations: []models.Citation{
						{URL: "https://example.com", Title: "Source"},
					},
				},
			},
		},
	}

	err := r.RenderResponse(resp)
	if err != nil {
		t.Fatalf("RenderResponse() error = %v", err)
	}

	output := buf.String()
	if !strings.Contains(output, "This is the answer") {
		t.Error("Output should contain the answer")
	}
	if !strings.Contains(output, "Sources:") {
		t.Error("Output should contain citations")
	}
}

func TestRenderResponseNoBlocks(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	resp := &models.SearchResponse{
		Text: "Raw text response",
	}

	err := r.RenderResponse(resp)
	if err != nil {
		t.Fatalf("RenderResponse() error = %v", err)
	}

	if !strings.Contains(buf.String(), "Raw text response") {
		t.Error("Output should contain raw text when no blocks")
	}
}

func TestSpinnerChars(t *testing.T) {
	if len(SpinnerChars) == 0 {
		t.Error("SpinnerChars should not be empty")
	}

	// Verify all are valid unicode characters
	for i, char := range SpinnerChars {
		if char == "" {
			t.Errorf("SpinnerChars[%d] should not be empty", i)
		}
	}
}

func TestRenderWebResultsEmpty(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with nil slice
	r.RenderWebResults(nil)
	if buf.String() != "" {
		t.Error("Nil results should produce no output")
	}

	// Test with empty slice
	buf.Reset()
	r.RenderWebResults([]models.WebResult{})
	if buf.String() != "" {
		t.Error("Empty results should produce no output")
	}
}

func TestRenderWebResultsFiltered(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with only internal results (should be filtered out)
	results := []models.WebResult{
		{URL: "https://perplexity.ai"},
		{URL: ""},
	}

	r.RenderWebResults(results)
	if buf.String() != "" {
		t.Error("Only internal results should be filtered out")
	}
}

func TestRenderWebResultsWithTitle(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	results := []models.WebResult{
		{Title: "Example Article", URL: "https://example.com/article"},
		{Title: "Another Article", URL: "https://example.com/another"},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "Sources:") {
		t.Error("Output should contain 'Sources:' header")
	}
	if !strings.Contains(output, "[1]") {
		t.Error("Output should contain citation number [1]")
	}
	if !strings.Contains(output, "[2]") {
		t.Error("Output should contain citation number [2]")
	}
	if !strings.Contains(output, "Example Article") {
		t.Error("Output should contain first article title")
	}
	if !strings.Contains(output, "https://example.com/article") {
		t.Error("Output should contain first article URL")
	}
	if !strings.Contains(output, "Another Article") {
		t.Error("Output should contain second article title")
	}
}

func TestRenderWebResultsWithName(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with Name field (fallback when Title is empty)
	results := []models.WebResult{
		{Name: "Example Site", URL: "https://example.com"},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "Example Site") {
		t.Error("Output should contain site name")
	}
}

func TestRenderWebResultsURLOnly(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with only URL (when both Title and Name are empty)
	results := []models.WebResult{
		{URL: "https://example.com/page"},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "https://example.com/page") {
		t.Error("Output should contain URL when no title or name")
	}
}

func TestRenderWebResultsMixed(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with mixed result types
	results := []models.WebResult{
		{Title: "Valid Article", URL: "https://example.com/article1"},
		{URL: "https://perplexity.ai"},                   // Should be filtered
		{Name: "Named Site", URL: "https://example.com"},  // Has name
		{URL: "https://example.com/page"},                 // URL only
		{URL: ""},                                         // Empty URL, should be filtered
	}

	r.RenderWebResults(results)

	output := buf.String()
	// Should have 3 sources (not 5, because 2 are filtered)
	sourceCount := strings.Count(output, "[")
	if sourceCount != 3 {
		t.Errorf("Expected 3 sources, got %d", sourceCount)
	}
	if !strings.Contains(output, "Valid Article") {
		t.Error("Output should contain valid article title")
	}
	if !strings.Contains(output, "Named Site") {
		t.Error("Output should contain named site")
	}
	if !strings.Contains(output, "https://example.com/page") {
		t.Error("Output should contain URL-only result")
	}
	if strings.Contains(output, "https://perplexity.ai") {
		t.Error("Output should not contain filtered internal URL")
	}
}

func TestRenderWebResultsURLAsTitle(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test when URL should be displayed (when it differs from title)
	results := []models.WebResult{
		{Title: "Example Site", URL: "https://example.com/different-path"},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "Example Site") {
		t.Error("Output should contain title")
	}
	if !strings.Contains(output, "https://example.com/different-path") {
		t.Error("Output should contain URL when different from title")
	}
}

func TestRenderWebResultsSpecialCharacters(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with special characters in title and URL
	results := []models.WebResult{
		{Title: "Article with <tags> & \"quotes\"", URL: "https://example.com/path?query=value&other=test"},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "Article with") {
		t.Error("Output should contain title with special characters")
	}
	if !strings.Contains(output, "https://example.com") {
		t.Error("Output should contain URL with query parameters")
	}
}

func TestRenderMarkdownNilRenderer(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Force mdRender to nil (simulating error in constructor)
	r.mdRender = nil

	err := r.RenderMarkdown("# Test")
	if err != nil {
		t.Fatalf("RenderMarkdown() error = %v", err)
	}

	output := buf.String()
	if output != "# Test\n" {
		t.Errorf("Output = %q, want %q", output, "# Test\n")
	}
}

func TestRenderMarkdownRenderError(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// This should fallback to raw content on error
	// (Glamour typically doesn't return errors, but the fallback is tested)
	err := r.RenderMarkdown("some text")
	if err != nil {
		t.Fatalf("RenderMarkdown() error = %v", err)
	}

	output := buf.String()
	if output == "" {
		t.Error("Output should not be empty even on error")
	}
}

func TestRenderStyledResponseNilRenderer(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Force mdRender to nil
	r.mdRender = nil

	err := r.RenderStyledResponse("# Test Response")
	if err != nil {
		t.Fatalf("RenderStyledResponse() error = %v", err)
	}

	output := buf.String()
	if output != "# Test Response\n" {
		t.Errorf("Output = %q, want %q", output, "# Test Response\n")
	}
}

func TestRenderStyledResponseWithMarkdown(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	err := r.RenderStyledResponse("# Test Response\n\n**Bold text**")
	if err != nil {
		t.Fatalf("RenderStyledResponse() error = %v", err)
	}

	output := buf.String()
	if !strings.Contains(output, "Test Response") {
		t.Error("Output should contain response content")
	}
}

func TestRenderWebResultsNewsFormat(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with news-style results
	results := []models.WebResult{
		{Title: "Breaking News", URL: "https://news.example.com/article1", Snippet: "Latest update..."},
		{Title: "Another News", URL: "https://news.example.com/article2", Snippet: "More updates..."},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "Breaking News") {
		t.Error("Output should contain news title")
	}
	if !strings.Contains(output, "[1]") {
		t.Error("Output should contain citation number")
	}
}

func TestRenderWebResultsAcademicFormat(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with academic paper style results
	results := []models.WebResult{
		{Title: "Deep Learning Research Paper", URL: "https://arxiv.org/abs/2024.12345"},
		{Title: "AI Ethics Study", URL: "https://scholar.google.com/study"},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "Deep Learning Research Paper") {
		t.Error("Output should contain academic paper title")
	}
	if !strings.Contains(output, "https://arxiv.org/abs/2024.12345") {
		t.Error("Output should contain arxiv URL")
	}
}

func TestRenderWebResultsLongTitle(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with very long title
	longTitle := "This is a very long article title that might need special handling " +
		"because it contains many words and could potentially cause issues with " +
		"terminal rendering or text wrapping"
	results := []models.WebResult{
		{Title: longTitle, URL: "https://example.com/long"},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "This is a very long article title") {
		t.Error("Output should contain long title")
	}
	if !strings.Contains(output, "https://example.com/long") {
		t.Error("Output should contain URL")
	}
}

func TestRenderWebResultsWithMetaData(t *testing.T) {
	var buf bytes.Buffer
	r, _ := NewRendererWithOptions(&buf, 80, false)

	// Test with metadata (should not affect rendering)
	results := []models.WebResult{
		{
			Title:    "Article with Metadata",
			URL:      "https://example.com/article",
			MetaData: map[string]interface{}{"author": "John Doe", "date": "2024-01-01"},
		},
	}

	r.RenderWebResults(results)

	output := buf.String()
	if !strings.Contains(output, "Article with Metadata") {
		t.Error("Output should contain title")
	}
	if !strings.Contains(output, "https://example.com/article") {
		t.Error("Output should contain URL")
	}
}
</file>
<file path="pkg/client/client.go">
// Package client provides the main Perplexity API client.
package client

import (
	"context"
	"fmt"

	http "github.com/bogdanfinn/fhttp"
	"github.com/diogo/perplexity-go/internal/auth"
	"github.com/diogo/perplexity-go/pkg/models"
)

// Client is the main Perplexity API client.
type Client struct {
	http          *HTTPClient
	cookies       []*http.Cookie
	csrfToken     string
	defaultModel  models.Model
	defaultMode   models.Mode
	defaultLang   string
	defaultSrcs   []models.Source
	proQueries    int
	fileUploads   int
	maxProQueries int
	maxFileUploads int
}

// Config holds client configuration options.
type Config struct {
	Cookies      []*http.Cookie
	CookieFile   string
	DefaultModel models.Model
	DefaultMode  models.Mode
	Language     string
	Sources      []models.Source
}

// DefaultConfig returns configuration with sensible defaults.
func DefaultConfig() Config {
	return Config{
		DefaultModel: models.ModelPplxPro,
		DefaultMode:  models.ModeDefault,
		Language:     "en-US",
		Sources:      []models.Source{models.SourceWeb},
	}
}

// New creates a new Perplexity client.
func New(cfg Config) (*Client, error) {
	httpClient, err := NewHTTPClient()
	if err != nil {
		return nil, fmt.Errorf("failed to create HTTP client: %w", err)
	}

	client := &Client{
		http:           httpClient,
		defaultModel:   cfg.DefaultModel,
		defaultMode:    cfg.DefaultMode,
		defaultLang:    cfg.Language,
		defaultSrcs:    cfg.Sources,
		proQueries:     0,
		fileUploads:    0,
		maxProQueries:  5,
		maxFileUploads: 10,
	}

	// Load cookies from file if specified
	if cfg.CookieFile != "" {
		cookies, err := auth.LoadCookiesFromFile(cfg.CookieFile)
		if err != nil {
			return nil, fmt.Errorf("failed to load cookies: %w", err)
		}
		client.SetCookies(cookies)
	} else if cfg.Cookies != nil {
		client.SetCookies(cfg.Cookies)
	}

	return client, nil
}

// NewWithCookieFile creates a client loading cookies from file.
func NewWithCookieFile(cookieFile string) (*Client, error) {
	cfg := DefaultConfig()
	cfg.CookieFile = cookieFile
	return New(cfg)
}

// NewWithCookies creates a client with provided cookies.
func NewWithCookies(cookies []*http.Cookie) (*Client, error) {
	cfg := DefaultConfig()
	cfg.Cookies = cookies
	return New(cfg)
}

// SetCookies sets the client cookies.
func (c *Client) SetCookies(cookies []*http.Cookie) {
	c.cookies = cookies
	c.http.SetCookies(cookiesSliceToMap(cookies))
	c.csrfToken = auth.ExtractCSRFToken(cookies)
}

// GetCookies returns current cookies.
func (c *Client) GetCookies() []*http.Cookie {
	return c.http.GetCookies()
}

// HasValidSession checks if the client has valid authentication.
func (c *Client) HasValidSession() bool {
	return c.csrfToken != ""
}

// ProQueriesRemaining returns remaining pro queries.
func (c *Client) ProQueriesRemaining() int {
	return c.maxProQueries - c.proQueries
}

// FileUploadsRemaining returns remaining file uploads.
func (c *Client) FileUploadsRemaining() int {
	return c.maxFileUploads - c.fileUploads
}

// Search performs a search query.
func (c *Client) Search(ctx context.Context, opts models.SearchOptions) (*models.SearchResponse, error) {
	// Check if streaming is requested
	if opts.Stream {
		return c.searchStream(ctx, opts)
	}
	return c.searchNonStream(ctx, opts)
}

// SearchStream performs a streaming search query.
func (c *Client) SearchStream(ctx context.Context, opts models.SearchOptions) (<-chan models.StreamChunk, error) {
	opts.Stream = true
	return c.searchStreamChannel(ctx, opts)
}

// Close closes the client and releases resources.
func (c *Client) Close() error {
	return c.http.Close()
}

// SetDefaultModel sets the default model.
func (c *Client) SetDefaultModel(model models.Model) {
	c.defaultModel = model
}

// SetDefaultMode sets the default mode.
func (c *Client) SetDefaultMode(mode models.Mode) {
	c.defaultMode = mode
}

// SetDefaultLanguage sets the default language.
func (c *Client) SetDefaultLanguage(lang string) {
	c.defaultLang = lang
}

// SetDefaultSources sets the default sources.
func (c *Client) SetDefaultSources(sources []models.Source) {
	c.defaultSrcs = sources
}

// applyDefaults fills in missing options with defaults.
func (c *Client) applyDefaults(opts *models.SearchOptions) {
	if opts.Mode == "" {
		opts.Mode = c.defaultMode
	}
	if opts.Model == "" {
		opts.Model = c.defaultModel
	}
	if opts.Language == "" {
		opts.Language = c.defaultLang
	}
	if len(opts.Sources) == 0 {
		opts.Sources = c.defaultSrcs
	}
}
</file>
<file path="pkg/client/client_test.go">
package client

import (
	"testing"

	fhttp "github.com/bogdanfinn/fhttp"
	"github.com/diogo/perplexity-go/pkg/models"
)

func TestDefaultConfig(t *testing.T) {
	cfg := DefaultConfig()

	if cfg.DefaultModel != models.ModelPplxPro {
		t.Errorf("DefaultModel = %q, want %q", cfg.DefaultModel, models.ModelPplxPro)
	}
	if cfg.DefaultMode != models.ModeDefault {
		t.Errorf("DefaultMode = %q, want %q", cfg.DefaultMode, models.ModeDefault)
	}
	if cfg.Language != "en-US" {
		t.Errorf("Language = %q, want %q", cfg.Language, "en-US")
	}
	if len(cfg.Sources) != 1 || cfg.Sources[0] != models.SourceWeb {
		t.Errorf("Sources = %v, want [web]", cfg.Sources)
	}
}

func TestNewClient(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	if client.http == nil {
		t.Error("HTTP client should not be nil")
	}
	if client.defaultModel != models.ModelPplxPro {
		t.Errorf("defaultModel = %q, want %q", client.defaultModel, models.ModelPplxPro)
	}
	if client.defaultMode != models.ModeDefault {
		t.Errorf("defaultMode = %q, want %q", client.defaultMode, models.ModeDefault)
	}
}

func TestClientSetCookies(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	cookies := []*fhttp.Cookie{
		{Name: "next-auth.csrf-token", Value: "testtoken|hash"},
		{Name: "session", Value: "session_value"},
	}

	client.SetCookies(cookies)

	if client.csrfToken != "testtoken" {
		t.Errorf("csrfToken = %q, want %q", client.csrfToken, "testtoken")
	}
}

func TestClientHasValidSession(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Without cookies
	if client.HasValidSession() {
		t.Error("HasValidSession() should be false without cookies")
	}

	// With CSRF token
	cookies := []*fhttp.Cookie{
		{Name: "next-auth.csrf-token", Value: "token|hash"},
	}
	client.SetCookies(cookies)

	if !client.HasValidSession() {
		t.Error("HasValidSession() should be true with CSRF token")
	}
}

func TestClientQueryLimits(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Initial limits
	if client.ProQueriesRemaining() != 5 {
		t.Errorf("ProQueriesRemaining() = %d, want 5", client.ProQueriesRemaining())
	}
	if client.FileUploadsRemaining() != 10 {
		t.Errorf("FileUploadsRemaining() = %d, want 10", client.FileUploadsRemaining())
	}
}

func TestClientSetDefaults(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Change defaults
	client.SetDefaultModel(models.ModelGPT51)
	client.SetDefaultMode(models.ModeFast)
	client.SetDefaultLanguage("pt-BR")
	client.SetDefaultSources([]models.Source{models.SourceWeb, models.SourceScholar})

	if client.defaultModel != models.ModelGPT51 {
		t.Errorf("defaultModel = %q, want %q", client.defaultModel, models.ModelGPT51)
	}
	if client.defaultMode != models.ModeFast {
		t.Errorf("defaultMode = %q, want %q", client.defaultMode, models.ModeFast)
	}
	if client.defaultLang != "pt-BR" {
		t.Errorf("defaultLang = %q, want %q", client.defaultLang, "pt-BR")
	}
	if len(client.defaultSrcs) != 2 {
		t.Errorf("len(defaultSrcs) = %d, want 2", len(client.defaultSrcs))
	}
}

func TestClientApplyDefaults(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Empty options should get defaults applied
	opts := models.SearchOptions{
		Query: "test query",
	}

	client.applyDefaults(&opts)

	if opts.Mode != models.ModeDefault {
		t.Errorf("Mode = %q, want %q", opts.Mode, models.ModeDefault)
	}
	if opts.Model != models.ModelPplxPro {
		t.Errorf("Model = %q, want %q", opts.Model, models.ModelPplxPro)
	}
	if opts.Language != "en-US" {
		t.Errorf("Language = %q, want %q", opts.Language, "en-US")
	}
	if len(opts.Sources) != 1 || opts.Sources[0] != models.SourceWeb {
		t.Errorf("Sources = %v, want [web]", opts.Sources)
	}
}

func TestClientApplyDefaultsWithExisting(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Options with existing values should not be overwritten
	opts := models.SearchOptions{
		Query:    "test query",
		Mode:     models.ModeFast,
		Model:    models.ModelGPT51,
		Language: "pt-BR",
		Sources:  []models.Source{models.SourceScholar},
	}

	client.applyDefaults(&opts)

	if opts.Mode != models.ModeFast {
		t.Errorf("Mode = %q, want %q (should not change)", opts.Mode, models.ModeFast)
	}
	if opts.Model != models.ModelGPT51 {
		t.Errorf("Model = %q, want %q (should not change)", opts.Model, models.ModelGPT51)
	}
	if opts.Language != "pt-BR" {
		t.Errorf("Language = %q, want %q (should not change)", opts.Language, "pt-BR")
	}
	if len(opts.Sources) != 1 || opts.Sources[0] != models.SourceScholar {
		t.Errorf("Sources = %v, want [scholar] (should not change)", opts.Sources)
	}
}
</file>
<file path="pkg/client/http.go">
// Package client provides HTTP client functionality with TLS fingerprint spoofing.
package client

import (
	"fmt"
	"io"
	"net/url"

	http "github.com/bogdanfinn/fhttp"
	tls_client "github.com/bogdanfinn/tls-client"
	"github.com/bogdanfinn/tls-client/profiles"
)

const (
	baseURL      = "https://www.perplexity.ai"
	searchPath   = "/rest/sse/perplexity_ask"
	sessionPath  = "/api/auth/session"
	uploadPath   = "/rest/uploads/create_upload_url"
	userAgent    = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36"
)

// HTTPClientInterface defines the contract for HTTP client operations.
// This interface enables dependency injection and mocking for testing.
// The interface is designed to be test-friendly while maintaining backward compatibility.
type HTTPClientInterface interface {
	// Get performs a GET request to the given URL.
	// The URL can be a full URL or a path (will be prefixed with baseURL).
	Get(url string, headers map[string]string) (*http.Response, error)

	// Post performs a POST request with the given body.
	// The URL can be a full URL or a path (will be prefixed with baseURL).
	Post(url string, body io.Reader, headers map[string]string) (*http.Response, error)

	// PostWithReader performs a POST request with a reader and content type.
	// The URL can be a full URL or a path (will be prefixed with baseURL).
	PostWithReader(url string, reader io.Reader, contentType string, headers map[string]string) (*http.Response, error)

	// SetCookies sets cookies for the client using a map of name-value pairs.
	// This signature uses map[string]string to enable easy mocking in tests.
	SetCookies(cookies map[string]string)

	// GetCSRFToken retrieves the CSRF token from cookies.
	GetCSRFToken() string

	// Close closes the HTTP client and releases resources.
	Close() error
}

// HTTPClient wraps tls-client to provide Chrome-impersonating HTTP requests.
type HTTPClient struct {
	client  tls_client.HttpClient
	cookies []*http.Cookie
}

// NewHTTPClient creates a new HTTP client with Chrome TLS fingerprint.
func NewHTTPClient() (*HTTPClient, error) {
	jar := tls_client.NewCookieJar()

	options := []tls_client.HttpClientOption{
		tls_client.WithTimeoutSeconds(60),
		tls_client.WithClientProfile(profiles.Chrome_133),
		tls_client.WithCookieJar(jar),
		tls_client.WithRandomTLSExtensionOrder(),
	}

	client, err := tls_client.NewHttpClient(tls_client.NewNoopLogger(), options...)
	if err != nil {
		return nil, fmt.Errorf("failed to create TLS client: %w", err)
	}

	return &HTTPClient{
		client:  client,
		cookies: make([]*http.Cookie, 0),
	}, nil
}

// cookiesMapToSlice converts a map of cookies to a slice of http.Cookie.
func cookiesMapToSlice(cookies map[string]string) []*http.Cookie {
	cookieSlice := make([]*http.Cookie, 0, len(cookies))
	for name, value := range cookies {
		cookieSlice = append(cookieSlice, &http.Cookie{
			Name:  name,
			Value: value,
		})
	}
	return cookieSlice
}

// cookiesSliceToMap converts a slice of http.Cookie to a map.
func cookiesSliceToMap(cookies []*http.Cookie) map[string]string {
	cookieMap := make(map[string]string, len(cookies))
	for _, cookie := range cookies {
		cookieMap[cookie.Name] = cookie.Value
	}
	return cookieMap
}

// buildHeaders returns common headers for Perplexity API requests.
// It merges custom headers with default headers.
func (c *HTTPClient) buildHeaders(customHeaders map[string]string) http.Header {
	headers := http.Header{
		"Accept":             {"*/*"},
		"Accept-Encoding":    {"gzip, deflate, br, zstd"},
		"Accept-Language":    {"en-US,en;q=0.9"},
		"Content-Type":       {"application/json"},
		"Origin":             {baseURL},
		"Referer":            {baseURL + "/"},
		"User-Agent":         {userAgent},
		"sec-ch-ua":          {`"Chromium";v="133", "Not(A:Brand";v="99", "Google Chrome";v="133"`},
		"sec-ch-ua-mobile":   {"?0"},
		"sec-ch-ua-platform": {`"Linux"`},
		"sec-fetch-dest":     {"empty"},
		"sec-fetch-mode":     {"cors"},
		"sec-fetch-site":     {"same-origin"},
		"priority":           {"u=1, i"},
	}

	// Merge custom headers
	for key, value := range customHeaders {
		headers.Set(key, value)
	}

	return headers
}

// normalizeURL converts a path to a full URL if needed.
func (c *HTTPClient) normalizeURL(urlStr string) string {
	// If it's already a full URL (starts with http:// or https://), return as-is
	if len(urlStr) > 7 && (urlStr[:7] == "http://" || urlStr[:8] == "https://") {
		return urlStr
	}
	// Otherwise, prepend baseURL
	return baseURL + urlStr
}

// Get performs a GET request.
// Implements HTTPClientInterface.
func (c *HTTPClient) Get(urlStr string, headers map[string]string) (*http.Response, error) {
	fullURL := c.normalizeURL(urlStr)
	req, err := http.NewRequest("GET", fullURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header = c.buildHeaders(headers)
	return c.client.Do(req)
}

// Post performs a POST request with body.
// Implements HTTPClientInterface.
func (c *HTTPClient) Post(urlStr string, body io.Reader, headers map[string]string) (*http.Response, error) {
	fullURL := c.normalizeURL(urlStr)
	req, err := http.NewRequest("POST", fullURL, body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header = c.buildHeaders(headers)
	return c.client.Do(req)
}

// PostWithReader performs a POST request with a reader and content type.
// Implements HTTPClientInterface.
func (c *HTTPClient) PostWithReader(urlStr string, reader io.Reader, contentType string, headers map[string]string) (*http.Response, error) {
	// Create a new reader that wraps the provided reader with proper content type
	headersWithCT := make(map[string]string)
	for k, v := range headers {
		headersWithCT[k] = v
	}
	headersWithCT["Content-Type"] = contentType

	return c.Post(urlStr, reader, headersWithCT)
}

// SetCookies sets cookies for the client.
// Implements HTTPClientInterface.
func (c *HTTPClient) SetCookies(cookies map[string]string) {
	c.cookies = cookiesMapToSlice(cookies)
	u, _ := url.Parse(baseURL)
	c.client.SetCookies(u, c.cookies)
}

// GetCSRFToken extracts CSRF token from cookies.
// Implements HTTPClientInterface.
func (c *HTTPClient) GetCSRFToken() string {
	for _, cookie := range c.GetCookies() {
		if cookie.Name == "next-auth.csrf-token" {
			// Token format: "value|hash"
			value := cookie.Value
			for i, ch := range value {
				if ch == '|' {
					return value[:i]
				}
			}
			return value
		}
	}
	return ""
}

// Close closes the HTTP client.
// Implements HTTPClientInterface.
func (c *HTTPClient) Close() error {
	// tls-client doesn't have explicit close
	return nil
}

// SetCookiesLegacy sets cookies for the client using []*http.Cookie.
// This is kept for backward compatibility with existing code.
func (c *HTTPClient) SetCookiesLegacy(cookies []*http.Cookie) {
	c.cookies = cookies
	u, _ := url.Parse(baseURL)
	c.client.SetCookies(u, cookies)
}

// AddCookie adds a single cookie.
func (c *HTTPClient) AddCookie(cookie *http.Cookie) {
	c.cookies = append(c.cookies, cookie)
	u, _ := url.Parse(baseURL)
	c.client.SetCookies(u, c.cookies)
}

// GetCookies returns current cookies.
func (c *HTTPClient) GetCookies() []*http.Cookie {
	u, _ := url.Parse(baseURL)
	return c.client.GetCookies(u)
}

// MockHTTPClient is a mock implementation of HTTPClientInterface for testing.
// It allows tests to simulate HTTP responses without making real network calls.
type MockHTTPClient struct {
	// Responses to return (indexed by call number)
	Responses []*http.Response
	Errors    []error

	// Cookies state
	Cookies map[string]string

	// Configuration
	defaultResponse *http.Response
	defaultError    error

	// Request tracking
	LastRequestURL   string
	LastRequestBody  []byte
	RequestCount     int
}

// NewMockHTTPClient creates a new MockHTTPClient with default settings.
func NewMockHTTPClient() *MockHTTPClient {
	return &MockHTTPClient{
		Cookies:         make(map[string]string),
		defaultResponse: nil,
		defaultError:    nil,
	}
}

// SetResponse sets the default response for all future calls.
func (m *MockHTTPClient) SetResponse(resp *http.Response) {
	m.defaultResponse = resp
}

// SetError sets the default error for all future calls.
func (m *MockHTTPClient) SetError(err error) {
	m.defaultError = err
}

// Get simulates a GET request for testing.
// Implements HTTPClientInterface.
func (m *MockHTTPClient) Get(url string, headers map[string]string) (*http.Response, error) {
	m.RequestCount++
	m.LastRequestURL = url
	return m.defaultResponse, m.defaultError
}

// Post simulates a POST request for testing.
// Implements HTTPClientInterface.
func (m *MockHTTPClient) Post(url string, body io.Reader, headers map[string]string) (*http.Response, error) {
	m.RequestCount++
	m.LastRequestURL = url
	if body != nil {
		m.LastRequestBody, _ = io.ReadAll(body)
	}
	return m.defaultResponse, m.defaultError
}

// PostWithReader simulates a POST request with reader for testing.
// Implements HTTPClientInterface.
func (m *MockHTTPClient) PostWithReader(url string, reader io.Reader, contentType string, headers map[string]string) (*http.Response, error) {
	return m.Post(url, reader, headers)
}

// SetCookies sets cookies on the mock client for testing.
// Implements HTTPClientInterface.
func (m *MockHTTPClient) SetCookies(cookies map[string]string) {
	m.Cookies = cookies
}

// GetCSRFToken returns CSRF token from cookies for testing.
// Implements HTTPClientInterface.
func (m *MockHTTPClient) GetCSRFToken() string {
	if m.Cookies == nil {
		return ""
	}
	cookieName := "next-auth.csrf-token"
	token, ok := m.Cookies[cookieName]
	if !ok {
		return ""
	}
	return token
}

// Close closes the mock client for testing.
// Implements HTTPClientInterface.
func (m *MockHTTPClient) Close() error {
	return nil
}

// Ensure HTTPClient implements the interface
var _ HTTPClientInterface = &HTTPClient{}

// Ensure MockHTTPClient implements the interface
var _ HTTPClientInterface = &MockHTTPClient{}
</file>
<file path="pkg/client/http_test.go.bak">
package client

import (
	"bytes"
	"fmt"
	"testing"

	http "github.com/bogdanfinn/fhttp"
)

func TestNewHTTPClient(t *testing.T) {
	client, err := NewHTTPClient()
	if err != nil {
		t.Fatalf("NewHTTPClient() error = %v", err)
	}

	if client == nil {
		t.Fatal("NewHTTPClient() returned nil")
	}

	if client.client == nil {
		t.Error("client.client should not be nil")
	}

	if client.cookies == nil {
		t.Error("client.cookies should be initialized")
	}
}

func TestHTTPClientSetCookies(t *testing.T) {
	client, err := NewHTTPClient()
	if err != nil {
		t.Fatalf("NewHTTPClient() error = %v", err)
	}

	cookies := []*http.Cookie{
		{Name: "test", Value: "value", Domain: ".perplexity.ai"},
	}

	client.SetCookies(cookies)

	if len(client.cookies) != 1 {
		t.Errorf("len(cookies) = %d, want 1", len(client.cookies))
	}
}

func TestHTTPClientAddCookie(t *testing.T) {
	client, err := NewHTTPClient()
	if err != nil {
		t.Fatalf("NewHTTPClient() error = %v", err)
	}

	client.AddCookie(&http.Cookie{Name: "cookie1", Value: "value1", Domain: ".perplexity.ai"})
	client.AddCookie(&http.Cookie{Name: "cookie2", Value: "value2", Domain: ".perplexity.ai"})

	if len(client.cookies) != 2 {
		t.Errorf("len(cookies) = %d, want 2", len(client.cookies))
	}
}

func TestHTTPClientBuildHeaders(t *testing.T) {
	client, err := NewHTTPClient()
	if err != nil {
		t.Fatalf("NewHTTPClient() error = %v", err)
	}

	headers := client.buildHeaders()

	// Check required headers (using direct access since Get() canonicalizes)
	if v := headers["Accept"]; len(v) == 0 || v[0] != "*/*" {
		t.Errorf("Header Accept = %v, want [*/*]", v)
	}
	if v := headers["Accept-Language"]; len(v) == 0 || v[0] != "en-US,en;q=0.9" {
		t.Errorf("Header Accept-Language = %v, want [en-US,en;q=0.9]", v)
	}
	if v := headers["Content-Type"]; len(v) == 0 || v[0] != "application/json" {
		t.Errorf("Header Content-Type = %v, want [application/json]", v)
	}
	if v := headers["Origin"]; len(v) == 0 || v[0] != baseURL {
		t.Errorf("Header Origin = %v, want [%s]", v, baseURL)
	}
	if v := headers["User-Agent"]; len(v) == 0 || v[0] != userAgent {
		t.Errorf("Header User-Agent = %v, want [%s]", v, userAgent)
	}
	// Check sec-* headers
	if v := headers["sec-ch-ua-mobile"]; len(v) == 0 || v[0] != "?0" {
		t.Errorf("Header sec-ch-ua-mobile = %v, want [?0]", v)
	}
	if v := headers["sec-fetch-dest"]; len(v) == 0 || v[0] != "empty" {
		t.Errorf("Header sec-fetch-dest = %v, want [empty]", v)
	}
}

func TestHTTPClientGetCSRFToken(t *testing.T) {
	client, err := NewHTTPClient()
	if err != nil {
		t.Fatalf("NewHTTPClient() error = %v", err)
	}

	// No cookies, no token
	token := client.GetCSRFToken()
	if token != "" {
		t.Errorf("GetCSRFToken() = %q, want empty", token)
	}

	// Add CSRF cookie with hash
	client.SetCookies([]*http.Cookie{
		{Name: "next-auth.csrf-token", Value: "mytoken|somehash", Domain: ".perplexity.ai", Path: "/"},
	})

	token = client.GetCSRFToken()
	if token != "mytoken" {
		t.Errorf("GetCSRFToken() = %q, want %q", token, "mytoken")
	}
}

func TestHTTPClientGetCSRFTokenNoHash(t *testing.T) {
	client, err := NewHTTPClient()
	if err != nil {
		t.Fatalf("NewHTTPClient() error = %v", err)
	}

	// Add CSRF cookie without hash
	client.SetCookies([]*http.Cookie{
		{Name: "next-auth.csrf-token", Value: "justtoken", Domain: ".perplexity.ai", Path: "/"},
	})

	token := client.GetCSRFToken()
	if token != "justtoken" {
		t.Errorf("GetCSRFToken() = %q, want %q", token, "justtoken")
	}
}

func TestHTTPClientClose(t *testing.T) {
	client, err := NewHTTPClient()
	if err != nil {
		t.Fatalf("NewHTTPClient() error = %v", err)
	}

	// Close should not error
	if err := client.Close(); err != nil {
		t.Errorf("Close() error = %v", err)
	}
}

func TestConstants(t *testing.T) {
	if baseURL != "https://www.perplexity.ai" {
		t.Errorf("baseURL = %q, want %q", baseURL, "https://www.perplexity.ai")
	}
	if searchPath != "/rest/sse/perplexity_ask" {
		t.Errorf("searchPath = %q, want %q", searchPath, "/rest/sse/perplexity_ask")
	}
	if sessionPath != "/api/auth/session" {
		t.Errorf("sessionPath = %q, want %q", sessionPath, "/api/auth/session")
	}
	if uploadPath != "/rest/uploads/create_upload_url" {
		t.Errorf("uploadPath = %q, want %q", uploadPath, "/rest/uploads/create_upload_url")
	}
	if userAgent == "" {
		t.Error("userAgent should not be empty")
	}
}

// MockHTTPClient Tests

func TestNewMockHTTPClient(t *testing.T) {
	mock := NewMockHTTPClient()
	if mock == nil {
		t.Fatal("NewMockHTTPClient() returned nil")
	}
	if len(mock.Calls) != 0 {
		t.Error("Calls should be empty initially")
	}
	if mock.Cookies == nil {
		t.Error("Cookies should be initialized")
	}
}

func TestMockHTTPClientPost(t *testing.T) {
	mock := NewMockHTTPClient()

	// Configure mock to return a specific response
	resp := &http.Response{
		StatusCode: 200,
		Body:       http.NoBody,
	}
	mock.AddResponse(resp)

	result, err := mock.Post("/test", []byte("test body"))

	if err != nil {
		t.Errorf("Post() error = %v", err)
	}
	if result != resp {
		t.Errorf("Post() = %v, want %v", result, resp)
	}

	// Verify call was recorded
	if len(mock.Calls) != 1 {
		t.Fatalf("len(mock.Calls) = %d, want 1", len(mock.Calls))
	}
	if mock.Calls[0].Method != "Post" {
		t.Errorf("Call method = %v, want %v", mock.Calls[0].Method, "Post")
	}
	if mock.Calls[0].Path != "/test" {
		t.Errorf("Call path = %v, want %v", mock.Calls[0].Path, "/test")
	}
	if !bytes.Equal(mock.Calls[0].Body, []byte("test body")) {
		t.Errorf("Call body = %v, want %v", mock.Calls[0].Body, []byte("test body"))
	}
}

func TestMockHTTPClientPostWithError(t *testing.T) {
	mock := NewMockHTTPClient()

	testErr := fmt.Errorf("test error")
	mock.AddError(testErr)

	result, err := mock.Post("/test", nil)

	if err != testErr {
		t.Errorf("Post() error = %v, want %v", err, testErr)
	}
	if result != nil {
		t.Errorf("Post() = %v, want nil", result)
	}
}

func TestMockHTTPClientGet(t *testing.T) {
	mock := NewMockHTTPClient()

	resp := &http.Response{
		StatusCode: 404,
		Body:       http.NoBody,
	}
	mock.AddResponse(resp)

	result, err := mock.Get("/another/path")

	if err != nil {
		t.Errorf("Get() error = %v", err)
	}
	if result != resp {
		t.Errorf("Get() = %v, want %v", result, resp)
	}

	// Verify call was recorded
	if len(mock.Calls) != 1 {
		t.Fatalf("len(mock.Calls) = %d, want 1", len(mock.Calls))
	}
	if mock.Calls[0].Method != "Get" {
		t.Errorf("Call method = %v, want %v", mock.Calls[0].Method, "Get")
	}
	if mock.Calls[0].Path != "/another/path" {
		t.Errorf("Call path = %v, want %v", mock.Calls[0].Path, "/another/path")
	}
}

func TestMockHTTPClientPostWithReader(t *testing.T) {
	mock := NewMockHTTPClient()

	resp := &http.Response{
		StatusCode: 200,
		Body:       http.NoBody,
	}
	mock.AddResponse(resp)

	result, err := mock.PostWithReader("/test/reader", []byte("reader body"))

	if err != nil {
		t.Errorf("PostWithReader() error = %v", err)
	}
	if result != resp {
		t.Errorf("PostWithReader() = %v, want %v", result, resp)
	}

	// Verify call was recorded
	if len(mock.Calls) != 1 {
		t.Fatalf("len(mock.Calls) = %d, want 1", len(mock.Calls))
	}
	if mock.Calls[0].Method != "PostWithReader" {
		t.Errorf("Call method = %v, want %v", mock.Calls[0].Method, "PostWithReader")
	}
}

func TestMockHTTPClientMultipleResponses(t *testing.T) {
	mock := NewMockHTTPClient()

	resp1 := &http.Response{StatusCode: 200, Body: http.NoBody}
	resp2 := &http.Response{StatusCode: 201, Body: http.NoBody}

	mock.AddResponse(resp1)
	mock.AddResponse(resp2)

	result1, err1 := mock.Get("/first")
	result2, err2 := mock.Get("/second")

	if err1 != nil || err2 != nil {
		t.Errorf("Multiple calls returned errors: %v, %v", err1, err2)
	}
	if result1 != resp1 {
		t.Errorf("First call result = %v, want %v", result1, resp1)
	}
	if result2 != resp2 {
		t.Errorf("Second call result = %v, want %v", result2, resp2)
	}
}

func TestMockHTTPClientDefaultResponse(t *testing.T) {
	mock := NewMockHTTPClient()

	defaultResp := &http.Response{StatusCode: 500, Body: http.NoBody}
	mock.SetResponse(defaultResp)

	// First call - no specific response configured
	result1, err1 := mock.Get("/first")
	if result1 != defaultResp {
		t.Errorf("First call result = %v, want default response", result1)
	}

	// Second call - still uses default
	result2, err2 := mock.Post("/second", nil)
	if result2 != defaultResp {
		t.Errorf("Second call result = %v, want default response", result2)
	}
}

func TestMockHTTPClientSetCookies(t *testing.T) {
	mock := NewMockHTTPClient()

	cookies := []*http.Cookie{
		{Name: "test1", Value: "value1"},
		{Name: "test2", Value: "value2"},
	}

	mock.SetCookies(cookies)

	result := mock.GetCookies()
	if len(result) != 2 {
		t.Errorf("len(GetCookies()) = %d, want 2", len(result))
	}
}

func TestMockHTTPClientAddCookie(t *testing.T) {
	mock := NewMockHTTPClient()

	mock.AddCookie(&http.Cookie{Name: "cookie1", Value: "value1"})
	mock.AddCookie(&http.Cookie{Name: "cookie2", Value: "value2"})

	result := mock.GetCookies()
	if len(result) != 2 {
		t.Errorf("len(GetCookies()) = %d, want 2", len(result))
	}
	if result[0].Name != "cookie1" || result[1].Name != "cookie2" {
		t.Errorf("Cookie names don't match")
	}
}

func TestMockHTTPClientGetCSRFToken(t *testing.T) {
	mock := NewMockHTTPClient()

	// No cookies initially
	token := mock.GetCSRFToken()
	if token != "" {
		t.Errorf("GetCSRFToken() = %q, want empty", token)
	}

	// Add CSRF cookie with hash
	mock.SetCookies([]*http.Cookie{
		{Name: "next-auth.csrf-token", Value: "token123|hash456"},
	})

	token = mock.GetCSRFToken()
	if token != "token123" {
		t.Errorf("GetCSRFToken() = %q, want %q", token, "token123")
	}
}

func TestMockHTTPClientCallTracking(t *testing.T) {
	mock := NewMockHTTPClient()

	// Make multiple calls
	mock.Get("/first")
	mock.Post("/second", []byte("body"))
	mock.PostWithReader("/third", nil)

	// Check call count for each method
	if count := mock.GetCallCount("Get"); count != 1 {
		t.Errorf("GetCallCount('Get') = %d, want 1", count)
	}
	if count := mock.GetCallCount("Post"); count != 1 {
		t.Errorf("GetCallCount('Post') = %d, want 1", count)
	}
	if count := mock.GetCallCount("PostWithReader"); count != 1 {
		t.Errorf("GetCallCount('PostWithReader') = %d, want 1", count)
	}
	if count := mock.GetCallCount("NonExistent"); count != 0 {
		t.Errorf("GetCallCount('NonExistent') = %d, want 0", count)
	}

	// Check WasMethodCalled
	if !mock.WasMethodCalled("Get") {
		t.Error("WasMethodCalled('Get') should be true")
	}
	if !mock.WasMethodCalled("Post") {
		t.Error("WasMethodCalled('Post') should be true")
	}
	if mock.WasMethodCalled("NonExistent") {
		t.Error("WasMethodCalled('NonExistent') should be false")
	}

	// Check last call
	lastCall := mock.GetLastCall()
	if lastCall == nil {
		t.Fatal("GetLastCall() returned nil")
	}
	if lastCall.Method != "PostWithReader" {
		t.Errorf("Last call method = %v, want %v", lastCall.Method, "PostWithReader")
	}
	if lastCall.Path != "/third" {
		t.Errorf("Last call path = %v, want %v", lastCall.Path, "/third")
	}

	// Clear calls
	mock.ClearCalls()
	if len(mock.Calls) != 0 {
		t.Error("Calls should be empty after ClearCalls()")
	}
	if mock.GetLastCall() != nil {
		t.Error("GetLastCall() should return nil after ClearCalls()")
	}
}
</file>
<file path="pkg/client/search.go">
package client

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/diogo/perplexity-go/pkg/models"
	"github.com/google/uuid"
)

// buildSearchPayload creates the JSON payload for a search request.
func (c *Client) buildSearchPayload(opts models.SearchOptions) ([]byte, error) {
	c.applyDefaults(&opts)

	// Determine effective mode based on model
	effectiveMode := string(opts.Mode)
	modelPref := string(opts.Model)
	isProReasoning := false

	// Map mode to API values (unless overridden by special model)
	switch opts.Mode {
	case models.ModeFast:
		effectiveMode = "concise"
		modelPref = "turbo"
	case models.ModePro, models.ModeDefault:
		effectiveMode = "copilot"
	case models.ModeReasoning:
		effectiveMode = "copilot"
		isProReasoning = true
	case models.ModeDeepResearch:
		effectiveMode = "copilot"
		modelPref = "pplx_alpha"
	}

	// Handle special thinking models (forces fast mode regardless of mode setting)
	if opts.Model == models.ModelGPT51Thinking {
		effectiveMode = "concise"
		modelPref = "turbo"
	}

	// Convert sources to strings
	sources := make([]string, len(opts.Sources))
	for i, s := range opts.Sources {
		sources[i] = string(s)
	}

	// Generate UUIDs
	frontendUUID := uuid.New().String()

	// Build request payload
	req := models.SearchRequest{
		Params: models.SearchParams{
			Version:            "2.18",
			Source:             "default",
			Language:           opts.Language,
			Timezone:           "America/New_York",
			SearchFocus:        "internet",
			FrontendUUID:       frontendUUID,
			Mode:               effectiveMode,
			IsIncognito:        opts.Incognito,
			Sources:            sources,
			IsProReasoningMode: isProReasoning,
		},
		QueryStr: opts.Query,
	}

	// Only set model preference if not using turbo
	if modelPref != "" && modelPref != "turbo" {
		req.Params.ModelPreference = &modelPref
	} else if modelPref == "turbo" {
		// For fast mode, explicitly set turbo
		req.Params.ModelPreference = &modelPref
	}

	// Handle follow-up context
	if opts.FollowUp != nil {
		req.Params.BackendUUID = opts.FollowUp.BackendUUID
		req.Params.Attachments = opts.FollowUp.Attachments
	}

	return json.Marshal(req)
}

// searchNonStream performs a non-streaming search.
func (c *Client) searchNonStream(ctx context.Context, opts models.SearchOptions) (*models.SearchResponse, error) {
	chunks := make([]models.StreamChunk, 0)

	ch, err := c.searchStreamChannel(ctx, opts)
	if err != nil {
		return nil, err
	}

	// Collect all chunks
	for chunk := range ch {
		if chunk.Error != nil {
			return nil, chunk.Error
		}
		chunks = append(chunks, chunk)
	}

	// Build response from chunks
	response := &models.SearchResponse{}
	var fullText strings.Builder

	for _, chunk := range chunks {
		if chunk.Text != "" {
			fullText.WriteString(chunk.Text)
		}
		if chunk.Delta != "" {
			fullText.WriteString(chunk.Delta)
		}
		if chunk.BackendUUID != "" {
			response.BackendUUID = chunk.BackendUUID
		}
		if len(chunk.Blocks) > 0 {
			response.Blocks = chunk.Blocks
		}
		// Collect web results from new format
		if len(chunk.WebResults) > 0 {
			response.WebResults = append(response.WebResults, chunk.WebResults...)
		}
	}

	response.Text = fullText.String()
	return response, nil
}

// searchStream performs a streaming search and returns the response.
func (c *Client) searchStream(ctx context.Context, opts models.SearchOptions) (*models.SearchResponse, error) {
	return c.searchNonStream(ctx, opts)
}

// searchStreamChannel performs a streaming search and returns a channel.
func (c *Client) searchStreamChannel(ctx context.Context, opts models.SearchOptions) (<-chan models.StreamChunk, error) {
	payload, err := c.buildSearchPayload(opts)
	if err != nil {
		return nil, fmt.Errorf("failed to build payload: %w", err)
	}

	ch := make(chan models.StreamChunk, 100)

	go func() {
		defer close(ch)

		resp, err := c.http.Post(searchPath, bytes.NewReader(payload), nil)
		if err != nil {
			ch <- models.StreamChunk{Error: fmt.Errorf("request failed: %w", err)}
			return
		}
		defer resp.Body.Close()

		if resp.StatusCode != 200 {
			body, _ := io.ReadAll(resp.Body)
			ch <- models.StreamChunk{Error: fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))}
			return
		}

		// Parse SSE stream
		c.parseSSEStream(ctx, resp.Body, ch)
	}()

	return ch, nil
}

// parseSSEStream parses Server-Sent Events from the response body.
func (c *Client) parseSSEStream(ctx context.Context, body io.Reader, ch chan<- models.StreamChunk) {
	scanner := bufio.NewScanner(body)
	// Use larger buffer for SSE chunks
	buf := make([]byte, 0, 64*1024)
	scanner.Buffer(buf, 1024*1024)

	// Custom split function for SSE (double CRLF delimiter)
	scanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		if atEOF && len(data) == 0 {
			return 0, nil, nil
		}

		// Look for \r\n\r\n delimiter
		if i := bytes.Index(data, []byte("\r\n\r\n")); i >= 0 {
			return i + 4, data[0:i], nil
		}

		// Also handle \n\n for compatibility
		if i := bytes.Index(data, []byte("\n\n")); i >= 0 {
			return i + 2, data[0:i], nil
		}

		if atEOF {
			return len(data), data, nil
		}

		return 0, nil, nil
	})

	for scanner.Scan() {
		select {
		case <-ctx.Done():
			ch <- models.StreamChunk{Error: ctx.Err()}
			return
		default:
		}

		chunk := scanner.Text()
		if chunk == "" {
			continue
		}

		// Parse SSE format: "event: message\r\ndata: {...}"
		parsed := c.parseSSEChunk(chunk)
		if parsed.Error != nil || parsed.Text != "" || parsed.Delta != "" || parsed.Done {
			ch <- parsed
		}
	}

	if err := scanner.Err(); err != nil {
		ch <- models.StreamChunk{Error: fmt.Errorf("stream read error: %w", err)}
	}
}

// parseSSEChunk parses a single SSE chunk.
func (c *Client) parseSSEChunk(chunk string) models.StreamChunk {
	// Strip SSE prefix
	data := chunk
	if strings.HasPrefix(chunk, "event: message") {
		// Find data: prefix
		lines := strings.Split(chunk, "\n")
		for _, line := range lines {
			line = strings.TrimPrefix(line, "\r")
			if strings.HasPrefix(line, "data: ") {
				data = strings.TrimPrefix(line, "data: ")
				break
			}
		}
	} else if strings.HasPrefix(chunk, "data: ") {
		data = strings.TrimPrefix(chunk, "data: ")
	}

	// Handle end of stream
	if data == "" || data == "{}" {
		return models.StreamChunk{Done: true}
	}

	// Check for end_of_stream event
	if strings.HasPrefix(data, "event: end_of_stream") {
		return models.StreamChunk{Done: true}
	}

	// Check for [DONE] marker
	if strings.Contains(data, "[DONE]") {
		return models.StreamChunk{Done: true}
	}

	// Try to parse as new step-based format (array of steps - direct)
	trimmedData := strings.TrimSpace(data)
	if strings.HasPrefix(trimmedData, "[{") && strings.Contains(trimmedData, "step_type") {
		return c.parseStepBasedResponse(trimmedData)
	}

	// Parse as outer JSON object
	var outer map[string]interface{}
	if err := json.Unmarshal([]byte(data), &outer); err != nil {
		// Not JSON, might be plain text
		return models.StreamChunk{Text: data}
	}

	result := models.StreamChunk{}

	// Extract backend_uuid
	if uuid, ok := outer["backend_uuid"].(string); ok {
		result.BackendUUID = uuid
	}

	// Parse inner text field (new format: text contains step array as string)
	if textField, ok := outer["text"].(string); ok {
		textTrimmed := strings.TrimSpace(textField)
		// Check if text contains step-based format
		if strings.HasPrefix(textTrimmed, "[{") && strings.Contains(textTrimmed, "step_type") {
			// Parse the step array from the text field
			stepResult := c.parseStepBasedResponse(textTrimmed)
			if stepResult.StepType == "FINAL" && stepResult.Text != "" {
				result.Text = stepResult.Text
				result.StepType = stepResult.StepType
				result.WebResults = stepResult.WebResults
				result.Chunks = stepResult.Chunks
				result.Done = true
				return result
			}
			// For non-FINAL steps, just note the step type
			result.StepType = stepResult.StepType
			return result
		}

		// Try legacy format: inner JSON with blocks
		var inner map[string]interface{}
		if err := json.Unmarshal([]byte(textField), &inner); err == nil {
			// Successfully parsed inner JSON
			if blocks, ok := inner["blocks"].([]interface{}); ok {
				result.Blocks = c.parseBlocks(blocks)
			}
		} else {
			// Inner text is not JSON, use as-is
			result.Text = textField
		}
	}

	// Check for delta/content updates
	if delta, ok := outer["delta"].(string); ok {
		result.Delta = delta
	}

	// Check for completion
	if finished, ok := outer["finished"].(bool); ok && finished {
		result.Done = true
	}
	if finishReason, ok := outer["finish_reason"].(string); ok && finishReason != "" {
		result.Done = true
	}

	return result
}

// parseStepBasedResponse parses the new step-based response format.
func (c *Client) parseStepBasedResponse(data string) models.StreamChunk {
	// Handle case where data might contain trailing SSE markers
	// The data might look like: [...JSON...]event: end_of_stream\ndata: {}
	if idx := strings.Index(data, "]event:"); idx > 0 {
		data = data[:idx+1]
	}
	if idx := strings.Index(data, "]\nevent:"); idx > 0 {
		data = data[:idx+1]
	}
	if idx := strings.Index(data, "]\r\nevent:"); idx > 0 {
		data = data[:idx+1]
	}
	data = strings.TrimSpace(data)

	var steps []models.SSEStep
	if err := json.Unmarshal([]byte(data), &steps); err != nil {
		// Try to extract just the array part
		startIdx := strings.Index(data, "[")
		endIdx := strings.LastIndex(data, "]")
		if startIdx >= 0 && endIdx > startIdx {
			data = data[startIdx : endIdx+1]
			if err := json.Unmarshal([]byte(data), &steps); err != nil {
				return models.StreamChunk{Text: data}
			}
		} else {
			return models.StreamChunk{Text: data}
		}
	}

	result := models.StreamChunk{}

	// Process each step
	for _, step := range steps {
		switch step.StepType {
		case "FINAL":
			// Parse final content
			contentMap, ok := step.Content.(map[string]interface{})
			if !ok {
				continue
			}

			answerJSON, ok := contentMap["answer"].(string)
			if !ok {
				continue
			}

			// Parse the nested answer JSON
			var finalAnswer models.FinalAnswer
			if err := json.Unmarshal([]byte(answerJSON), &finalAnswer); err != nil {
				// If parsing fails, try to use the raw answer
				result.Text = answerJSON
				continue
			}

			// Extract the answer text
			result.Text = finalAnswer.Answer
			result.StepType = "FINAL"
			result.Chunks = finalAnswer.Chunks
			result.WebResults = finalAnswer.WebResults

			// Also add extra web results
			if len(finalAnswer.ExtraWebResults) > 0 {
				result.WebResults = append(result.WebResults, finalAnswer.ExtraWebResults...)
			}

		case "SEARCH_RESULTS":
			// Parse search results
			contentMap, ok := step.Content.(map[string]interface{})
			if !ok {
				continue
			}

			webResultsRaw, ok := contentMap["web_results"].([]interface{})
			if !ok {
				continue
			}

			for _, wrRaw := range webResultsRaw {
				wrMap, ok := wrRaw.(map[string]interface{})
				if !ok {
					continue
				}

				wr := models.WebResult{}
				if name, ok := wrMap["name"].(string); ok {
					wr.Name = name
				}
				if url, ok := wrMap["url"].(string); ok {
					wr.URL = url
				}
				if snippet, ok := wrMap["snippet"].(string); ok {
					wr.Snippet = snippet
				}
				if title, ok := wrMap["title"].(string); ok {
					wr.Title = title
				}
				result.WebResults = append(result.WebResults, wr)
			}
			result.StepType = "SEARCH_RESULTS"

		case "INITIAL_QUERY":
			result.StepType = "INITIAL_QUERY"
			// Ignore initial query content

		case "SEARCH_WEB":
			result.StepType = "SEARCH_WEB"
			// Ignore search web step
		}

		// Extract UUID
		if step.UUID != "" {
			result.BackendUUID = step.UUID
		}
	}

	return result
}

// parseBlocks parses response blocks from JSON.
func (c *Client) parseBlocks(blocks []interface{}) []models.ResponseBlock {
	result := make([]models.ResponseBlock, 0, len(blocks))

	for _, b := range blocks {
		block, ok := b.(map[string]interface{})
		if !ok {
			continue
		}

		rb := models.ResponseBlock{}

		// Parse markdown_block
		if mb, ok := block["markdown_block"].(map[string]interface{}); ok {
			rb.MarkdownBlock = &models.MarkdownBlock{}
			if answer, ok := mb["answer"].(string); ok {
				rb.MarkdownBlock.Answer = answer
			}
			// Parse citations
			if cites, ok := mb["citations"].([]interface{}); ok {
				rb.MarkdownBlock.Citations = make([]models.Citation, 0, len(cites))
				for _, cite := range cites {
					if cm, ok := cite.(map[string]interface{}); ok {
						c := models.Citation{}
						if url, ok := cm["url"].(string); ok {
							c.URL = url
						}
						if title, ok := cm["title"].(string); ok {
							c.Title = title
						}
						if snippet, ok := cm["snippet"].(string); ok {
							c.Snippet = snippet
						}
						rb.MarkdownBlock.Citations = append(rb.MarkdownBlock.Citations, c)
					}
				}
			}
		}

		// Parse web_search_results
		if wsr, ok := block["web_search_results"].(map[string]interface{}); ok {
			rb.WebSearchResults = &models.WebSearchResults{}
			if results, ok := wsr["results"].([]interface{}); ok {
				rb.WebSearchResults.Results = make([]models.WebSearchResult, 0, len(results))
				for _, r := range results {
					if rm, ok := r.(map[string]interface{}); ok {
						wr := models.WebSearchResult{}
						if url, ok := rm["url"].(string); ok {
							wr.URL = url
						}
						if title, ok := rm["title"].(string); ok {
							wr.Title = title
						}
						if snippet, ok := rm["snippet"].(string); ok {
							wr.Snippet = snippet
						}
						rb.WebSearchResults.Results = append(rb.WebSearchResults.Results, wr)
					}
				}
			}
		}

		result = append(result, rb)
	}

	return result
}
</file>
<file path="pkg/client/search_test.go">
package client

import (
	"encoding/json"
	"testing"

	"github.com/diogo/perplexity-go/pkg/models"
)

func TestBuildSearchPayload(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	opts := models.SearchOptions{
		Query:    "test query",
		Mode:     models.ModeDefault,
		Model:    models.ModelPplxPro,
		Language: "en-US",
		Sources:  []models.Source{models.SourceWeb},
	}

	payload, err := client.buildSearchPayload(opts)
	if err != nil {
		t.Fatalf("buildSearchPayload() error = %v", err)
	}

	var req models.SearchRequest
	if err := json.Unmarshal(payload, &req); err != nil {
		t.Fatalf("Failed to unmarshal payload: %v", err)
	}

	if req.QueryStr != "test query" {
		t.Errorf("Query = %q, want %q", req.QueryStr, "test query")
	}
	if req.Params.Language != "en-US" {
		t.Errorf("Language = %q, want %q", req.Params.Language, "en-US")
	}
	if req.Params.Mode != "copilot" {
		t.Errorf("Mode = %q, want %q", req.Params.Mode, "copilot")
	}
}

func TestBuildSearchPayloadFastMode(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	opts := models.SearchOptions{
		Query: "test query",
		Mode:  models.ModeFast,
	}

	payload, err := client.buildSearchPayload(opts)
	if err != nil {
		t.Fatalf("buildSearchPayload() error = %v", err)
	}

	var req models.SearchRequest
	if err := json.Unmarshal(payload, &req); err != nil {
		t.Fatalf("Failed to unmarshal payload: %v", err)
	}

	if req.Params.Mode != "concise" {
		t.Errorf("Mode = %q, want %q for fast mode", req.Params.Mode, "concise")
	}
	if req.Params.ModelPreference == nil || *req.Params.ModelPreference != "turbo" {
		t.Errorf("ModelPreference should be turbo for fast mode")
	}
}

func TestBuildSearchPayloadGPT5Thinking(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	opts := models.SearchOptions{
		Query: "test query",
		Mode:  models.ModeDefault,
		Model: models.ModelGPT51Thinking,
	}

	payload, err := client.buildSearchPayload(opts)
	if err != nil {
		t.Fatalf("buildSearchPayload() error = %v", err)
	}

	var req models.SearchRequest
	if err := json.Unmarshal(payload, &req); err != nil {
		t.Fatalf("Failed to unmarshal payload: %v", err)
	}

	// GPT5Thinking should force concise mode with turbo
	if req.Params.Mode != "concise" {
		t.Errorf("Mode = %q, want %q for gpt5_thinking", req.Params.Mode, "concise")
	}
	if req.Params.ModelPreference == nil || *req.Params.ModelPreference != "turbo" {
		t.Errorf("ModelPreference should be turbo for gpt5_thinking")
	}
}

func TestBuildSearchPayloadReasoningMode(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	opts := models.SearchOptions{
		Query: "test query",
		Mode:  models.ModeReasoning,
	}

	payload, err := client.buildSearchPayload(opts)
	if err != nil {
		t.Fatalf("buildSearchPayload() error = %v", err)
	}

	var req models.SearchRequest
	if err := json.Unmarshal(payload, &req); err != nil {
		t.Fatalf("Failed to unmarshal payload: %v", err)
	}

	if req.Params.Mode != "copilot" {
		t.Errorf("Mode = %q, want %q", req.Params.Mode, "copilot")
	}
	if !req.Params.IsProReasoningMode {
		t.Error("IsProReasoningMode should be true for reasoning mode")
	}
}

func TestBuildSearchPayloadDeepResearch(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	opts := models.SearchOptions{
		Query: "test query",
		Mode:  models.ModeDeepResearch,
	}

	payload, err := client.buildSearchPayload(opts)
	if err != nil {
		t.Fatalf("buildSearchPayload() error = %v", err)
	}

	var req models.SearchRequest
	if err := json.Unmarshal(payload, &req); err != nil {
		t.Fatalf("Failed to unmarshal payload: %v", err)
	}

	if req.Params.Mode != "copilot" {
		t.Errorf("Mode = %q, want %q", req.Params.Mode, "copilot")
	}
	if req.Params.ModelPreference == nil || *req.Params.ModelPreference != "pplx_alpha" {
		t.Errorf("ModelPreference should be pplx_alpha for deep-research")
	}
}

func TestBuildSearchPayloadWithFollowUp(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	opts := models.SearchOptions{
		Query: "follow up query",
		Mode:  models.ModeDefault,
		FollowUp: &models.FollowUpContext{
			BackendUUID: "test-uuid-123",
			Attachments: []models.Attachment{
				{URL: "https://example.com/file.pdf"},
			},
		},
	}

	payload, err := client.buildSearchPayload(opts)
	if err != nil {
		t.Fatalf("buildSearchPayload() error = %v", err)
	}

	var req models.SearchRequest
	if err := json.Unmarshal(payload, &req); err != nil {
		t.Fatalf("Failed to unmarshal payload: %v", err)
	}

	if req.Params.BackendUUID != "test-uuid-123" {
		t.Errorf("BackendUUID = %q, want %q", req.Params.BackendUUID, "test-uuid-123")
	}
	if len(req.Params.Attachments) != 1 {
		t.Errorf("len(Attachments) = %d, want 1", len(req.Params.Attachments))
	}
}

func TestParseSSEChunk(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	tests := []struct {
		name  string
		chunk string
		want  models.StreamChunk
	}{
		{
			name:  "done signal",
			chunk: "data: [DONE]",
			want:  models.StreamChunk{Done: true},
		},
		{
			name:  "empty data",
			chunk: "",
			want:  models.StreamChunk{Done: true},
		},
		{
			name:  "plain text",
			chunk: "Hello world",
			want:  models.StreamChunk{Text: "Hello world"},
		},
		{
			name:  "json with backend_uuid",
			chunk: `data: {"backend_uuid": "test-uuid"}`,
			want:  models.StreamChunk{BackendUUID: "test-uuid"},
		},
		{
			name:  "json with delta",
			chunk: `data: {"delta": "new text"}`,
			want:  models.StreamChunk{Delta: "new text"},
		},
		{
			name:  "json with finished",
			chunk: `data: {"finished": true}`,
			want:  models.StreamChunk{Done: true},
		},
		{
			name:  "json with finish_reason",
			chunk: `data: {"finish_reason": "stop"}`,
			want:  models.StreamChunk{Done: true},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := client.parseSSEChunk(tt.chunk)
			if got.Done != tt.want.Done {
				t.Errorf("Done = %v, want %v", got.Done, tt.want.Done)
			}
			if got.BackendUUID != tt.want.BackendUUID {
				t.Errorf("BackendUUID = %q, want %q", got.BackendUUID, tt.want.BackendUUID)
			}
			if got.Delta != tt.want.Delta {
				t.Errorf("Delta = %q, want %q", got.Delta, tt.want.Delta)
			}
			if got.Text != tt.want.Text {
				t.Errorf("Text = %q, want %q", got.Text, tt.want.Text)
			}
		})
	}
}

func TestParseBlocks(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	blocks := []interface{}{
		map[string]interface{}{
			"markdown_block": map[string]interface{}{
				"answer": "This is the answer",
				"citations": []interface{}{
					map[string]interface{}{
						"url":   "https://example.com",
						"title": "Example",
					},
				},
			},
		},
		map[string]interface{}{
			"web_search_results": map[string]interface{}{
				"results": []interface{}{
					map[string]interface{}{
						"url":     "https://example.com/result",
						"title":   "Result Title",
						"snippet": "Result snippet",
					},
				},
			},
		},
	}

	result := client.parseBlocks(blocks)

	if len(result) != 2 {
		t.Fatalf("len(result) = %d, want 2", len(result))
	}

	// Check markdown block
	if result[0].MarkdownBlock == nil {
		t.Fatal("MarkdownBlock should not be nil")
	}
	if result[0].MarkdownBlock.Answer != "This is the answer" {
		t.Errorf("Answer = %q, want %q", result[0].MarkdownBlock.Answer, "This is the answer")
	}
	if len(result[0].MarkdownBlock.Citations) != 1 {
		t.Errorf("len(Citations) = %d, want 1", len(result[0].MarkdownBlock.Citations))
	}

	// Check web search results
	if result[1].WebSearchResults == nil {
		t.Fatal("WebSearchResults should not be nil")
	}
	if len(result[1].WebSearchResults.Results) != 1 {
		t.Errorf("len(Results) = %d, want 1", len(result[1].WebSearchResults.Results))
	}
	if result[1].WebSearchResults.Results[0].URL != "https://example.com/result" {
		t.Errorf("URL = %q, want %q", result[1].WebSearchResults.Results[0].URL, "https://example.com/result")
	}
}

func TestParseStepBasedResponse(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test with a complete step-based response
	data := `[{"step_type": "INITIAL_QUERY", "content": {"query": "test"}, "uuid": ""}, {"step_type": "FINAL", "content": {"answer": "{\"answer\": \"This is the answer.\", \"web_results\": [], \"chunks\": [\"This\", \" is\", \" the\", \" answer.\"], \"extra_web_results\": [], \"structured_answer\": []}"}, "uuid": "test-uuid"}]`

	result := client.parseStepBasedResponse(data)

	if result.StepType != "FINAL" {
		t.Errorf("StepType = %q, want %q", result.StepType, "FINAL")
	}
	if result.Text != "This is the answer." {
		t.Errorf("Text = %q, want %q", result.Text, "This is the answer.")
	}
	if len(result.Chunks) != 4 {
		t.Errorf("len(Chunks) = %d, want 4", len(result.Chunks))
	}
}

func TestParseStepBasedResponse_WithWebResults(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test with web results in SEARCH_RESULTS step
	data := `[{"step_type": "SEARCH_RESULTS", "content": {"goal_id": "0", "web_results": [{"name": "Test", "url": "https://example.com", "snippet": "Test snippet"}]}, "uuid": "test-uuid"}]`

	result := client.parseStepBasedResponse(data)

	if result.StepType != "SEARCH_RESULTS" {
		t.Errorf("StepType = %q, want %q", result.StepType, "SEARCH_RESULTS")
	}
	if len(result.WebResults) != 1 {
		t.Fatalf("len(WebResults) = %d, want 1", len(result.WebResults))
	}
	if result.WebResults[0].URL != "https://example.com" {
		t.Errorf("WebResults[0].URL = %q, want %q", result.WebResults[0].URL, "https://example.com")
	}
}

func TestParseStepBasedResponse_WithTrailingSSEMarker(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test with trailing SSE marker
	data := `[{"step_type": "FINAL", "content": {"answer": "{\"answer\": \"Answer text.\", \"web_results\": [], \"chunks\": [], \"extra_web_results\": [], \"structured_answer\": []}"}, "uuid": ""}]event: end_of_stream
data: {}`

	result := client.parseStepBasedResponse(data)

	if result.StepType != "FINAL" {
		t.Errorf("StepType = %q, want %q", result.StepType, "FINAL")
	}
	if result.Text != "Answer text." {
		t.Errorf("Text = %q, want %q", result.Text, "Answer text.")
	}
}

func TestParseSSEChunk_NewFormat(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test with new format where text field contains step array
	chunk := `{"backend_uuid": "test-uuid", "text": "[{\"step_type\": \"FINAL\", \"content\": {\"answer\": \"{\\\"answer\\\": \\\"The answer.\\\", \\\"web_results\\\": [], \\\"chunks\\\": [], \\\"extra_web_results\\\": [], \\\"structured_answer\\\": []}\"}, \"uuid\": \"\"}]"}`

	result := client.parseSSEChunk(chunk)

	if result.StepType != "FINAL" {
		t.Errorf("StepType = %q, want %q", result.StepType, "FINAL")
	}
	if result.Text != "The answer." {
		t.Errorf("Text = %q, want %q", result.Text, "The answer.")
	}
	if !result.Done {
		t.Error("Done should be true for FINAL step")
	}
}

func TestParseSSEChunk_EndOfStream(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	tests := []struct {
		name  string
		chunk string
	}{
		{"event: end_of_stream", "event: end_of_stream\ndata: {}"},
		{"empty object", "{}"},
		{"data: empty object", "data: {}"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := client.parseSSEChunk(tt.chunk)
			if !result.Done {
				t.Errorf("Done = false, want true for %q", tt.chunk)
			}
		})
	}
}
</file>
<file path="pkg/client/search_test.go.broken">
package client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"strings"
	"testing"

	http "github.com/bogdanfinn/fhttp"
	"github.com/diogo/perplexity-go/pkg/models"
)

// testHTTPClient mimics HTTPClient but allows mocking the Post method
type testHTTPClient struct {
	client tls_client.HttpClient
	cookies []*http.Cookie

	MockResponse *http.Response
	MockError    error
}

func (t *testHTTPClient) Post(path string, body []byte) (*http.Response, error) {
	if t.MockError != nil {
		return nil, t.MockError
	}
	return t.MockResponse, nil
}

func (t *testHTTPClient) Get(path string) (*http.Response, error) {
	return nil, nil
}

func (t *testHTTPClient) PostWithReader(path string, body []byte) (*http.Response, error) {
	return nil, nil
}

func (t *testHTTPClient) buildHeaders() http.Header {
	return http.Header{
		"Accept":             {"*/*"},
		"Accept-Language":    {"en-US,en;q=0.9"},
		"Content-Type":       {"application/json"},
		"Origin":             {"https://www.perplexity.ai"},
		"User-Agent":         {"Mozilla/5.0"},
	}
}

func (t *testHTTPClient) GetCSRFToken() string {
	return ""
}

func (t *testHTTPClient) SetCookies(cookies []*http.Cookie) {
	t.cookies = cookies
}

func (t *testHTTPClient) AddCookie(cookie *http.Cookie) {
	t.cookies = append(t.cookies, cookie)
}

func (t *testHTTPClient) GetCookies() []*http.Cookie {
	return t.cookies
}

func (t *testHTTPClient) Close() error {
	return nil
}

func TestSearchStreamChannel(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Create test HTTP client with mock
	testHTTP := &testHTTPClient{
		HTTPClient: client.http,
	}

	// Create SSE response
	sseData := `event: message
data: {"text": "Hello", "backend_uuid": "test-uuid-123"}

event: message
data: {"delta": " World"}

event: message
data: [DONE]`

	response := &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(strings.NewReader(sseData)),
		Header:     http.Header{"Content-Type": {"text/event-stream"}},
	}

	testHTTP.MockResponse = response
	client.http = testHTTP

	// Test streaming channel
	ctx := context.Background()
	ch, err := client.searchStreamChannel(ctx, models.SearchOptions{
		Query: "test query",
	})
	if err != nil {
		t.Fatalf("searchStreamChannel() error = %v", err)
	}

	// Collect chunks
	chunksReceived := 0
	for chunk := range ch {
		chunksReceived++
		if chunk.Error != nil {
			t.Errorf("Unexpected error in chunk: %v", chunk.Error)
		}
		if chunk.Done {
			break
		}
	}

	if chunksReceived == 0 {
		t.Error("Expected to receive at least one chunk")
	}
}

func TestSearchStreamChannel_ErrorResponse(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	testHTTP := &testHTTPClient{
		HTTPClient: client.http,
		MockError:  fmt.Errorf("network error"),
	}
	client.http = testHTTP

	ctx := context.Background()
	ch, err := client.searchStreamChannel(ctx, models.SearchOptions{
		Query: "test query",
	})
	if err != nil {
		t.Fatalf("searchStreamChannel() error = %v", err)
	}

	// Should receive error chunk
	chunk := <-ch
	if chunk.Error == nil {
		t.Error("Expected error chunk")
	}
}

func TestSearchStreamChannel_Non200Status(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Simulate non-200 status
	response := &http.Response{
		StatusCode: 401,
		Body:       io.NopCloser(strings.NewReader("Unauthorized")),
	}
	testHTTP := &testHTTPClient{
		HTTPClient:  client.http,
		MockResponse: response,
	}
	client.http = testHTTP

	ctx := context.Background()
	ch, err := client.searchStreamChannel(ctx, models.SearchOptions{
		Query: "test query",
	})
	if err != nil {
		t.Fatalf("searchStreamChannel() error = %v", err)
	}

	// Should receive error chunk
	chunk := <-ch
	if chunk.Error == nil {
		t.Error("Expected error chunk for non-200 status")
	}
}

func TestSearchStreamChannel_ContextCancelled(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Create SSE response with delay
	sseData := `event: message
data: {"text": "Hello"}

event: message
data: [DONE]`

	response := &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(strings.NewReader(sseData)),
	}
	testHTTP := &testHTTPClient{
		HTTPClient:  client.http,
		MockResponse: response,
	}
	client.http = testHTTP

	// Create cancellable context
	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel immediately

	ch, err := client.searchStreamChannel(ctx, models.SearchOptions{
		Query: "test query",
	})
	if err != nil {
		t.Fatalf("searchStreamChannel() error = %v", err)
	}

	// Should receive error chunk for cancelled context
	chunk := <-ch
	if chunk.Error == nil {
		t.Error("Expected error chunk for cancelled context")
	}
}

func TestSearchStream(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Create step-based SSE response
	sseData := `event: message
data: [{"step_type": "INITIAL_QUERY", "content": {"query": "test"}, "uuid": ""}]
event: message
data: [{"step_type": "SEARCH_RESULTS", "content": {"web_results": []}, "uuid": ""}]
event: message
data: [{"step_type": "FINAL", "content": {"answer": "{\"answer\": \"Streaming answer\", \"web_results\": [], \"chunks\": [], \"extra_web_results\": [], \"structured_answer\": []}"}, "uuid": "test-uuid"}]
event: message
data: [DONE]`

	response := &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(strings.NewReader(sseData)),
	}
	testHTTP := &testHTTPClient{
		HTTPClient:  client.http,
		MockResponse: response,
	}
	client.http = testHTTP

	ctx := context.Background()
	result, err := client.searchStream(ctx, models.SearchOptions{
		Query: "test query",
	})
	if err != nil {
		t.Fatalf("searchStream() error = %v", err)
	}

	if result == nil {
		t.Fatal("searchStream() returned nil response")
	}

	if result.Text != "Streaming answer" {
		t.Errorf("Text = %q, want %q", result.Text, "Streaming answer")
	}

	if result.BackendUUID != "test-uuid" {
		t.Errorf("BackendUUID = %q, want %q", result.BackendUUID, "test-uuid")
	}
}

func TestSearchNonStream(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Create legacy format SSE response
	sseData := `event: message
data: {"backend_uuid": "legacy-uuid", "text": "{\"blocks\": [{\"markdown_block\": {\"answer\": \"Legacy answer\", \"citations\": []}}]}"}

event: message
data: [DONE]`

	response := &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(strings.NewReader(sseData)),
	}
	testHTTP := &testHTTPClient{
		HTTPClient:  client.http,
		MockResponse: response,
	}
	client.http = testHTTP

	ctx := context.Background()
	result, err := client.searchNonStream(ctx, models.SearchOptions{
		Query: "test query",
	})
	if err != nil {
		t.Fatalf("searchNonStream() error = %v", err)
	}

	if result == nil {
		t.Fatal("searchNonStream() returned nil response")
	}

	if result.Text != "Legacy answer" {
		t.Errorf("Text = %q, want %q", result.Text, "Legacy answer")
	}

	if result.BackendUUID != "legacy-uuid" {
		t.Errorf("BackendUUID = %q, want %q", result.BackendUUID, "legacy-uuid")
	}

	if len(result.Blocks) == 0 {
		t.Error("Expected blocks in response")
	}
}

func TestSearchNonStream_WithErrorInChunk(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Create SSE response with error
	sseData := `event: message
data: {"text": "Some text"}

event: message
data: {"error": "Something went wrong"}

event: message
data: [DONE]`

	response := &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(strings.NewReader(sseData)),
	}
	testHTTP := &testHTTPClient{
		HTTPClient:  client.http,
		MockResponse: response,
	}
	client.http = testHTTP

	ctx := context.Background()
	result, err := client.searchNonStream(ctx, models.SearchOptions{
		Query: "test query",
	})
	if err == nil {
		t.Error("searchNonStream() expected error but got nil")
	}

	if result != nil {
		t.Error("searchNonStream() should return nil on error")
	}
}

func TestSearch(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	sseData := `event: message
data: [{"step_type": "FINAL", "content": {"answer": "{\"answer\": \"Test answer\", \"web_results\": [], \"chunks\": [], \"extra_web_results\": [], \"structured_answer\": []}"}, "uuid": "search-uuid"}]
event: message
data: [DONE]`

	response := &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(strings.NewReader(sseData)),
	}
	testHTTP := &testHTTPClient{
		HTTPClient:  client.http,
		MockResponse: response,
	}
	client.http = testHTTP

	ctx := context.Background()
	result, err := client.Search(ctx, models.SearchOptions{
		Query:  "test query",
		Stream: false,
	})
	if err != nil {
		t.Fatalf("Search() error = %v", err)
	}

	if result == nil {
		t.Fatal("Search() returned nil response")
	}

	if result.Text != "Test answer" {
		t.Errorf("Text = %q, want %q", result.Text, "Test answer")
	}
}

func TestSearchStreamIntegration(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	sseData := `event: message
data: {"delta": "Hello"}

event: message
data: {"delta": " World"}

event: message
data: [DONE]`

	response := &http.Response{
		StatusCode: 200,
		Body:       io.NopCloser(strings.NewReader(sseData)),
	}
	testHTTP := &testHTTPClient{
		HTTPClient:  client.http,
		MockResponse: response,
	}
	client.http = testHTTP

	ctx := context.Background()
	ch, err := client.SearchStream(ctx, models.SearchOptions{
		Query: "test query",
	})
	if err != nil {
		t.Fatalf("SearchStream() error = %v", err)
	}

	// Collect chunks
	chunks := []models.StreamChunk{}
	for chunk := range ch {
		chunks = append(chunks, chunk)
		if chunk.Done {
			break
		}
	}

	if len(chunks) != 3 {
		t.Errorf("Expected 3 chunks, got %d", len(chunks))
	}

	// Check that we got the deltas
	if chunks[0].Delta != "Hello" {
		t.Errorf("First chunk Delta = %q, want %q", chunks[0].Delta, "Hello")
	}
	if chunks[1].Delta != " World" {
		t.Errorf("Second chunk Delta = %q, want %q", chunks[1].Delta, " World")
	}
}

func TestParseSSEStream(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	// Test with SSE format using \r\n\r\n delimiter
	sseData := "event: message\ndata: {\"text\": \"First chunk\"}\r\n\r\nevent: message\ndata: {\"text\": \"Second chunk\"}\r\n\rnevent: message\ndata: [DONE]\r\n\r\n"

	ch := make(chan models.StreamChunk, 10)
	go func() {
		client.parseSSEStream(ctx, strings.NewReader(sseData), ch)
		close(ch)
	}()

	// Collect chunks
	chunks := []models.StreamChunk{}
	for chunk := range ch {
		chunks = append(chunks, chunk)
	}

	if len(chunks) < 2 {
		t.Errorf("Expected at least 2 chunks, got %d", len(chunks))
	}

	// First chunk should have text
	if len(chunks) > 0 && chunks[0].Text != "First chunk" {
		t.Errorf("First chunk Text = %q, want %q", chunks[0].Text, "First chunk")
	}

	// Second chunk should have text
	if len(chunks) > 1 && chunks[1].Text != "Second chunk" {
		t.Errorf("Second chunk Text = %q, want %q", chunks[1].Text, "Second chunk")
	}
}

func TestParseSSEStream_WithLFOnly(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	// Test with SSE format using \n\n delimiter (alternative format)
	sseData := "event: message\ndata: {\"text\": \"Test with LF\"}\n\nevent: message\ndata: [DONE]\n\n"

	ch := make(chan models.StreamChunk, 10)
	go func() {
		client.parseSSEStream(ctx, strings.NewReader(sseData), ch)
		close(ch)
	}()

	// Collect chunks
	chunks := []models.StreamChunk{}
	for chunk := range ch {
		chunks = append(chunks, chunk)
	}

	if len(chunks) == 0 {
		t.Error("Expected at least 1 chunk")
	}

	if len(chunks) > 0 && chunks[0].Text != "Test with LF" {
		t.Errorf("Chunk Text = %q, want %q", chunks[0].Text, "Test with LF")
	}
}

func TestParseSSEStream_WithEmptyChunks(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	// Test with empty chunks between data
	sseData := "event: message\ndata: {\"text\": \"First\"}\r\n\r\n\r\n\r\nevent: message\ndata: {\"text\": \"Second\"}\r\n\r\n\r\n\r\nevent: message\ndata: [DONE]\r\n\r\n"

	ch := make(chan models.StreamChunk, 10)
	go func() {
		client.parseSSEStream(ctx, strings.NewReader(sseData), ch)
		close(ch)
	}()

	// Collect chunks
	chunks := []models.StreamChunk{}
	for chunk := range ch {
		chunks = append(chunks, chunk)
	}

	// Should handle empty lines gracefully
	if len(chunks) < 2 {
		t.Errorf("Expected at least 2 chunks, got %d", len(chunks))
	}
}

func TestParseSSEStream_WithEventPrefix(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	// Test with explicit "event: message" prefix
	sseData := "event: message\ndata: {\"text\": \"Prefixed\"}\r\n\r\nevent: message\ndata: [DONE]\r\n\r\n"

	ch := make(chan models.StreamChunk, 10)
	go func() {
		client.parseSSEStream(ctx, strings.NewReader(sseData), ch)
		close(ch)
	}()

	// Collect chunks
	chunks := []models.StreamChunk{}
	for chunk := range ch {
		chunks = append(chunks, chunk)
	}

	if len(chunks) == 0 {
		t.Error("Expected at least 1 chunk")
	}

	if len(chunks) > 0 && chunks[0].Text != "Prefixed" {
		t.Errorf("Chunk Text = %q, want %q", chunks[0].Text, "Prefixed")
	}
}

func TestParseSSEStream_WithLargeBuffer(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	// Create a large SSE response to test buffer handling
	var buf strings.Builder
	buf.WriteString("event: message\ndata: {\"text\": \"")
	// Write large text (60KB+)
	for i := 0; i < 60000; i++ {
		buf.WriteRune('a')
	}
	buf.WriteString("\"}\r\n\r\nevent: message\ndata: [DONE]\r\n\r\n")

	ch := make(chan models.StreamChunk, 10)
	go func() {
		client.parseSSEStream(ctx, strings.NewReader(buf.String()), ch)
		close(ch)
	}()

	// Collect chunks
	chunks := []models.StreamChunk{}
	for chunk := range ch {
		chunks = append(chunks, chunk)
	}

	if len(chunks) == 0 {
		t.Error("Expected at least 1 chunk")
	}
}

func TestParseSSEStream_WithContextCancellation(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel immediately

	// SSE data with delay
	sseData := "event: message\ndata: {\"text\": \"Should not parse\"}\r\n\r\nevent: message\ndata: [DONE]\r\n\r\n"

	ch := make(chan models.StreamChunk, 10)
	go func() {
		client.parseSSEStream(ctx, strings.NewReader(sseData), ch)
		close(ch)
	}()

	// Should receive error due to context cancellation
	chunk := <-ch
	if chunk.Error == nil {
		t.Error("Expected error due to context cancellation")
	}
}

func TestParseSSEStream_WithScannerError(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	// Create a reader that will cause scanner error
	invalidData := strings.Repeat("a", 2000) // Larger than default buffer

	ch := make(chan models.StreamChunk, 10)
	go func() {
		client.parseSSEStream(ctx, strings.NewReader(invalidData), ch)
		close(ch)
	}()

	// Should handle scanner error gracefully
	chunk := <-ch
	if chunk.Error == nil {
		t.Error("Expected error for invalid SSE data")
	}
}

func TestParseSSEChunk_WithLegacyInnerJSON(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test legacy format where text field contains inner JSON with blocks
	chunk := `{"backend_uuid": "legacy-uuid", "text": "{\"blocks\": [{\"markdown_block\": {\"answer\": \"Legacy block answer\", \"citations\": [{\"url\": \"https://example.com\", \"title\": \"Example\", \"snippet\": \"Example snippet\"}]}}, {\"web_search_results\": {\"results\": [{\"url\": \"https://example.com/result\", \"title\": \"Result\", \"snippet\": \"Result snippet\"}]}}]}"}`

	result := client.parseSSEChunk(chunk)

	if result.BackendUUID != "legacy-uuid" {
		t.Errorf("BackendUUID = %q, want %q", result.BackendUUID, "legacy-uuid")
	}

	if len(result.Blocks) != 2 {
		t.Errorf("len(Blocks) = %d, want 2", len(result.Blocks))
	}

	if result.Blocks[0].MarkdownBlock == nil {
		t.Error("MarkdownBlock should not be nil")
	} else if result.Blocks[0].MarkdownBlock.Answer != "Legacy block answer" {
		t.Errorf("Block Answer = %q, want %q", result.Blocks[0].MarkdownBlock.Answer, "Legacy block answer")
	}

	if len(result.Blocks[0].MarkdownBlock.Citations) != 1 {
		t.Errorf("len(Citations) = %d, want 1", len(result.Blocks[0].MarkdownBlock.Citations))
	} else if result.Blocks[0].MarkdownBlock.Citations[0].URL != "https://example.com" {
		t.Errorf("Citation URL = %q, want %q", result.Blocks[0].MarkdownBlock.Citations[0].URL, "https://example.com")
	}

	if result.Blocks[1].WebSearchResults == nil {
		t.Error("WebSearchResults should not be nil")
	} else if len(result.Blocks[1].WebSearchResults.Results) != 1 {
		t.Errorf("len(WebSearchResults) = %d, want 1", len(result.Blocks[1].WebSearchResults.Results))
	}
}

func TestParseSSEChunk_WithNestedStepBasedFormat(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test where text field contains step-based format that's already FINAL
	chunk := `{"backend_uuid": "nested-uuid", "text": "[{\"step_type\": \"FINAL\", \"content\": {\"answer\": \"{\\\"answer\\\": \\\"Nested FINAL answer\\\", \\\"web_results\\\": [{\\\"url\\\": \\\"https://nested.com\\\", \\\"title\\\": \\\"Nested\\\", \\\"snippet\\\": \\\"Nested snippet\\\"}], \\\"chunks\\\": [\\\"Nested\\\", \\\" FINAL\\\", \\\" answer\\\"], \\\"extra_web_results\\\": [], \\\"structured_answer\\\": []}\"}, \"uuid\": \"nested-final-uuid\"}]"}`

	result := client.parseSSEChunk(chunk)

	if result.StepType != "FINAL" {
		t.Errorf("StepType = %q, want %q", result.StepType, "FINAL")
	}

	if result.Text != "Nested FINAL answer" {
		t.Errorf("Text = %q, want %q", result.Text, "Nested FINAL answer")
	}

	if !result.Done {
		t.Error("Done should be true for FINAL step")
	}

	if len(result.WebResults) != 1 {
		t.Errorf("len(WebResults) = %d, want 1", len(result.WebResults))
	} else if result.WebResults[0].URL != "https://nested.com" {
		t.Errorf("WebResults[0].URL = %q, want %q", result.WebResults[0].URL, "https://nested.com")
	}

	if len(result.Chunks) != 3 {
		t.Errorf("len(Chunks) = %d, want 3", len(result.Chunks))
	}
}

func TestParseSSEChunk_WithDirectStepBasedFormat(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test direct step-based format (not nested in text field)
	chunk := `[{"step_type": "INITIAL_QUERY", "content": {"query": "direct step query"}, "uuid": "direct-query-uuid"}, {"step_type": "SEARCH_WEB", "content": {}, "uuid": ""}, {"step_type": "FINAL", "content": {"answer": "{\"answer\": \"Direct FINAL answer\", \"web_results\": [], \"chunks\": [], \"extra_web_results\": [], \"structured_answer\": []}"}, "uuid": "direct-final-uuid"}]`

	result := client.parseSSEChunk(chunk)

	if result.StepType != "FINAL" {
		t.Errorf("StepType = %q, want %q", result.StepType, "FINAL")
	}

	if result.Text != "Direct FINAL answer" {
		t.Errorf("Text = %q, want %q", result.Text, "Direct FINAL answer")
	}
}

func TestParseSSEChunk_WithInvalidJSON(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test with invalid JSON - should return as plain text
	chunk := `{"text": "not valid json`

	result := client.parseSSEChunk(chunk)

	if result.Text != `{"text": "not valid json` {
		t.Errorf("Text = %q, want %q", result.Text, `{"text": "not valid json`)
	}
}

func TestParseSSEChunk_WithStepBasedNonFinal(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test with non-FINAL step type
	chunk := `[{"step_type": "SEARCH_WEB", "content": {"url": "https://search.com"}, "uuid": "search-uuid"}]`

	result := client.parseSSEChunk(chunk)

	if result.StepType != "SEARCH_WEB" {
		t.Errorf("StepType = %q, want %q", result.StepType, "SEARCH_WEB")
	}

	if result.BackendUUID != "search-uuid" {
		t.Errorf("BackendUUID = %q, want %q", result.BackendUUID, "search-uuid")
	}

	// Non-FINAL steps should not have Done set
	if result.Done {
		t.Error("Done should be false for non-FINAL step")
	}
}

func TestParseStepBasedResponse_WithMultipleSteps(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test with multiple steps including search results and final
	data := `[{"step_type": "SEARCH_RESULTS", "content": {"goal_id": "0", "web_results": [{"name": "Result 1", "url": "https://result1.com", "snippet": "Snippet 1"}, {"name": "Result 2", "url": "https://result2.com", "snippet": "Snippet 2"}]}, "uuid": "search-results-uuid"}, {"step_type": "FINAL", "content": {"answer": "{\"answer\": \"Final answer with multiple results\", \"web_results\": [], \"chunks\": [], \"extra_web_results\": [{\"name\": \"Extra\", \"url\": \"https://extra.com\", \"snippet\": \"Extra snippet\"}], \"structured_answer\": []}"}, "uuid": "final-uuid"}]`

	result := client.parseStepBasedResponse(data)

	if result.StepType != "FINAL" {
		t.Errorf("StepType = %q, want %q", result.StepType, "FINAL")
	}

	if result.Text != "Final answer with multiple results" {
		t.Errorf("Text = %q, want %q", result.Text, "Final answer with multiple results")
	}

	// Should have web results from SEARCH_RESULTS step
	if len(result.WebResults) < 3 {
		t.Errorf("Expected at least 3 WebResults, got %d", len(result.WebResults))
	}

	// Should have extra web results from FINAL step
	if len(result.WebResults) >= 3 {
		if result.WebResults[2].URL != "https://extra.com" {
			t.Errorf("Extra WebResults[2].URL = %q, want %q", result.WebResults[2].URL, "https://extra.com")
		}
	}
}

func TestParseStepBasedResponse_WithMalformedJSON(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test with malformed JSON - should return as plain text
	data := `[{"step_type": "FINAL", "content": {"answer": "not valid json`

	result := client.parseStepBasedResponse(data)

	if result.Text == "" {
		t.Error("Expected Text to contain raw data for malformed JSON")
	}
}

func TestParseStepBasedResponse_WithExtractionLogic(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	// Test the array extraction logic
	data := `some prefix [{"step_type": "FINAL", "content": {"answer": "{\"answer\": \"Extracted answer\", \"web_results\": [], \"chunks\": [], \"extra_web_results\": [], \"structured_answer\": []}"}, "uuid": ""}] some suffix`

	result := client.parseStepBasedResponse(data)

	if result.StepType != "FINAL" {
		t.Errorf("StepType = %q, want %q", result.StepType, "FINAL")
	}

	if result.Text != "Extracted answer" {
		t.Errorf("Text = %q, want %q", result.Text, "Extracted answer")
	}
}

func TestClientGetCookies(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	cookies := []*http.Cookie{
		{Name: "cookie1", Value: "value1", Domain: ".perplexity.ai"},
		{Name: "cookie2", Value: "value2", Domain: ".perplexity.ai"},
	}

	client.SetCookies(cookies)

	retrieved := client.GetCookies()
	if len(retrieved) != 2 {
		t.Errorf("len(retrieved cookies) = %d, want 2", len(retrieved))
	}
}
</file>
<file path="pkg/client/upload.go">
package client

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/diogo/perplexity-go/pkg/models"
)

// UploadFile uploads a file and returns its URL for use in queries.
func (c *Client) UploadFile(filePath string) (string, error) {
	// Read file
	data, err := os.ReadFile(filePath)
	if err != nil {
		return "", fmt.Errorf("failed to read file: %w", err)
	}

	filename := filepath.Base(filePath)
	contentType := detectContentType(filename)

	return c.UploadBytes(data, filename, contentType)
}

// UploadBytes uploads file bytes and returns the URL.
func (c *Client) UploadBytes(data []byte, filename, contentType string) (string, error) {
	// Step 1: Request upload URL
	uploadReq := models.UploadURLRequest{
		Filename:    filename,
		ContentType: contentType,
	}

	reqBody, err := json.Marshal(uploadReq)
	if err != nil {
		return "", fmt.Errorf("failed to marshal upload request: %w", err)
	}

	resp, err := c.http.Post(uploadPath, bytes.NewReader(reqBody), nil)
	if err != nil {
		return "", fmt.Errorf("failed to request upload URL: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("upload URL request failed %d: %s", resp.StatusCode, string(body))
	}

	var uploadResp models.UploadURLResponse
	if err := json.NewDecoder(resp.Body).Decode(&uploadResp); err != nil {
		return "", fmt.Errorf("failed to decode upload response: %w", err)
	}

	// Step 2: Upload to S3
	finalURL, err := c.uploadToS3(uploadResp, data, filename, contentType)
	if err != nil {
		return "", fmt.Errorf("S3 upload failed: %w", err)
	}

	// Track upload count
	c.fileUploads++

	return finalURL, nil
}

// uploadToS3 uploads the file to the S3 bucket.
func (c *Client) uploadToS3(upload models.UploadURLResponse, data []byte, filename, contentType string) (string, error) {
	// Create multipart form
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	// Add fields from upload response
	for key, value := range upload.Fields {
		if err := writer.WriteField(key, value); err != nil {
			return "", fmt.Errorf("failed to write field %s: %w", key, err)
		}
	}

	// Add Content-Type field
	if err := writer.WriteField("Content-Type", contentType); err != nil {
		return "", fmt.Errorf("failed to write Content-Type: %w", err)
	}

	// Add file
	part, err := writer.CreateFormFile("file", filename)
	if err != nil {
		return "", fmt.Errorf("failed to create form file: %w", err)
	}

	if _, err := part.Write(data); err != nil {
		return "", fmt.Errorf("failed to write file data: %w", err)
	}

	if err := writer.Close(); err != nil {
		return "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	// Send to S3 using standard http client (no TLS spoofing needed for S3)
	req, err := http.NewRequest("POST", upload.URL, &buf)
	if err != nil {
		return "", fmt.Errorf("failed to create S3 request: %w", err)
	}

	req.Header.Set("Content-Type", writer.FormDataContentType())

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("S3 request failed: %w", err)
	}
	defer resp.Body.Close()

	// S3 returns 204 No Content on success
	if resp.StatusCode != 204 && resp.StatusCode != 200 && resp.StatusCode != 201 {
		body, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("S3 upload failed %d: %s", resp.StatusCode, string(body))
	}

	// Construct final URL
	finalURL := upload.FinalURL
	if finalURL == "" {
		// Build URL from upload.Fields["key"]
		if key, ok := upload.Fields["key"]; ok {
			finalURL = strings.TrimSuffix(upload.URL, "/") + "/" + key
		}
	}

	// Handle image URL rewriting
	if isImageFile(filename) {
		finalURL = rewriteImageURL(finalURL)
	}

	return finalURL, nil
}

// detectContentType detects MIME type from filename.
func detectContentType(filename string) string {
	ext := strings.ToLower(filepath.Ext(filename))
	switch ext {
	case ".jpg", ".jpeg":
		return "image/jpeg"
	case ".png":
		return "image/png"
	case ".gif":
		return "image/gif"
	case ".webp":
		return "image/webp"
	case ".pdf":
		return "application/pdf"
	case ".txt":
		return "text/plain"
	case ".md":
		return "text/markdown"
	case ".json":
		return "application/json"
	case ".csv":
		return "text/csv"
	case ".doc":
		return "application/msword"
	case ".docx":
		return "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
	case ".xls":
		return "application/vnd.ms-excel"
	case ".xlsx":
		return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
	default:
		return "application/octet-stream"
	}
}

// isImageFile checks if the filename represents an image.
func isImageFile(filename string) bool {
	ext := strings.ToLower(filepath.Ext(filename))
	switch ext {
	case ".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp", ".svg":
		return true
	}
	return false
}

// rewriteImageURL rewrites S3 URLs for image display.
// This matches the Python implementation's regex URL rewriting.
func rewriteImageURL(url string) string {
	// Pattern to match S3 bucket URLs
	re := regexp.MustCompile(`https://([^.]+)\.s3\.([^.]+)\.amazonaws\.com/(.+)`)
	matches := re.FindStringSubmatch(url)
	if len(matches) == 4 {
		bucket := matches[1]
		region := matches[2]
		key := matches[3]
		return fmt.Sprintf("https://s3.%s.amazonaws.com/%s/%s", region, bucket, key)
	}
	return url
}
</file>
<file path="pkg/client/upload_test.go.bak">
package client

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"

	http "github.com/bogdanfinn/fhttp"
	"github.com/diogo/perplexity-go/pkg/models"
)

// createTestResponse creates a test HTTP response with JSON body
func createTestResponse(statusCode int, body string) *http.Response {
	return &http.Response{
		StatusCode: statusCode,
		Body:       io.NopCloser(strings.NewReader(body)),
		Header:     make(http.Header),
	}
}

func TestDetectContentType(t *testing.T) {
	tests := []struct {
		filename string
		want     string
	}{
		{"file.jpg", "image/jpeg"},
		{"file.jpeg", "image/jpeg"},
		{"file.JPG", "image/jpeg"},
		{"file.png", "image/png"},
		{"file.PNG", "image/png"},
		{"file.gif", "image/gif"},
		{"file.webp", "image/webp"},
		{"file.pdf", "application/pdf"},
		{"file.txt", "text/plain"},
		{"file.md", "text/markdown"},
		{"file.json", "application/json"},
		{"file.csv", "text/csv"},
		{"file.doc", "application/msword"},
		{"file.docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"},
		{"file.xls", "application/vnd.ms-excel"},
		{"file.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"},
		{"file.unknown", "application/octet-stream"},
		{"file", "application/octet-stream"},
		{"file.", "application/octet-stream"},
		// Edge cases
		{"file.tar.gz", "application/octet-stream"},
		{".hidden.jpg", "image/jpeg"},
		{".gitignore", "application/octet-stream"},
		{"file.JPG.PNG", "application/octet-stream"}, // Multiple extensions
	}

	for _, tt := range tests {
		t.Run(tt.filename, func(t *testing.T) {
			got := detectContentType(tt.filename)
			if got != tt.want {
				t.Errorf("detectContentType(%q) = %q, want %q", tt.filename, got, tt.want)
			}
		})
	}
}

func TestIsImageFile(t *testing.T) {
	tests := []struct {
		filename string
		want     bool
	}{
		{"file.jpg", true},
		{"file.jpeg", true},
		{"file.png", true},
		{"file.gif", true},
		{"file.webp", true},
		{"file.bmp", true},
		{"file.svg", true},
		{"file.JPG", true},
		{"file.pdf", false},
		{"file.txt", false},
		{"file.doc", false},
		{"file", false},
		// Edge cases
		{".hidden.png", true},
		{"file.PNG.GIF", false}, // Multiple extensions - only last should count
	}

	for _, tt := range tests {
		t.Run(tt.filename, func(t *testing.T) {
			got := isImageFile(tt.filename)
			if got != tt.want {
				t.Errorf("isImageFile(%q) = %v, want %v", tt.filename, got, tt.want)
			}
		})
	}
}

func TestRewriteImageURL(t *testing.T) {
	tests := []struct {
		name string
		url  string
		want string
	}{
		{
			name: "S3 bucket URL",
			url:  "https://mybucket.s3.us-east-1.amazonaws.com/path/to/file.png",
			want: "https://s3.us-east-1.amazonaws.com/mybucket/path/to/file.png",
		},
		{
			name: "S3 bucket URL eu-west",
			url:  "https://otherbucket.s3.eu-west-1.amazonaws.com/images/photo.jpg",
			want: "https://s3.eu-west-1.amazonaws.com/otherbucket/images/photo.jpg",
		},
		{
			name: "S3 bucket URL ap-southeast",
			url:  "https://testbucket.s3.ap-southeast-1.amazonaws.com/files/image.webp",
			want: "https://s3.ap-southeast-1.amazonaws.com/testbucket/files/image.webp",
		},
		{
			name: "Non-S3 URL unchanged",
			url:  "https://example.com/path/to/file.png",
			want: "https://example.com/path/to/file.png",
		},
		{
			name: "Different domain unchanged",
			url:  "https://cdn.example.com/file.png",
			want: "https://cdn.example.com/file.png",
		},
		{
			name: "S3 URL with query params",
			url:  "https://mybucket.s3.us-east-1.amazonaws.com/path/file.png?token=123",
			want: "https://s3.us-east-1.amazonaws.com/mybucket/path/file.png?token=123",
		},
		{
			name: "Empty URL",
			url:  "",
			want: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := rewriteImageURL(tt.url)
			if got != tt.want {
				t.Errorf("rewriteImageURL(%q) = %q, want %q", tt.url, got, tt.want)
			}
		})
	}
}

func TestClientUploadFile(t *testing.T) {
	// Create a temporary file for testing
	tmpDir := t.TempDir()

	tests := []struct {
		name      string
		filename  string
		content   string
		mockResp  *http.Response
		want      string
		wantErr   bool
	}{
		{
			name:     "successful image upload",
			filename: "test.png",
			content:  "fake image data",
			mockResp: createTestResponse(200, `{
				"url": "https://test-bucket.s3.us-east-1.amazonaws.com",
				"fields": {
					"key": "uploads/test.png",
					"bucket": "test-bucket",
					"region": "us-east-1"
				},
				"final_url": "https://test-bucket.s3.us-east-1.amazonaws.com/uploads/test.png"
			}`),
			want:    "https://s3.us-east-1.amazonaws.com/test-bucket/uploads/test.png",
			wantErr: false,
		},
		{
			name:     "successful PDF upload",
			filename: "document.pdf",
			content:  "PDF content",
			mockResp: createTestResponse(200, `{
				"url": "https://bucket.s3.eu-west-1.amazonaws.com",
				"fields": {
					"key": "docs/document.pdf"
				}
			}`),
			want:    "https://bucket.s3.eu-west-1.amazonaws.com/docs/document.pdf",
			wantErr: false,
		},
		{
			name:     "file not found error",
			filename: "/nonexistent/path/to/file.txt",
			content:  "",
			mockResp: nil,
			want:     "",
			wantErr:  true,
		},
		{
			name:     "upload URL request fails",
			filename: "test.jpg",
			content:  "image",
			mockResp: createTestResponse(401, "unauthorized"),
			want:     "",
			wantErr:  true,
		},
		{
			name:     "large file handling",
			filename: "large.bin",
			content:  string(make([]byte, 10000)), // 10KB file
			mockResp: createTestResponse(200, `{
				"url": "https://bucket.s3.amazonaws.com",
				"fields": {"key": "large.bin"}
			}`),
			want:    "https://bucket.s3.amazonaws.com/large.bin",
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := DefaultConfig()
			client, err := New(cfg)
			if err != nil {
				t.Fatalf("New() error = %v", err)
			}
			defer client.Close()

			// Create mock HTTP client
			mockClient := NewMockHTTPClient()
			if tt.mockResp != nil {
				mockClient.AddResponse(tt.mockResp)
			}
			client.http = mockClient

			// Create temporary file if needed
			var filePath string
			if tt.filename != "" && !strings.HasPrefix(tt.filename, "/nonexistent") {
				filePath = filepath.Join(tmpDir, tt.filename)
				if err := os.WriteFile(filePath, []byte(tt.content), 0644); err != nil {
					t.Fatalf("Failed to create test file: %v", err)
				}
				defer os.Remove(filePath)
			} else {
				filePath = tt.filename
			}

			got, err := client.UploadFile(filePath)

			if (err != nil) != tt.wantErr {
				t.Errorf("UploadFile() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr && got != tt.want {
				t.Errorf("UploadFile() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestClientUploadBytes(t *testing.T) {
	tests := []struct {
		name      string
		data      []byte
		filename  string
		contentTy string
		mockResp  *http.Response
		mockErr   error
		want      string
		wantErr   bool
	}{
		{
			name:      "successful upload with image",
			data:      []byte("image data"),
			filename:  "photo.jpg",
			contentTy: "image/jpeg",
			mockResp: createTestResponse(200, `{
				"url": "https://photos.s3.us-west-2.amazonaws.com",
				"fields": {
					"key": "uploads/photo.jpg",
					"bucket": "photos",
					"region": "us-west-2"
				},
				"final_url": "https://photos.s3.us-west-2.amazonaws.com/uploads/photo.jpg"
			}`),
			want:    "https://s3.us-west-2.amazonaws.com/photos/uploads/photo.jpg",
			wantErr: false,
		},
		{
			name:      "successful upload with JSON",
			data:      []byte(`{"key": "value"}`),
			filename:  "data.json",
			contentTy: "application/json",
			mockResp: createTestResponse(200, `{
				"url": "https://data-bucket.s3.amazonaws.com",
				"fields": {"key": "data.json"}
			}`),
			want:    "https://data-bucket.s3.amazonaws.com/data.json",
			wantErr: false,
		},
		{
			name:    "upload URL request network error",
			data:    []byte("test"),
			filename: "test.txt",
			contentTy: "text/plain",
			mockErr: fmt.Errorf("network error"),
			want:    "",
			wantErr: true,
		},
		{
			name:      "upload URL request HTTP error",
			data:      []byte("test"),
			filename:  "test.txt",
			contentTy: "text/plain",
			mockResp: createTestResponse(400, "bad request"),
			want:      "",
			wantErr:   true,
		},
		{
			name:      "invalid JSON response",
			data:      []byte("test"),
			filename:  "test.txt",
			contentTy: "text/plain",
			mockResp: createTestResponse(200, "invalid json"),
			want:      "",
			wantErr:   true,
		},
		{
			name:      "large byte array upload",
			data:      make([]byte, 50000), // 50KB
			filename:  "large.bin",
			contentTy: "application/octet-stream",
			mockResp: createTestResponse(200, `{
				"url": "https://bucket.s3.amazonaws.com",
				"fields": {"key": "large.bin"}
			}`),
			want:    "https://bucket.s3.amazonaws.com/large.bin",
			wantErr: false,
		},
		{
			name:      "empty filename",
			data:      []byte("test"),
			filename:  "",
			contentTy: "application/octet-stream",
			mockResp: createTestResponse(200, `{
				"url": "https://bucket.s3.amazonaws.com",
				"fields": {"key": "unnamed"}
			}`),
			want:    "https://bucket.s3.amazonaws.com/unnamed",
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := DefaultConfig()
			client, err := New(cfg)
			if err != nil {
				t.Fatalf("New() error = %v", err)
			}
			defer client.Close()

			// Create mock HTTP client
			mockClient := NewMockHTTPClient()
			if tt.mockResp != nil {
				mockClient.AddResponse(tt.mockResp)
			}
			if tt.mockErr != nil {
				mockClient.AddError(tt.mockErr)
			}
			client.http = mockClient

			got, err := client.UploadBytes(tt.data, tt.filename, tt.contentTy)

			if (err != nil) != tt.wantErr {
				t.Errorf("UploadBytes() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr && got != tt.want {
				t.Errorf("UploadBytes() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestClientUploadToS3(t *testing.T) {
	tests := []struct {
		name         string
		upload       models.UploadURLResponse
		data         []byte
		filename     string
		contentType  string
		mockHTTP     func(*http.Response, error)
		want         string
		wantErr      bool
	}{
		{
			name: "successful upload with 204 status",
			upload: models.UploadURLResponse{
				URL:      "https://bucket.s3.amazonaws.com",
				Fields:   map[string]string{"key": "test.png"},
				FinalURL: "https://bucket.s3.amazonaws.com/test.png",
			},
			data:        []byte("image data"),
			filename:    "test.png",
			contentType: "image/png",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return &http.Response{
					StatusCode: 204,
					Body:       io.NopCloser(strings.NewReader("")),
				}, nil
			},
			want:    "https://bucket.s3.amazonaws.com/test.png",
			wantErr: false,
		},
		{
			name: "successful upload with 200 status",
			upload: models.UploadURLResponse{
				URL:      "https://bucket.s3.amazonaws.com",
				Fields:   map[string]string{"key": "docs/document.pdf"},
				FinalURL: "",
			},
			data:        []byte("PDF data"),
			filename:    "document.pdf",
			contentType: "application/pdf",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return &http.Response{
					StatusCode: 200,
					Body:       io.NopCloser(strings.NewReader("OK")),
				}, nil
			},
			want:    "https://bucket.s3.amazonaws.com/docs/document.pdf",
			wantErr: false,
		},
		{
			name: "successful upload with 201 status",
			upload: models.UploadURLResponse{
				URL:      "https://mybucket.s3.eu-west-1.amazonaws.com/",
				Fields:   map[string]string{"key": "files/data.json"},
				FinalURL: "",
			},
			data:        []byte(`{"test": "data"}`),
			filename:    "data.json",
			contentType: "application/json",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return &http.Response{
					StatusCode: 201,
					Body:       io.NopCloser(strings.NewReader("Created")),
				}, nil
			},
			want:    "https://mybucket.s3.eu-west-1.amazonaws.com/files/data.json",
			wantErr: false,
		},
		{
			name: "S3 upload fails with 400 status",
			upload: models.UploadURLResponse{
				URL:    "https://bucket.s3.amazonaws.com",
				Fields: map[string]string{"key": "test.txt"},
			},
			data:        []byte("data"),
			filename:    "test.txt",
			contentType: "text/plain",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return &http.Response{
					StatusCode: 400,
					Body:       io.NopCloser(strings.NewReader("Bad Request")),
				}, nil
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "S3 upload fails with 403 status",
			upload: models.UploadURLResponse{
				URL:    "https://bucket.s3.amazonaws.com",
				Fields: map[string]string{"key": "test.txt"},
			},
			data:        []byte("data"),
			filename:    "test.txt",
			contentType: "text/plain",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return &http.Response{
					StatusCode: 403,
					Body:       io.NopCloser(strings.NewReader("Forbidden")),
				}, nil
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "S3 upload fails with 500 status",
			upload: models.UploadURLResponse{
				URL:    "https://bucket.s3.amazonaws.com",
				Fields: map[string]string{"key": "test.txt"},
			},
			data:        []byte("data"),
			filename:    "test.txt",
			contentType: "text/plain",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return &http.Response{
					StatusCode: 500,
					Body:       io.NopCloser(strings.NewReader("Internal Server Error")),
				}, nil
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "S3 upload network error",
			upload: models.UploadURLResponse{
				URL:    "https://bucket.s3.amazonaws.com",
				Fields: map[string]string{"key": "test.txt"},
			},
			data:        []byte("data"),
			filename:    "test.txt",
			contentType: "text/plain",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return nil, fmt.Errorf("network error")
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "multipart form creation error",
			upload: models.UploadURLResponse{
				URL: "https://bucket.s3.amazonaws.com",
				Fields: map[string]string{
					"key":     "test.txt",
					"invalid": string(bytes.Repeat([]byte("x"), 1000000)), // Very large value might cause issues
				},
			},
			data:        []byte("data"),
			filename:    "test.txt",
			contentType: "text/plain",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				// This test validates the multipart form is created properly
				return &http.Response{
					StatusCode: 204,
					Body:       io.NopCloser(strings.NewReader("")),
				}, nil
			},
			want:    "https://bucket.s3.amazonaws.com/test.txt",
			wantErr: false,
		},
		{
			name: "empty Fields map",
			upload: models.UploadURLResponse{
				URL:      "https://bucket.s3.amazonaws.com",
				Fields:   map[string]string{},
				FinalURL: "https://custom.url/test.txt",
			},
			data:        []byte("data"),
			filename:    "test.txt",
			contentType: "text/plain",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return &http.Response{
					StatusCode: 204,
					Body:       io.NopCloser(strings.NewReader("")),
				}, nil
			},
			want:    "https://custom.url/test.txt",
			wantErr: false,
		},
		{
			name: "image URL rewriting",
			upload: models.UploadURLResponse{
				URL:      "https://mybucket.s3.us-east-1.amazonaws.com",
				Fields:   map[string]string{"key": "images/photo.jpg"},
				FinalURL: "",
			},
			data:        []byte("image data"),
			filename:    "photo.jpg",
			contentType: "image/jpeg",
			mockHTTP: func(resp *http.Response, err error) (*http.Response, error) {
				return &http.Response{
					StatusCode: 204,
					Body:       io.NopCloser(strings.NewReader("")),
				}, nil
			},
			want:    "https://s3.us-east-1.amazonaws.com/mybucket/images/photo.jpg",
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := DefaultConfig()
			client, err := New(cfg)
			if err != nil {
				t.Fatalf("New() error = %v", err)
			}
			defer client.Close()

			// For uploadToS3, we need to mock the standard http.Client
			// We can't directly mock it, but we can test the logic by checking the behavior
			// For tests that require HTTP mocking, we'll skip the actual S3 request
			if tt.mockHTTP != nil {
				// We need to intercept the actual HTTP call
				// Since uploadToS3 uses http.NewRequest and http.Client, we can't easily mock it
				// Instead, we test that the function handles the upload URL properly
			}

			// Call the unexported method via a workaround
			// We need to use a test that verifies the public methods work correctly
			// For uploadToS3 specifically, we'll test through UploadBytes or UploadFile

			// Test by calling UploadBytes which calls uploadToS3 internally
			mockClient := &mockHTTPClient{}
			mockClient.PostFunc = func(path string, body []byte) (*http.Response, error) {
				// Return the upload URL
				resp := &http.Response{
					StatusCode: 200,
					Body: io.NopCloser(strings.NewReader(fmt.Sprintf(`{
						"url": %q,
						"fields": %v,
						"final_url": %q
					}`, tt.upload.URL, tt.upload.Fields, tt.upload.FinalURL))),
				}
				return resp, nil
			}
			client.http = mockClient

			// Use UploadBytes to trigger uploadToS3
			got, err := client.UploadBytes(tt.data, tt.filename, tt.contentType)

			if (err != nil) != tt.wantErr {
				t.Errorf("UploadBytes() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr && got != tt.want {
				t.Errorf("UploadBytes() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestClientUploadFileCounting(t *testing.T) {
	cfg := DefaultConfig()
	client, err := New(cfg)
	if err != nil {
		t.Fatalf("New() error = %v", err)
	}
	defer client.Close()

	mockClient := &mockHTTPClient{}
	mockClient.PostFunc = func(path string, body []byte) (*http.Response, error) {
		return &http.Response{
			StatusCode: 200,
			Body: io.NopCloser(strings.NewReader(`{
				"url": "https://bucket.s3.amazonaws.com",
				"fields": {"key": "test.txt"}
			}`)),
		}, nil
	}
	client.http = mockClient

	// Create a temporary file
	tmpDir := t.TempDir()
	filePath := filepath.Join(tmpDir, "test.txt")
	if err := os.WriteFile(filePath, []byte("test data"), 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Upload file multiple times
	for i := 1; i <= 3; i++ {
		_, err := client.UploadFile(filePath)
		if err != nil {
			t.Errorf("Upload %d failed: %v", i, err)
		}
	}

	// Check file upload count
	if client.fileUploads != 3 {
		t.Errorf("fileUploads = %d, want 3", client.fileUploads)
	}

	// Check remaining uploads
	remaining := client.FileUploadsRemaining()
	if remaining != 7 {
		t.Errorf("FileUploadsRemaining() = %d, want 7", remaining)
	}
}
</file>
<file path="pkg/models/request.go">
package models

// SearchParams represents the nested parameters in a search request.
type SearchParams struct {
	Version            string       `json:"version"`
	Source             string       `json:"source"`
	FrontendSessionID  string       `json:"frontend_session_id,omitempty"`
	Language           string       `json:"language"`
	Timezone           string       `json:"timezone"`
	SearchFocus        string       `json:"search_focus"`
	FrontendUUID       string       `json:"frontend_uuid,omitempty"`
	GptUUID            string       `json:"gpt_uuid,omitempty"`
	ConversationMode   string       `json:"conversation_mode,omitempty"`
	Mode               string       `json:"mode"`
	IsIncognito        bool         `json:"is_incognito"`
	InPage             string       `json:"in_page,omitempty"`
	ModelPreference    *string      `json:"model_preference,omitempty"`
	IsProReasoningMode bool         `json:"is_pro_reasoning_mode,omitempty"`
	Sources            []string     `json:"sources,omitempty"`
	Attachments        []Attachment `json:"attachments,omitempty"`
	BackendUUID        string       `json:"backend_uuid,omitempty"`
	ReadWriteToken     *string      `json:"read_write_token,omitempty"`
	FunctioningMode    string       `json:"functioning_mode,omitempty"`
	UseInhouseModel    bool         `json:"use_inhouse_model,omitempty"`
	DslQuery           string       `json:"dsl_query"`
}

// SearchRequest represents the payload for a Perplexity search query.
type SearchRequest struct {
	Params   SearchParams `json:"params"`
	QueryStr string       `json:"query_str"`
}

// Attachment represents a file attachment in the request.
type Attachment struct {
	URL          string `json:"url"`
	ContentType  string `json:"content_type,omitempty"`
	Name         string `json:"name,omitempty"`
	Size         int64  `json:"size,omitempty"`
}

// SearchOptions contains user-configurable search parameters.
type SearchOptions struct {
	Query       string
	Mode        Mode
	Model       Model
	Sources     []Source
	Language    string
	Incognito   bool
	Stream      bool
	Attachments []string
	FollowUp    *FollowUpContext
}

// FollowUpContext contains context for follow-up queries.
type FollowUpContext struct {
	BackendUUID  string
	Attachments  []Attachment
}

// DefaultSearchOptions returns options with sensible defaults.
func DefaultSearchOptions(query string) SearchOptions {
	return SearchOptions{
		Query:     query,
		Mode:      ModeDefault,
		Model:     ModelPplxPro,
		Sources:   []Source{SourceWeb},
		Language:  "en-US",
		Incognito: false,
		Stream:    true,
	}
}

// UploadURLRequest represents a request to get an upload URL.
type UploadURLRequest struct {
	Filename    string `json:"filename"`
	ContentType string `json:"content_type"`
}

// UploadURLResponse contains the S3 upload URL and fields.
type UploadURLResponse struct {
	URL        string            `json:"url"`
	Fields     map[string]string `json:"fields"`
	FinalURL   string            `json:"final_url,omitempty"`
}
</file>
<file path="pkg/models/request_test.go">
package models

import "testing"

func TestDefaultSearchOptions(t *testing.T) {
	query := "test query"
	opts := DefaultSearchOptions(query)

	if opts.Query != query {
		t.Errorf("Query = %q, want %q", opts.Query, query)
	}
	if opts.Mode != ModeDefault {
		t.Errorf("Mode = %q, want %q", opts.Mode, ModeDefault)
	}
	if opts.Model != ModelPplxPro {
		t.Errorf("Model = %q, want %q", opts.Model, ModelPplxPro)
	}
	if len(opts.Sources) != 1 || opts.Sources[0] != SourceWeb {
		t.Errorf("Sources = %v, want [web]", opts.Sources)
	}
	if opts.Language != "en-US" {
		t.Errorf("Language = %q, want %q", opts.Language, "en-US")
	}
	if opts.Incognito {
		t.Error("Incognito should be false by default")
	}
	if !opts.Stream {
		t.Error("Stream should be true by default")
	}
}

func TestSearchRequestJSON(t *testing.T) {
	req := SearchRequest{
		Params: SearchParams{
			Version:  "2.18",
			Source:   "default",
			Language: "en-US",
			Mode:     "copilot",
		},
		QueryStr: "test",
	}

	if req.Params.Version != "2.18" {
		t.Errorf("Params.Version = %q, want %q", req.Params.Version, "2.18")
	}
	if req.QueryStr != "test" {
		t.Errorf("QueryStr = %q, want %q", req.QueryStr, "test")
	}
	if req.Params.Language != "en-US" {
		t.Errorf("Params.Language = %q, want %q", req.Params.Language, "en-US")
	}
	if req.Params.Mode != "copilot" {
		t.Errorf("Params.Mode = %q, want %q", req.Params.Mode, "copilot")
	}
}

func TestAttachment(t *testing.T) {
	att := Attachment{
		URL:         "https://example.com/file.pdf",
		ContentType: "application/pdf",
		Name:        "file.pdf",
		Size:        1024,
	}

	if att.URL != "https://example.com/file.pdf" {
		t.Errorf("URL = %q, want %q", att.URL, "https://example.com/file.pdf")
	}
	if att.ContentType != "application/pdf" {
		t.Errorf("ContentType = %q, want %q", att.ContentType, "application/pdf")
	}
	if att.Size != 1024 {
		t.Errorf("Size = %d, want %d", att.Size, 1024)
	}
}

func TestFollowUpContext(t *testing.T) {
	ctx := FollowUpContext{
		BackendUUID: "test-uuid-123",
		Attachments: []Attachment{
			{URL: "https://example.com/file.pdf"},
		},
	}

	if ctx.BackendUUID != "test-uuid-123" {
		t.Errorf("BackendUUID = %q, want %q", ctx.BackendUUID, "test-uuid-123")
	}
	if len(ctx.Attachments) != 1 {
		t.Errorf("len(Attachments) = %d, want 1", len(ctx.Attachments))
	}
}

func TestUploadURLRequest(t *testing.T) {
	req := UploadURLRequest{
		Filename:    "test.pdf",
		ContentType: "application/pdf",
	}

	if req.Filename != "test.pdf" {
		t.Errorf("Filename = %q, want %q", req.Filename, "test.pdf")
	}
	if req.ContentType != "application/pdf" {
		t.Errorf("ContentType = %q, want %q", req.ContentType, "application/pdf")
	}
}
</file>
<file path="pkg/models/response.go">
package models

import "time"

// SearchResponse represents a complete response from Perplexity.
type SearchResponse struct {
	Text         string          `json:"text"`
	BackendUUID  string          `json:"backend_uuid,omitempty"`
	Blocks       []ResponseBlock `json:"blocks,omitempty"`
	Attachments  []Attachment    `json:"attachments,omitempty"`
	FinishReason string          `json:"finish_reason,omitempty"`
	WebResults   []WebResult     `json:"web_results,omitempty"`
}

// SSEStep represents a step in the SSE stream response.
type SSEStep struct {
	StepType string      `json:"step_type"`
	Content  interface{} `json:"content"`
	UUID     string      `json:"uuid,omitempty"`
}

// FinalContent represents the content of a FINAL step.
type FinalContent struct {
	Answer string `json:"answer"`
}

// FinalAnswer represents the parsed answer JSON from a FINAL step.
type FinalAnswer struct {
	Answer           string      `json:"answer"`
	WebResults       []WebResult `json:"web_results,omitempty"`
	Chunks           []string    `json:"chunks,omitempty"`
	ExtraWebResults  []WebResult `json:"extra_web_results,omitempty"`
	StructuredAnswer []string    `json:"structured_answer,omitempty"`
}

// WebResult represents a web search result from the API.
type WebResult struct {
	Name      string                 `json:"name,omitempty"`
	URL       string                 `json:"url"`
	Snippet   string                 `json:"snippet,omitempty"`
	Title     string                 `json:"title,omitempty"`
	MetaData  map[string]interface{} `json:"meta_data,omitempty"`
	SiteLinks []interface{}          `json:"sitelinks,omitempty"`
}

// SearchResultsContent represents SEARCH_RESULTS step content.
type SearchResultsContent struct {
	GoalID     string      `json:"goal_id,omitempty"`
	WebResults []WebResult `json:"web_results,omitempty"`
}

// ResponseBlock represents a block in the response.
type ResponseBlock struct {
	MarkdownBlock      *MarkdownBlock      `json:"markdown_block,omitempty"`
	PlanBlock          *PlanBlock          `json:"plan_block,omitempty"`
	ReasoningPlanBlock *ReasoningPlanBlock `json:"reasoning_plan_block,omitempty"`
	WebSearchResults   *WebSearchResults   `json:"web_search_results,omitempty"`
}

// MarkdownBlock contains the main answer with citations.
type MarkdownBlock struct {
	Answer    string     `json:"answer"`
	Citations []Citation `json:"citations,omitempty"`
}

// Citation represents a source citation.
type Citation struct {
	URL         string `json:"url"`
	Title       string `json:"title,omitempty"`
	Snippet     string `json:"snippet,omitempty"`
	Favicon     string `json:"favicon,omitempty"`
	SiteName    string `json:"site_name,omitempty"`
	PublishedAt string `json:"published_at,omitempty"`
}

// PlanBlock represents an execution plan (mode='default').
type PlanBlock struct {
	Steps []PlanStep `json:"steps,omitempty"`
}

// PlanStep represents a step in the execution plan.
type PlanStep struct {
	Description string `json:"description"`
	Status      string `json:"status,omitempty"`
}

// ReasoningPlanBlock represents step-by-step reasoning (deep-research).
type ReasoningPlanBlock struct {
	Reasoning []ReasoningStep `json:"reasoning,omitempty"`
}

// ReasoningStep represents a reasoning step.
type ReasoningStep struct {
	Thought string `json:"thought"`
	Action  string `json:"action,omitempty"`
	Result  string `json:"result,omitempty"`
}

// WebSearchResults contains search results from various sources.
type WebSearchResults struct {
	Results []WebSearchResult `json:"results,omitempty"`
}

// WebSearchResult represents a single search result.
type WebSearchResult struct {
	URL         string `json:"url"`
	Title       string `json:"title"`
	Snippet     string `json:"snippet,omitempty"`
	Favicon     string `json:"favicon,omitempty"`
	Source      string `json:"source,omitempty"`
	PublishedAt string `json:"published_at,omitempty"`
}

// StreamChunk represents a chunk of streaming response.
type StreamChunk struct {
	Text        string          `json:"text,omitempty"`
	Delta       string          `json:"delta,omitempty"`
	BackendUUID string          `json:"backend_uuid,omitempty"`
	Blocks      []ResponseBlock `json:"blocks,omitempty"`
	Done        bool            `json:"done,omitempty"`
	Error       error           `json:"-"`
	// New step-based fields
	StepType   string      `json:"step_type,omitempty"`
	WebResults []WebResult `json:"web_results,omitempty"`
	Chunks     []string    `json:"chunks,omitempty"`
}

// HistoryEntry represents a query in the history file.
type HistoryEntry struct {
	Timestamp   time.Time `json:"timestamp"`
	Query       string    `json:"query"`
	Mode        string    `json:"mode"`
	Model       string    `json:"model,omitempty"`
	Response    string    `json:"response,omitempty"`
	BackendUUID string    `json:"backend_uuid,omitempty"`
}
</file>
<file path="pkg/models/types.go">
// Package models defines data structures for Perplexity API requests and responses.
package models

// Mode represents the search mode for Perplexity queries.
type Mode string

const (
	ModeFast         Mode = "fast"
	ModePro          Mode = "pro"
	ModeReasoning    Mode = "reasoning"
	ModeDeepResearch Mode = "deep-research"
	ModeDefault      Mode = "default"
)

// Model represents available AI models.
type Model string

// Pro mode models
const (
	ModelPplxPro            Model = "pplx_pro"
	ModelGPT51              Model = "gpt51"
	ModelGrok41NonReasoning Model = "grok41nonreasoning"
	ModelExperimental       Model = "experimental"
	ModelClaude45Sonnet     Model = "claude45sonnet"
)

// Reasoning mode models
const (
	ModelGemini30Pro         Model = "gemini30pro"
	ModelGPT51Thinking       Model = "gpt51_thinking"
	ModelGrok41Reasoning     Model = "grok41reasoning"
	ModelKimiK2Thinking      Model = "kimik2thinking"
	ModelClaude45SonnetThink Model = "claude45sonnetthinking"
)

// Source represents search sources.
type Source string

const (
	SourceWeb     Source = "web"
	SourceScholar Source = "scholar"
	SourceSocial  Source = "social"
)

// AvailableProModels contains models available for Pro mode.
var AvailableProModels = []Model{
	ModelPplxPro,
	ModelGPT51,
	ModelGrok41NonReasoning,
	ModelExperimental,
	ModelClaude45Sonnet,
}

// AvailableReasoningModels contains models available for Reasoning mode.
var AvailableReasoningModels = []Model{
	ModelGemini30Pro,
	ModelGPT51Thinking,
	ModelGrok41Reasoning,
	ModelKimiK2Thinking,
	ModelClaude45SonnetThink,
}

// AvailableModels contains all valid model names.
var AvailableModels = append(AvailableProModels, AvailableReasoningModels...)

// AvailableSources contains all valid source names.
var AvailableSources = []Source{
	SourceWeb,
	SourceScholar,
	SourceSocial,
}

// IsValidModel checks if a model name is valid.
func IsValidModel(m Model) bool {
	for _, valid := range AvailableModels {
		if m == valid {
			return true
		}
	}
	return false
}

// IsValidSource checks if a source name is valid.
func IsValidSource(s Source) bool {
	for _, valid := range AvailableSources {
		if s == valid {
			return true
		}
	}
	return false
}

// IsValidMode checks if a mode is valid.
func IsValidMode(m Mode) bool {
	switch m {
	case ModeFast, ModePro, ModeReasoning, ModeDeepResearch, ModeDefault:
		return true
	}
	return false
}
</file>
<file path="pkg/models/types_test.go">
package models

import "testing"

func TestIsValidModel(t *testing.T) {
	tests := []struct {
		name  string
		model Model
		want  bool
	}{
		// Pro models
		{"valid pplx_pro", ModelPplxPro, true},
		{"valid gpt51", ModelGPT51, true},
		{"valid grok41nonreasoning", ModelGrok41NonReasoning, true},
		{"valid experimental", ModelExperimental, true},
		{"valid claude45sonnet", ModelClaude45Sonnet, true},
		// Reasoning models
		{"valid gemini30pro", ModelGemini30Pro, true},
		{"valid gpt51_thinking", ModelGPT51Thinking, true},
		{"valid grok41reasoning", ModelGrok41Reasoning, true},
		{"valid kimik2thinking", ModelKimiK2Thinking, true},
		{"valid claude45sonnetthinking", ModelClaude45SonnetThink, true},
		// Invalid
		{"invalid model", Model("invalid_model"), false},
		{"empty model", Model(""), false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := IsValidModel(tt.model)
			if got != tt.want {
				t.Errorf("IsValidModel(%q) = %v, want %v", tt.model, got, tt.want)
			}
		})
	}
}

func TestIsValidSource(t *testing.T) {
	tests := []struct {
		name   string
		source Source
		want   bool
	}{
		{"valid web", SourceWeb, true},
		{"valid scholar", SourceScholar, true},
		{"valid social", SourceSocial, true},
		{"invalid source", Source("invalid"), false},
		{"empty source", Source(""), false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := IsValidSource(tt.source)
			if got != tt.want {
				t.Errorf("IsValidSource(%q) = %v, want %v", tt.source, got, tt.want)
			}
		})
	}
}

func TestIsValidMode(t *testing.T) {
	tests := []struct {
		name string
		mode Mode
		want bool
	}{
		{"valid fast", ModeFast, true},
		{"valid pro", ModePro, true},
		{"valid reasoning", ModeReasoning, true},
		{"valid deep-research", ModeDeepResearch, true},
		{"valid default", ModeDefault, true},
		{"invalid mode", Mode("invalid"), false},
		{"empty mode", Mode(""), false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := IsValidMode(tt.mode)
			if got != tt.want {
				t.Errorf("IsValidMode(%q) = %v, want %v", tt.mode, got, tt.want)
			}
		})
	}
}

func TestAvailableModels(t *testing.T) {
	expectedTotal := len(AvailableProModels) + len(AvailableReasoningModels)
	if len(AvailableModels) != expectedTotal {
		t.Errorf("Expected %d available models, got %d", expectedTotal, len(AvailableModels))
	}

	// Verify all models in the list are valid
	for _, m := range AvailableModels {
		if !IsValidModel(m) {
			t.Errorf("Model %q in AvailableModels is not valid", m)
		}
	}
}

func TestAvailableProModels(t *testing.T) {
	if len(AvailableProModels) != 5 {
		t.Errorf("Expected 5 pro models, got %d", len(AvailableProModels))
	}

	expectedModels := []Model{
		ModelPplxPro,
		ModelGPT51,
		ModelGrok41NonReasoning,
		ModelExperimental,
		ModelClaude45Sonnet,
	}

	for i, m := range AvailableProModels {
		if m != expectedModels[i] {
			t.Errorf("AvailableProModels[%d] = %q, want %q", i, m, expectedModels[i])
		}
	}
}

func TestAvailableReasoningModels(t *testing.T) {
	if len(AvailableReasoningModels) != 5 {
		t.Errorf("Expected 5 reasoning models, got %d", len(AvailableReasoningModels))
	}

	expectedModels := []Model{
		ModelGemini30Pro,
		ModelGPT51Thinking,
		ModelGrok41Reasoning,
		ModelKimiK2Thinking,
		ModelClaude45SonnetThink,
	}

	for i, m := range AvailableReasoningModels {
		if m != expectedModels[i] {
			t.Errorf("AvailableReasoningModels[%d] = %q, want %q", i, m, expectedModels[i])
		}
	}
}

func TestAvailableSources(t *testing.T) {
	if len(AvailableSources) != 3 {
		t.Errorf("Expected 3 available sources, got %d", len(AvailableSources))
	}

	expectedSources := []Source{SourceWeb, SourceScholar, SourceSocial}
	for i, s := range AvailableSources {
		if s != expectedSources[i] {
			t.Errorf("AvailableSources[%d] = %q, want %q", i, s, expectedSources[i])
		}
	}
}
</file>
<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Perplexity-go is a Go CLI and library for interacting with the Perplexity AI API. It provides Chrome TLS fingerprint spoofing via `tls-client`, SSE streaming response parsing, and terminal-rendered markdown output.

## Architecture

```
perplexity-go/
├── cmd/perplexity/     # CLI commands (Cobra)
│   ├── main.go         # Entry point
│   ├── root.go         # Main query command + flag handling
│   ├── config.go       # Interactive config menu (uses huh TUI)
│   ├── cookies.go      # Cookie management (import/status/clear/path)
│   ├── history.go      # Query history
│   └── version.go      # Version info
├── pkg/
│   ├── client/         # API client (exported)
│   │   ├── client.go   # Main client struct + Search methods
│   │   ├── http.go     # TLS-client wrapper with Chrome fingerprint
│   │   ├── search.go   # SSE parsing, payload building
│   │   └── upload.go   # S3 file upload
│   └── models/         # Data types (exported)
│       ├── types.go    # Mode, Model, Source enums
│       ├── request.go  # SearchRequest, SearchOptions
│       └── response.go # SearchResponse, StreamChunk, blocks
└── internal/
    ├── auth/           # Cookie loading (JSON/Netscape formats)
    ├── config/         # Viper-based config (~/.perplexity-cli/config.json)
    ├── history/        # JSONL history writer
    └── ui/             # Glamour/Lipgloss rendering + interactive config menu
```

### Key Dependencies
- `github.com/bogdanfinn/tls-client` + `fhttp`: Chrome TLS fingerprint impersonation
- `github.com/spf13/cobra` + `viper`: CLI framework and config
- `github.com/charmbracelet/glamour` + `lipgloss`: Terminal markdown rendering
- `github.com/charmbracelet/huh`: Interactive terminal UI forms

## Common Commands

```bash
# Build
make build                    # Build to ./build/perplexity
make build-release            # Optimized build with -s -w -trimpath

# Install
make install                  # System install (/usr/local/bin, requires sudo)
make install-user             # User install (~/.local/bin)

# Test
make test                     # Run all tests
make test-coverage            # With coverage summary
make test-coverage-html       # Generate HTML coverage report
go test ./pkg/client/... -v   # Run specific package tests
go test ./... -run TestName   # Run specific test

# Run directly
make run ARGS='"What is Go?"'
./build/perplexity "query" --model gpt51 --mode pro --stream
```

## API Implementation Details

### SSE Response Parsing (`pkg/client/search.go`)
- Delimiter: `\r\n\r\n` (also handles `\n\n`)
- Format: `event: message\r\ndata: {...json...}`
- Double JSON parsing: outer JSON has `text` field containing inner JSON with `blocks`
- Blocks: `markdown_block` (answer + citations), `web_search_results`

### Mode Mapping
| CLI Mode       | API mode   | model_preference |
|----------------|------------|------------------|
| fast           | concise    | turbo           |
| pro/default    | copilot    | (from model)    |
| reasoning      | copilot    | + is_pro_reasoning_mode=true |
| deep-research  | copilot    | pplx_alpha      |

**Special case:** `gpt51_thinking` model forces `concise` + `turbo` regardless of mode.

### Available Models

**Pro Mode:**
`pplx_pro`, `gpt51`, `grok41nonreasoning`, `experimental`, `claude45sonnet`

**Reasoning Mode:**
`gemini30pro`, `gpt51_thinking`, `grok41reasoning`, `kimik2thinking`, `claude45sonnetthinking`

### Configuration
- Config file: `~/.perplexity-cli/config.json`
- Cookie file: `~/.perplexity-cli/cookies.json`
- Environment prefix: `PERPLEXITY_` (e.g., `PERPLEXITY_DEFAULT_MODEL`)
- Language format: `xx-XX` (e.g., `en-US`, `pt-BR`)

## Cookie Authentication

Cookies must be exported from browser (JSON format via extension or Netscape format). Required cookie: `next-auth.csrf-token`.

```bash
perplexity import-cookies cookies.json  # Import cookies
perplexity cookies status               # Check authentication
perplexity cookies clear                # Clear saved cookies
perplexity cookies path                 # Show cookie file path
```

## Interactive Configuration

The `perplexity config` command opens an interactive menu to manage settings:

```bash
perplexity config                       # Open interactive config menu
perplexity config path                  # Show config file path
```

Configuration options available in the interactive menu:
- Model: Default AI model
- Mode: Search mode (fast, pro, reasoning, deep-research, default)
- Language: Response language
- Sources: Search sources (web, scholar, social)
- Streaming: Enable/disable streaming output
- Incognito: Enable/disable history saving

## Testing Notes

- Tests use table-driven patterns
- HTTP tests mock the tls-client
- Run `go test -race ./...` to check for race conditions
- Coverage target: 80% for new code
</file>
<file path="cookies.json">
[
  {
    "name": "pplx.visitor-id",
    "value": "2ecf4d3b-73e8-4c1b-bf9a-c41c6142cd78",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1795464708,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "g_state",
    "value": "{\"i_l\":0,\"i_ll\":1763928711009,\"i_b\":\"QV1d08MgfZBxy4f5AZ6luSH8l554YNa+4tivrO62lUE\"}",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1779480711,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "__ps_r",
    "value": "_",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1795464711,
    "httpOnly": false,
    "secure": true
  },
  {
    "name": "__ps_lu",
    "value": "https://www.perplexity.ai/?login-source=floatingSignup&login-new=false",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1795464711,
    "httpOnly": false,
    "secure": true
  },
  {
    "name": "__ps_fva",
    "value": "1763928711024",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1795464711,
    "httpOnly": false,
    "secure": true
  },
  {
    "name": "_gcl_au",
    "value": "1.1.1093573671.1763928711",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1771704711,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "_fbp",
    "value": "fb.1.1763928711250.876080601983491845",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1772344085,
    "httpOnly": false,
    "secure": false,
    "sameSite": "Lax"
  },
  {
    "name": "gov-badge",
    "value": "3",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1795479664,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "segmented-control-study",
    "value": "1",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1795479664,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "sidebar-upgrade-badge",
    "value": "10",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1795545628,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "__cflb",
    "value": "02DiuDyvFMmK5p9jVbVnMNSKYZhUL9aGmejsCp1aDDtqz",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1764583010.291393,
    "httpOnly": true,
    "secure": true
  },
  {
    "name": "pplx.is-student-referral-banner-dismissed",
    "value": "true",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1764845814,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "next-auth.csrf-token",
    "value": "00da54ca2d018ec5c30f549565c888eb9e4d728e6730433d75508841b843fa73%7C6433170b2ee515d8247c551f780039a358f84320848df7444fed35695d78ff52",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": -1,
    "httpOnly": true,
    "secure": true
  },
  {
    "name": "next-auth.callback-url",
    "value": "https%3A%2F%2Fwww.perplexity.ai%2Fapi%2Fauth%2Fsignin-callback%3Fredirect%3Dhttps%253A%252F%252Fwww.perplexity.ai",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": -1,
    "httpOnly": false,
    "secure": true
  },
  {
    "name": "pplx.session-id",
    "value": "a7bd9401-efd3-4e4a-b405-ca0b92686530",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1764568690,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "__cf_bm",
    "value": "rBnz7rUR8IcDAr1lJP9f2koc97W0sBEO2YKrka4d1Qo-1764568078-1.0.1.1-NRzP2wdYVm0wGJTaAZaO5FqyPyLOTL_SgPV7wqYpQikLEVIZd1XFBBIrro4rWOsiWfjWLHYc1NasGG8DqTT3rU5W9RJKo2JLt7Jueo_EQyE",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1764569878.867148,
    "httpOnly": true,
    "secure": true
  },
  {
    "name": "__Secure-next-auth.session-token",
    "value": "eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0..3M26YH7DCA32xNJP.6orR2-YTMyxJgofxC7Sb2WLqj3WoSGJ8xWjOTg_qpc4NE5548Lj4QLyU08uBVddAxqqVFPv1L9BeQ5oBqhUMc75DT52S75qu_WMeOtc5Yy6lXWOPk1HqpgoBdQl-pFHrrskufwSHC3QvoGfo4oo5BbR4RgByyIveGNRuREurfHMLz7ZWuIK_k9r0gKQxKtnscXRiut7n4Qsm3qid_pzeFmCdUMbjxbzngSrYtJLMkBc_H0S3DM8_972PkYvuSpJ42kaVOxBcgV8kAEQIw2eA_lBt9aY_ZFrhcYHFhGwN4hEu8OWBddkLO5rK384OfkK4l-dpPGMkqqRvgwtviplTwUsAQzl3WB-on1s0jAFI-8IWxAtWiG_8Ov0MU1IXtfHWd6xGeZib-6Td8NBunD_mOrz7mVlyk0mcjlewzFtbkYbjVHrHyqAQttc.gv0kuCTg4-uaRgsQzcxMjA",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1767160079.971553,
    "httpOnly": true,
    "secure": true,
    "sameSite": "Lax"
  },
  {
    "name": "__ps_sr",
    "value": "_",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1764569880,
    "httpOnly": false,
    "secure": true
  },
  {
    "name": "__ps_slu",
    "value": "https://www.perplexity.ai/?login-source=floatingSignup&login-new=false",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1764569880,
    "httpOnly": false,
    "secure": true
  },
  {
    "name": "_rdt_uuid",
    "value": "1763928711037.236480d1-e68d-4768-919a-34751b2abc95",
    "domain": ".perplexity.ai",
    "path": "/",
    "expires": 1772344080,
    "httpOnly": false,
    "secure": true,
    "sameSite": "Strict"
  },
  {
    "name": "pplx.metadata",
    "value": "{%22qc%22:28%2C%22qcu%22:924%2C%22qcm%22:145%2C%22qcc%22:730%2C%22qcco%22:0%2C%22qccol%22:0%2C%22qcdr%22:1%2C%22qcs%22:0%2C%22qcd%22:0%2C%22hli%22:true%2C%22hcga%22:false%2C%22hcds%22:false%2C%22hso%22:false%2C%22hfo%22:false%2C%22hsco%22:false%2C%22hfco%22:false%2C%22hsma%22:false%2C%22hdc%22:false%2C%22fqa%22:1763968350267%2C%22lqa%22:1764568084620}",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1799128088,
    "httpOnly": false,
    "secure": false
  },
  {
    "name": "_dd_s",
    "value": "aid=69906382-b859-410f-8de8-a010038d788e&rum=2&id=61a68616-acc2-4cc5-ad30-41090782f900&created=1764568079095&expire=1764568985443&logs=0",
    "domain": "www.perplexity.ai",
    "path": "/",
    "expires": 1796104085,
    "httpOnly": false,
    "secure": false,
    "sameSite": "Strict"
  }
]
</file>
<file path="coverage.html">

<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>perplexity: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/diogo/perplexity-go/cmd/perplexity/config.go (25.0%)</option>
				
				<option value="file1">github.com/diogo/perplexity-go/cmd/perplexity/cookies.go (84.9%)</option>
				
				<option value="file2">github.com/diogo/perplexity-go/cmd/perplexity/history.go (8.1%)</option>
				
				<option value="file3">github.com/diogo/perplexity-go/cmd/perplexity/main.go (0.0%)</option>
				
				<option value="file4">github.com/diogo/perplexity-go/cmd/perplexity/root.go (38.3%)</option>
				
				<option value="file5">github.com/diogo/perplexity-go/cmd/perplexity/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"

        "github.com/diogo/perplexity-go/internal/ui"
        "github.com/spf13/cobra"
)

var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Manage configuration interactively",
        Long: `Open an interactive menu to view and modify configuration settings.

Use arrow keys to navigate, Enter to select an option, and Esc to cancel.

Configuration options:
  - Model:     Default AI model (pplx_pro, gpt5, claude45sonnet, etc.)
  - Mode:      Search mode (fast, pro, reasoning, deep-research, default)
  - Language:  Response language (e.g., en-US, pt-BR)
  - Sources:   Search sources (web, scholar, social)
  - Streaming: Enable/disable streaming output
  - Incognito: Enable/disable history saving`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return ui.RunInteractiveConfig(cfg, cfgMgr)
        }</span>,
}

var configPathCmd = &amp;cobra.Command{
        Use:   "path",
        Short: "Show configuration file path",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                fmt.Println(cfgMgr.GetConfigFile())
                return nil
        }</span>,
}

func init() <span class="cov8" title="1">{
        configCmd.AddCommand(configPathCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/diogo/perplexity-go/internal/auth"
        "github.com/spf13/cobra"
)

var cookiesCmd = &amp;cobra.Command{
        Use:   "cookies",
        Short: "Manage authentication cookies",
        Long:  `Manage authentication cookies for Perplexity API access.`,
}

// importCookiesCmd is a root-level command for importing cookies.
var importCookiesCmd = &amp;cobra.Command{
        Use:   "import-cookies &lt;file&gt;",
        Short: "Import cookies from file",
        Long: `Import cookies from a JSON or Netscape format file.

Supported formats:
  - JSON: Browser extension export (cookies.json)
  - Netscape: curl/wget format (cookies.txt)

Example:
  perplexity import-cookies ~/Downloads/cookies.json`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                importFile := args[0]

                // Check if source file exists
                if _, err := os.Stat(importFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("file not found: %s", importFile)
                }</span>

                // Try JSON format first
                <span class="cov8" title="1">cookies, err := auth.LoadCookiesFromFile(importFile)
                if err != nil </span><span class="cov8" title="1">{
                        // Try Netscape format
                        cookies, err = auth.LoadCookiesFromNetscape(importFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse cookies (tried JSON and Netscape formats): %v", err)
                        }</span>
                }

                <span class="cov8" title="1">if len(cookies) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("no Perplexity cookies found in file")
                }</span>

                // Save to config cookie file
                <span class="cov8" title="1">if err := auth.SaveCookiesToFile(cookies, cfg.CookieFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save cookies: %v", err)
                }</span>

                <span class="cov8" title="1">render.RenderSuccess(fmt.Sprintf("Imported %d cookies to %s", len(cookies), cfg.CookieFile))

                if !auth.HasCSRFToken(cookies) </span><span class="cov8" title="1">{
                        render.RenderWarning("CSRF token not found - session may not work")
                }</span>

                <span class="cov8" title="1">return nil</span>
        },
}

var cookiesStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Check authentication status",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                cookieFile := cfg.CookieFile
                if flagCookieFile != "" </span><span class="cov0" title="0">{
                        cookieFile = flagCookieFile
                }</span>

                // Check if file exists
                <span class="cov8" title="1">if _, err := os.Stat(cookieFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        render.RenderWarning("Not authenticated")
                        render.RenderInfo(fmt.Sprintf("Cookie file not found: %s", cookieFile))
                        render.RenderInfo("Run 'perplexity import-cookies &lt;file&gt;' to import cookies")
                        return nil
                }</span>

                // Load and validate cookies
                <span class="cov8" title="1">cookies, err := auth.LoadCookiesFromFile(cookieFile)
                if err != nil </span><span class="cov0" title="0">{
                        render.RenderError(fmt.Errorf("failed to load cookies: %v", err))
                        return err
                }</span>

                <span class="cov8" title="1">if len(cookies) == 0 </span><span class="cov0" title="0">{
                        render.RenderWarning("No Perplexity cookies found in file")
                        return nil
                }</span>

                // Check for CSRF token
                <span class="cov8" title="1">if auth.HasCSRFToken(cookies) </span><span class="cov8" title="1">{
                        render.RenderSuccess("Authenticated")
                        fmt.Printf("Cookie file: %s\n", cookieFile)
                        fmt.Printf("Cookies loaded: %d\n", len(cookies))

                        // Show cookie names
                        fmt.Println("\nCookies:")
                        for _, c := range cookies </span><span class="cov8" title="1">{
                                fmt.Printf("  - %s\n", c.Name)
                        }</span>
                } else<span class="cov8" title="1"> {
                        render.RenderWarning("Cookies found but CSRF token missing")
                        render.RenderInfo("Session may be expired. Re-export cookies from browser.")
                }</span>

                <span class="cov8" title="1">return nil</span>
        },
}

var cookiesClearCmd = &amp;cobra.Command{
        Use:   "clear",
        Short: "Clear saved cookies",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if err := os.Remove(cfg.CookieFile); err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                render.RenderInfo("No cookies to clear")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to remove cookies: %v", err)</span>
                }

                <span class="cov8" title="1">render.RenderSuccess("Cookies cleared")
                return nil</span>
        },
}

var cookiesPathCmd = &amp;cobra.Command{
        Use:   "path",
        Short: "Show cookie file path",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                fmt.Println(cfg.CookieFile)
                return nil
        }</span>,
}

func init() <span class="cov8" title="1">{
        cookiesCmd.AddCommand(cookiesStatusCmd)
        cookiesCmd.AddCommand(cookiesClearCmd)
        cookiesCmd.AddCommand(cookiesPathCmd)

        // NOTE: importCookiesCmd is added to the rootCmd in root.go
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "strconv"

        "github.com/diogo/perplexity-go/internal/history"
        "github.com/spf13/cobra"
)

var (
        historyCount int
)

var historyCmd = &amp;cobra.Command{
        Use:   "history",
        Short: "View query history",
        Long:  `View and manage your query history.`,
        RunE:  runHistoryList,
}

var historyListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List recent queries",
        RunE:  runHistoryList,
}

var historySearchCmd = &amp;cobra.Command{
        Use:   "search &lt;query&gt;",
        Short: "Search history",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                reader := history.NewReader(cfg.HistoryFile)
                entries, err := reader.Search(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to search history: %v", err)
                }</span>

                <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                        render.RenderInfo("No matching entries found")
                        return nil
                }</span>

                <span class="cov0" title="0">render.RenderTitle(fmt.Sprintf("Search Results: %d matches", len(entries)))
                for i, entry := range entries </span><span class="cov0" title="0">{
                        fmt.Printf("[%d] %s\n", i+1, entry.Timestamp.Format("2006-01-02 15:04"))
                        fmt.Printf("    Query: %s\n", entry.Query)
                        fmt.Printf("    Mode: %s, Model: %s\n", entry.Mode, entry.Model)
                        fmt.Println()
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

var historyShowCmd = &amp;cobra.Command{
        Use:   "show &lt;index&gt;",
        Short: "Show details of a history entry",
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                idx, err := strconv.Atoi(args[0])
                if err != nil || idx &lt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid index: %s", args[0])
                }</span>

                <span class="cov0" title="0">reader := history.NewReader(cfg.HistoryFile)
                entries, err := reader.ReadAll()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read history: %v", err)
                }</span>

                <span class="cov0" title="0">if idx &gt; len(entries) </span><span class="cov0" title="0">{
                        return fmt.Errorf("index out of range: %d (max: %d)", idx, len(entries))
                }</span>

                <span class="cov0" title="0">entry := entries[idx-1]
                render.RenderTitle("History Entry")
                fmt.Printf("Timestamp: %s\n", entry.Timestamp.Format("2006-01-02 15:04:05"))
                fmt.Printf("Query:     %s\n", entry.Query)
                fmt.Printf("Mode:      %s\n", entry.Mode)
                fmt.Printf("Model:     %s\n", entry.Model)
                if entry.Response != "" </span><span class="cov0" title="0">{
                        fmt.Println("\nResponse:")
                        render.RenderStyledResponse(entry.Response)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

var historyClearCmd = &amp;cobra.Command{
        Use:   "clear",
        Short: "Clear all history",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                reader := history.NewReader(cfg.HistoryFile)
                if err := reader.Clear(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear history: %v", err)
                }</span>
                <span class="cov0" title="0">render.RenderSuccess("History cleared")
                return nil</span>
        },
}

func runHistoryList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        reader := history.NewReader(cfg.HistoryFile)

        var entries []any
        var err error

        if historyCount &gt; 0 </span><span class="cov0" title="0">{
                entries, err = readLastN(reader, historyCount)
        }</span> else<span class="cov0" title="0"> {
                entries, err = readLastN(reader, 20)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read history: %v", err)
        }</span>

        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                render.RenderInfo("No history entries")
                return nil
        }</span>

        <span class="cov0" title="0">render.RenderTitle("Recent Queries")
        for i, e := range entries </span><span class="cov0" title="0">{
                entry := e.(historyEntry)
                fmt.Printf("[%d] %s\n", i+1, entry.Timestamp)
                fmt.Printf("    %s\n", entry.Query)
                if entry.Mode != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    Mode: %s", entry.Mode)
                        if entry.Model != "" </span><span class="cov0" title="0">{
                                fmt.Printf(", Model: %s", entry.Model)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type historyEntry struct {
        Timestamp string
        Query     string
        Mode      string
        Model     string
}

func readLastN(reader *history.Reader, n int) ([]any, error) <span class="cov0" title="0">{
        entries, err := reader.ReadLast(n)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]any, len(entries))
        for i, e := range entries </span><span class="cov0" title="0">{
                result[i] = historyEntry{
                        Timestamp: e.Timestamp.Format("2006-01-02 15:04"),
                        Query:     e.Query,
                        Mode:      e.Mode,
                        Model:     e.Model,
                }
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func init() <span class="cov8" title="1">{
        historyCmd.AddCommand(historyListCmd)
        historyCmd.AddCommand(historySearchCmd)
        historyCmd.AddCommand(historyShowCmd)
        historyCmd.AddCommand(historyClearCmd)

        historyCmd.Flags().IntVarP(&amp;historyCount, "count", "n", 20, "Number of entries to show")
        historyListCmd.Flags().IntVarP(&amp;historyCount, "count", "n", 20, "Number of entries to show")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package main is the entry point for the perplexity CLI.
package main

import (
        "os"
)

func main() <span class="cov0" title="0">{
        if err := Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/diogo/perplexity-go/internal/auth"
        "github.com/mattn/go-isatty"
        "github.com/diogo/perplexity-go/internal/config"
        "github.com/diogo/perplexity-go/internal/history"
        "github.com/diogo/perplexity-go/internal/ui"
        "github.com/diogo/perplexity-go/pkg/client"
        "github.com/diogo/perplexity-go/pkg/models"
        "github.com/spf13/cobra"
)

var (
        // Flags
        flagModel      string
        flagMode       string
        flagSources    string
        flagLanguage   string
        flagStream     bool
        flagNoStream   bool
        flagIncognito  bool
        flagOutputFile string
        flagInputFile  string
        flagCookieFile string
        flagVerbose    bool

        // Global config
        cfg     *config.Config
        cfgMgr  *config.Manager
        render  *ui.Renderer
)

// rootCmd represents the base command.
var rootCmd = &amp;cobra.Command{
        Use:   "perplexity [query]",
        Short: "Perplexity AI CLI - Search with AI",
        Long: `Perplexity CLI is a command-line interface for Perplexity AI.

It allows you to perform AI-powered searches directly from your terminal
with support for multiple models, streaming output, and file attachments.

The query can be provided as command-line arguments, from a file (-f), or via stdin (pipe).

Examples:
  perplexity "What is the capital of France?"
  perplexity "Explain quantum computing" --model gpt5 --mode pro
  perplexity "Latest news on AI" --sources web,scholar --stream
  echo "What is Go?" | perplexity
  perplexity -f prompt.md --mode pro
  perplexity -f question.txt -o answer.md`,
        Args: cobra.ArbitraryArgs,
        RunE: runQuery,
}

// Execute runs the root command.
func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Query flags
        rootCmd.Flags().StringVarP(&amp;flagModel, "model", "m", "", "AI model to use (pplx_pro, gpt5, claude45sonnet, etc.)")
        rootCmd.Flags().StringVar(&amp;flagMode, "mode", "", "Search mode (fast, pro, reasoning, deep-research, default)")
        rootCmd.Flags().StringVarP(&amp;flagSources, "sources", "s", "", "Search sources (web,scholar,social)")
        rootCmd.Flags().StringVarP(&amp;flagLanguage, "language", "l", "", "Response language (e.g., en-US, pt-BR)")
        rootCmd.Flags().BoolVar(&amp;flagStream, "stream", false, "Enable streaming output")
        rootCmd.Flags().BoolVar(&amp;flagNoStream, "no-stream", false, "Disable streaming output")
        rootCmd.Flags().BoolVarP(&amp;flagIncognito, "incognito", "i", false, "Don't save to history")
        rootCmd.Flags().StringVarP(&amp;flagOutputFile, "output", "o", "", "Save response to file")
        rootCmd.Flags().StringVarP(&amp;flagInputFile, "file", "f", "", "Read query from file (takes precedence over args/stdin)")
        rootCmd.Flags().StringVarP(&amp;flagCookieFile, "cookies", "c", "", "Path to cookies.json file")
        rootCmd.Flags().BoolVarP(&amp;flagVerbose, "verbose", "v", false, "Verbose output")

        // Add subcommands
        rootCmd.AddCommand(configCmd)
        rootCmd.AddCommand(historyCmd)
        rootCmd.AddCommand(cookiesCmd)
        rootCmd.AddCommand(versionCmd)
        rootCmd.AddCommand(importCookiesCmd)
}</span>

func initConfig() <span class="cov0" title="0">{
        var err error

        // Initialize config manager
        cfgMgr, err = config.NewManager()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error initializing config: %v\n", err)
                os.Exit(1)
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err = cfgMgr.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                os.Exit(1)
        }</span>

        // Initialize renderer
        <span class="cov0" title="0">render, err = ui.NewRenderer()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error initializing renderer: %v\n", err)
                os.Exit(1)
        }</span>
}

func runQuery(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        var query string
        var err error

        // Priority: -f/--file &gt; args &gt; stdin
        // 1. Check if -f/--file flag is provided
        if flagInputFile != "" </span><span class="cov0" title="0">{
                query, err = getQueryFromFile(flagInputFile)
                if err != nil </span><span class="cov0" title="0">{
                        render.RenderError(err)
                        return err
                }</span>
        }

        // 2. If query is still empty, try args or stdin
        <span class="cov8" title="1">if query == "" </span><span class="cov8" title="1">{
                isTerminal := isatty.IsTerminal(os.Stdin.Fd()) || isatty.IsCygwinTerminal(os.Stdin.Fd())
                query, err = getQueryFromInput(args, os.Stdin, isTerminal)
                if err != nil </span><span class="cov0" title="0">{
                        render.RenderError(err)
                        return err
                }</span>
        }

        // If query is still empty, show help
        <span class="cov8" title="1">if query == "" </span><span class="cov8" title="1">{
                return cmd.Help()
        }</span>

        // Determine cookie file
        <span class="cov8" title="1">cookieFile := cfg.CookieFile
        if flagCookieFile != "" </span><span class="cov0" title="0">{
                cookieFile = flagCookieFile
        }</span>

        // Check if cookies exist
        <span class="cov8" title="1">if _, err := os.Stat(cookieFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                render.RenderError(fmt.Errorf("cookies file not found: %s", cookieFile))
                render.RenderInfo("Run 'perplexity import-cookies &lt;file&gt;' to import cookies from browser")
                return fmt.Errorf("no cookies found")
        }</span>

        // Load cookies
        <span class="cov0" title="0">cookies, err := auth.LoadCookiesFromFile(cookieFile)
        if err != nil </span><span class="cov0" title="0">{
                render.RenderError(fmt.Errorf("failed to load cookies: %v", err))
                return err
        }</span>

        // Create client
        <span class="cov0" title="0">cli, err := client.NewWithCookies(cookies)
        if err != nil </span><span class="cov0" title="0">{
                render.RenderError(fmt.Errorf("failed to create client: %v", err))
                return err
        }</span>
        <span class="cov0" title="0">defer cli.Close()

        // Build search options
        opts := buildSearchOptions(query)

        // Setup context with cancellation
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle interrupt
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-sigCh
                cancel()
        }</span>()

        // Determine if streaming
        <span class="cov0" title="0">streaming := cfg.Streaming
        if flagStream </span><span class="cov0" title="0">{
                streaming = true
        }</span>
        <span class="cov0" title="0">if flagNoStream </span><span class="cov0" title="0">{
                streaming = false
        }</span>
        <span class="cov0" title="0">opts.Stream = streaming

        if flagVerbose </span><span class="cov0" title="0">{
                render.RenderInfo(fmt.Sprintf("Query: %s", query))
                render.RenderInfo(fmt.Sprintf("Mode: %s, Model: %s", opts.Mode, opts.Model))
                render.RenderInfo(fmt.Sprintf("Streaming: %v", streaming))
                render.NewLine()
        }</span>

        <span class="cov0" title="0">var responseText string

        if streaming </span><span class="cov0" title="0">{
                // Streaming mode
                ch, err := cli.SearchStream(ctx, opts)
                if err != nil </span><span class="cov0" title="0">{
                        render.RenderError(err) // Render error from stream initiation
                        return err
                }</span>

                <span class="cov0" title="0">var fullResponse strings.Builder
                var allWebResults []models.WebResult
                for chunk := range ch </span><span class="cov0" title="0">{
                        if chunk.Error != nil </span><span class="cov0" title="0">{ // Handle all chunk errors
                                if chunk.Error == context.Canceled </span><span class="cov0" title="0">{
                                        render.NewLine()
                                        render.RenderWarning("Search cancelled")
                                        break</span> // Exit loop on cancel
                                }
                                // Report other errors
                                <span class="cov0" title="0">render.RenderError(chunk.Error)
                                return chunk.Error</span>
                        }

                        // For new step-based format, only render FINAL step
                        <span class="cov0" title="0">if chunk.StepType == "FINAL" &amp;&amp; chunk.Text != "" </span><span class="cov0" title="0">{
                                // Render as markdown instead of raw text
                                if err := render.RenderStyledResponse(chunk.Text); err != nil </span><span class="cov0" title="0">{
                                        render.RenderStreamChunk(chunk)
                                }</span>
                                <span class="cov0" title="0">fullResponse.WriteString(chunk.Text)
                                allWebResults = append(allWebResults, chunk.WebResults...)</span>
                        } else<span class="cov0" title="0"> if chunk.StepType == "" </span><span class="cov0" title="0">{
                                // Legacy format - render as stream
                                render.RenderStreamChunk(chunk)
                                if chunk.Delta != "" </span><span class="cov0" title="0">{
                                        fullResponse.WriteString(chunk.Delta)
                                }</span> else<span class="cov0" title="0"> if chunk.Text != "" </span><span class="cov0" title="0">{
                                        fullResponse.WriteString(chunk.Text)
                                }</span>
                        }
                }
                <span class="cov0" title="0">render.NewLine()

                // Post-stream rendering of the full accumulated response (with new styling/markdown)
                if fullResponse.Len() &gt; 0 </span><span class="cov0" title="0">{
                        if err := render.RenderStyledResponse(fullResponse.String()); err != nil </span><span class="cov0" title="0">{
                                // If final styled rendering fails, the raw stream output is still there.
                                render.RenderError(fmt.Errorf("failed to render final response: %w", err))
                        }</span>
                }

                // Render web results if any
                <span class="cov0" title="0">if len(allWebResults) &gt; 0 </span><span class="cov0" title="0">{
                        render.RenderWebResults(allWebResults)
                }</span>

                <span class="cov0" title="0">responseText = fullResponse.String()</span>
        } else<span class="cov0" title="0"> {
                // Non-streaming mode with spinner
                done := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        frame := 0
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-done:<span class="cov0" title="0">
                                        render.ClearLine()
                                        return</span>
                                case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0">
                                        render.RenderSpinner(frame)
                                        frame++</span>
                                }
                        }
                }()

                <span class="cov0" title="0">resp, err := cli.Search(ctx, opts)
                close(done)

                if err != nil </span><span class="cov0" title="0">{
                        if err == context.Canceled </span><span class="cov0" title="0">{
                                render.RenderWarning("Search cancelled")
                                return nil
                        }</span>
                        <span class="cov0" title="0">render.RenderError(err)
                        return err</span>
                }

                <span class="cov0" title="0">if err := render.RenderResponse(resp); err != nil </span><span class="cov0" title="0">{
                        render.RenderError(err)
                        return err
                }</span>
                <span class="cov0" title="0">responseText = resp.Text</span>
        }

        // Save to output file if specified
        <span class="cov0" title="0">if flagOutputFile != "" </span><span class="cov0" title="0">{
                if err := os.WriteFile(flagOutputFile, []byte(responseText), 0644); err != nil </span><span class="cov0" title="0">{
                        render.RenderError(fmt.Errorf("failed to save output: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        render.RenderSuccess(fmt.Sprintf("Saved to %s", flagOutputFile))
                }</span>
        }

        // Save to history if not incognito
        <span class="cov0" title="0">if !flagIncognito &amp;&amp; !cfg.Incognito </span><span class="cov0" title="0">{
                hw, err := history.NewWriter(cfg.HistoryFile)
                if err == nil </span><span class="cov0" title="0">{
                        hw.Append(models.HistoryEntry{
                                Query:    query,
                                Mode:     string(opts.Mode),
                                Model:    string(opts.Model),
                                Response: truncateResponse(responseText, 500),
                        })
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func buildSearchOptions(query string) models.SearchOptions <span class="cov8" title="1">{
        opts := models.DefaultSearchOptions(query)

        // Apply config defaults
        opts.Model = cfg.DefaultModel
        opts.Mode = cfg.DefaultMode
        opts.Language = cfg.DefaultLanguage
        opts.Sources = cfg.DefaultSources
        opts.Incognito = cfg.Incognito

        // Override with flags
        if flagModel != "" </span><span class="cov8" title="1">{
                opts.Model = models.Model(flagModel)
        }</span>
        <span class="cov8" title="1">if flagMode != "" </span><span class="cov8" title="1">{
                opts.Mode = models.Mode(flagMode)
        }</span>
        <span class="cov8" title="1">if flagLanguage != "" </span><span class="cov8" title="1">{
                opts.Language = flagLanguage
        }</span>
        <span class="cov8" title="1">if flagSources != "" </span><span class="cov8" title="1">{
                sources := strings.Split(flagSources, ",")
                opts.Sources = make([]models.Source, 0, len(sources))
                for _, s := range sources </span><span class="cov8" title="1">{
                        opts.Sources = append(opts.Sources, models.Source(strings.TrimSpace(s)))
                }</span>
        }
        <span class="cov8" title="1">if flagIncognito </span><span class="cov8" title="1">{
                opts.Incognito = true
        }</span>

        <span class="cov8" title="1">return opts</span>
}

func truncateResponse(s string, maxLen int) string <span class="cov8" title="1">{
        if len(s) &lt;= maxLen </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return s[:maxLen] + "..."</span>
}

// getQueryFromInput extracts the query from command-line args or stdin.
// This function is exported for testing purposes.
func getQueryFromInput(args []string, stdin io.Reader, isTerminal bool) (string, error) <span class="cov8" title="1">{
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                return strings.Join(args, " "), nil
        }</span>

        // If stdin is not a terminal, try to read from it
        <span class="cov8" title="1">if !isTerminal </span><span class="cov8" title="1">{
                data, err := io.ReadAll(stdin)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed to read from stdin: %w", err)
                }</span>
                <span class="cov8" title="1">return strings.TrimSpace(string(data)), nil</span>
        }

        <span class="cov8" title="1">return "", nil</span>
}

// getQueryFromFile reads the query content from a file.
// Returns the trimmed content or an error if the file cannot be read.
func getQueryFromFile(path string) (string, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to read input file %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">content := strings.TrimSpace(string(data))
        if content == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("input file %s is empty", path)
        }</span>
        <span class="cov8" title="1">return content, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "fmt"
        "runtime"

        "github.com/spf13/cobra"
)

// Version information (set via ldflags during build).
var (
        Version   = "1.0.0"
        GitCommit = "unknown"
        BuildDate = "unknown"
)

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print version information",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("perplexity %s\n", Version)
                fmt.Printf("  Git commit: %s\n", GitCommit)
                fmt.Printf("  Built:      %s\n", BuildDate)
                fmt.Printf("  Go version: %s\n", runtime.Version())
                fmt.Printf("  OS/Arch:    %s/%s\n", runtime.GOOS, runtime.GOARCH)
        }</span>,
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
</file>
<file path="go.mod">
module github.com/diogo/perplexity-go

go 1.25.4

require (
	github.com/bogdanfinn/fhttp v0.6.3
	github.com/bogdanfinn/tls-client v1.11.2
	github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7
	github.com/charmbracelet/glamour v0.10.0
	github.com/charmbracelet/huh v0.8.0
	github.com/charmbracelet/lipgloss v1.1.1-0.20250404203927-76690c660834
	github.com/google/uuid v1.6.0
	github.com/mattn/go-isatty v0.0.20
	github.com/spf13/cobra v1.10.1
	github.com/spf13/viper v1.21.0
)

require (
	github.com/alecthomas/chroma/v2 v2.14.0 // indirect
	github.com/andybalholm/brotli v1.1.1 // indirect
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/aymerick/douceur v0.2.0 // indirect
	github.com/bogdanfinn/quic-go-utls v1.0.4-utls // indirect
	github.com/bogdanfinn/utls v1.7.4-barnius // indirect
	github.com/catppuccin/go v0.3.0 // indirect
	github.com/charmbracelet/bubbletea v1.3.6 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.9.3 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13 // indirect
	github.com/charmbracelet/x/exp/slice v0.0.0-20250327172914-2fdc97757edf // indirect
	github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/cloudflare/circl v1.5.0 // indirect
	github.com/dlclark/regexp2 v1.11.0 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/fsnotify/fsnotify v1.9.0 // indirect
	github.com/go-viper/mapstructure/v2 v2.4.0 // indirect
	github.com/gorilla/css v1.0.1 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/klauspost/compress v1.17.11 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/microcosm-cc/bluemonday v1.0.27 // indirect
	github.com/mitchellh/hashstructure/v2 v2.0.2 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/reflow v0.3.0 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/quic-go/qpack v0.5.1 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/sagikazarmark/locafero v0.11.0 // indirect
	github.com/sourcegraph/conc v0.3.1-0.20240121214520-5f936abd7ae8 // indirect
	github.com/spf13/afero v1.15.0 // indirect
	github.com/spf13/cast v1.10.0 // indirect
	github.com/spf13/pflag v1.0.10 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/tam7t/hpkp v0.0.0-20160821193359-2b70b4024ed5 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	github.com/yuin/goldmark v1.7.8 // indirect
	github.com/yuin/goldmark-emoji v1.0.5 // indirect
	go.uber.org/mock v0.5.0 // indirect
	go.yaml.in/yaml/v3 v3.0.4 // indirect
	golang.org/x/crypto v0.40.0 // indirect
	golang.org/x/mod v0.26.0 // indirect
	golang.org/x/net v0.42.0 // indirect
	golang.org/x/sync v0.16.0 // indirect
	golang.org/x/sys v0.34.0 // indirect
	golang.org/x/term v0.33.0 // indirect
	golang.org/x/text v0.28.0 // indirect
	golang.org/x/tools v0.35.0 // indirect
)
</file>
<file path="go.sum">
github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=
github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=
github.com/alecthomas/assert/v2 v2.7.0 h1:QtqSACNS3tF7oasA8CU6A6sXZSBDqnm7RfpLl9bZqbE=
github.com/alecthomas/assert/v2 v2.7.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=
github.com/alecthomas/chroma/v2 v2.14.0 h1:R3+wzpnUArGcQz7fCETQBzO5n9IMNi13iIs46aU4V9E=
github.com/alecthomas/chroma/v2 v2.14.0/go.mod h1:QolEbTfmUHIMVpBqxeDnNBj2uoeI4EbYP4i6n68SG4I=
github.com/alecthomas/repr v0.4.0 h1:GhI2A8MACjfegCPVq9f1FLvIBS+DrQ2KQBFZP1iFzXc=
github.com/alecthomas/repr v0.4.0/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=
github.com/andybalholm/brotli v1.1.1 h1:PR2pgnyFznKEugtsUo0xLdDop5SKXd5Qf5ysW+7XdTA=
github.com/andybalholm/brotli v1.1.1/go.mod h1:05ib4cKhjx3OQYUY22hTVd34Bc8upXjOLL2rKwwZBoA=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.3.1 h1:LV+qyBQ2pqe0u42ZsUEtPiCaUoqgA9gYRDs3vj1nolY=
github.com/aymanbagabas/go-udiff v0.3.1/go.mod h1:G0fsKmG+P6ylD0r6N/KgQD/nWzgfnl8ZBcNLgcbrw8E=
github.com/aymerick/douceur v0.2.0 h1:Mv+mAeH1Q+n9Fr+oyamOlAkUNPWPlA8PPGR0QAaYuPk=
github.com/aymerick/douceur v0.2.0/go.mod h1:wlT5vV2O3h55X9m7iVYN0TBM0NH/MmbLnd30/FjWUq4=
github.com/bogdanfinn/fhttp v0.6.3 h1:WtWurH0jbc1X2hOhWckVDiSQPonaU/WwjInB+OwnaCI=
github.com/bogdanfinn/fhttp v0.6.3/go.mod h1:0irhEtS+wJ4m8SGhWO0wmbXMjCbH3WZpU6UcymRYKuk=
github.com/bogdanfinn/quic-go-utls v1.0.4-utls h1:zPjusVVNeJFA2ORMAP0rjnrZrBkV4Dnia4e6ToOfUDA=
github.com/bogdanfinn/quic-go-utls v1.0.4-utls/go.mod h1:UONJOaHGWho08kZtkkgH7GjktEPjMemGxjTcNpVPZVA=
github.com/bogdanfinn/tls-client v1.11.2 h1:o6qX0L1cEi+4MaBqujxqOeK254VZM20t3QR+A34/V6I=
github.com/bogdanfinn/tls-client v1.11.2/go.mod h1:qQIsVGe35NdxYEozNh9JuDZ+aOaOEq2tKAsu2iYEGZg=
github.com/bogdanfinn/utls v1.7.4-barnius h1:1ldNJEpKdkrx7b8hEc6MRkjnZIF8f2lDcTtRVxqY9zw=
github.com/bogdanfinn/utls v1.7.4-barnius/go.mod h1:SUn0CoHGVp/akGNuaqh99yvovu64PCP2LbWd3Z/Laic=
github.com/catppuccin/go v0.3.0 h1:d+0/YicIq+hSTo5oPuRi5kOpqkVA5tAsU6dNhvRu+aY=
github.com/catppuccin/go v0.3.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7 h1:JFgG/xnwFfbezlUnFMJy0nusZvytYysV4SCS2cYbvws=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7/go.mod h1:ISC1gtLcVilLOf23wvTfoQuYbW2q0JevFxPfUzZ9Ybw=
github.com/charmbracelet/bubbletea v1.3.6 h1:VkHIxPJQeDt0aFJIsVxw8BQdh/F/L2KKZGsK6et5taU=
github.com/charmbracelet/bubbletea v1.3.6/go.mod h1:oQD9VCRQFF8KplacJLo28/jofOI2ToOfGYeFgBBxHOc=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/glamour v0.10.0 h1:MtZvfwsYCx8jEPFJm3rIBFIMZUfUJ765oX8V6kXldcY=
github.com/charmbracelet/glamour v0.10.0/go.mod h1:f+uf+I/ChNmqo087elLnVdCiVgjSKWuXa/l6NU2ndYk=
github.com/charmbracelet/huh v0.8.0 h1:Xz/Pm2h64cXQZn/Jvele4J3r7DDiqFCNIVteYukxDvY=
github.com/charmbracelet/huh v0.8.0/go.mod h1:5YVc+SlZ1IhQALxRPpkGwwEKftN/+OlJlnJYlDRFqN4=
github.com/charmbracelet/lipgloss v1.1.1-0.20250404203927-76690c660834 h1:ZR7e0ro+SZZiIZD7msJyA+NjkCNNavuiPBLgerbOziE=
github.com/charmbracelet/lipgloss v1.1.1-0.20250404203927-76690c660834/go.mod h1:aKC/t2arECF6rNOnaKaVU6y4t4ZeHQzqfxedE/VkVhA=
github.com/charmbracelet/x/ansi v0.9.3 h1:BXt5DHS/MKF+LjuK4huWrC6NCvHtexww7dMayh6GXd0=
github.com/charmbracelet/x/ansi v0.9.3/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13 h1:/KBBKHuVRbq1lYx5BzEHBAFBP8VcQzJejZ/IA3iR28k=
github.com/charmbracelet/x/cellbuf v0.0.13/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/conpty v0.1.0 h1:4zc8KaIcbiL4mghEON8D72agYtSeIgq8FSThSPQIb+U=
github.com/charmbracelet/x/conpty v0.1.0/go.mod h1:rMFsDJoDwVmiYM10aD4bH2XiRgwI7NYJtQgl5yskjEQ=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 h1:JSt3B+U9iqk37QUU2Rvb6DSBYRLtWqFqfxf8l5hOZUA=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86/go.mod h1:2P0UgXMEa6TsToMSuFqKFQR+fZTO9CNGUNokkPatT/0=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/exp/slice v0.0.0-20250327172914-2fdc97757edf h1:rLG0Yb6MQSDKdB52aGX55JT1oi0P0Kuaj7wi1bLUpnI=
github.com/charmbracelet/x/exp/slice v0.0.0-20250327172914-2fdc97757edf/go.mod h1:B3UgsnsBZS/eX42BlaNiJkD1pPOUa+oF1IYC6Yd2CEU=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/charmbracelet/x/termios v0.1.1 h1:o3Q2bT8eqzGnGPOYheoYS8eEleT5ZVNYNy8JawjaNZY=
github.com/charmbracelet/x/termios v0.1.1/go.mod h1:rB7fnv1TgOPOyyKRJ9o+AsTU/vK5WHJ2ivHeut/Pcwo=
github.com/charmbracelet/x/xpty v0.1.2 h1:Pqmu4TEJ8KeA9uSkISKMU3f+C1F6OGBn8ABuGlqCbtI=
github.com/charmbracelet/x/xpty v0.1.2/go.mod h1:XK2Z0id5rtLWcpeNiMYBccNNBrP2IJnzHI0Lq13Xzq4=
github.com/cloudflare/circl v1.5.0 h1:hxIWksrX6XN5a1L2TI/h53AGPhNHoUBo+TD1ms9+pys=
github.com/cloudflare/circl v1.5.0/go.mod h1:uddAzsPgqdMAYatqJ0lsjX1oECcQLIlRpzZh3pJrofs=
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/creack/pty v1.1.24 h1:bJrF4RRfyJnbTJqzRLHzcGaZK1NeM5kTC9jGgovnR1s=
github.com/creack/pty v1.1.24/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dlclark/regexp2 v1.11.0 h1:G/nrcoOa7ZXlpoa/91N3X7mM3r8eIlMBBJZvsz/mxKI=
github.com/dlclark/regexp2 v1.11.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=
github.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=
github.com/fsnotify/fsnotify v1.9.0 h1:2Ml+OJNzbYCTzsxtv8vKSFD9PbJjmhYF14k/jKC7S9k=
github.com/fsnotify/fsnotify v1.9.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=
github.com/go-viper/mapstructure/v2 v2.4.0 h1:EBsztssimR/CONLSZZ04E8qAkxNYq4Qp9LvH92wZUgs=
github.com/go-viper/mapstructure/v2 v2.4.0/go.mod h1:oJDH3BJKyqBA2TXFhDsKDGDTlndYOZ6rGS0BRZIxGhM=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/css v1.0.1 h1:ntNaBIghp6JmvWnxbZKANoLyuXTPZ4cAMlo6RyhlbO8=
github.com/gorilla/css v1.0.1/go.mod h1:BvnYkspnSzMmwRK+b8/xgNPLiIuNZr6vbZBTPQ2A3b0=
github.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUqJM=
github.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=
github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
github.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=
github.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.12/go.mod h1:RAqKPSqVFrSLVXbA8x7dzmKdmGzieGRCM46jaSJTDAk=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/microcosm-cc/bluemonday v1.0.27 h1:MpEUotklkwCSLeH+Qdx1VJgNqLlpY2KXwXFM08ygZfk=
github.com/microcosm-cc/bluemonday v1.0.27/go.mod h1:jFi9vgW+H7c3V0lb6nR74Ib/DIB5OBs92Dimizgw2cA=
github.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=
github.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/reflow v0.3.0 h1:IFsN6K9NfGtjeggFP+68I4chLZV2yIKsXJFNZ+eWh6s=
github.com/muesli/reflow v0.3.0/go.mod h1:pbwTDkVPibjO2kyvBQRBxTWEEGDGq0FlB1BIKtnHY/8=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=
github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/quic-go/qpack v0.5.1 h1:giqksBPnT/HDtZ6VhtFKgoLOWmlyo9Ei6u9PqzIMbhI=
github.com/quic-go/qpack v0.5.1/go.mod h1:+PC4XFrEskIVkcLzpEkbLqq1uCoxPhQuvK5rH1ZgaEg=
github.com/rivo/uniseg v0.1.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/sagikazarmark/locafero v0.11.0 h1:1iurJgmM9G3PA/I+wWYIOw/5SyBtxapeHDcg+AAIFXc=
github.com/sagikazarmark/locafero v0.11.0/go.mod h1:nVIGvgyzw595SUSUE6tvCp3YYTeHs15MvlmU87WwIik=
github.com/sourcegraph/conc v0.3.1-0.20240121214520-5f936abd7ae8 h1:+jumHNA0Wrelhe64i8F6HNlS8pkoyMv5sreGx2Ry5Rw=
github.com/sourcegraph/conc v0.3.1-0.20240121214520-5f936abd7ae8/go.mod h1:3n1Cwaq1E1/1lhQhtRK2ts/ZwZEhjcQeJQ1RuC6Q/8U=
github.com/spf13/afero v1.15.0 h1:b/YBCLWAJdFWJTN9cLhiXXcD7mzKn9Dm86dNnfyQw1I=
github.com/spf13/afero v1.15.0/go.mod h1:NC2ByUVxtQs4b3sIUphxK0NioZnmxgyCrfzeuq8lxMg=
github.com/spf13/cast v1.10.0 h1:h2x0u2shc1QuLHfxi+cTJvs30+ZAHOGRic8uyGTDWxY=
github.com/spf13/cast v1.10.0/go.mod h1:jNfB8QC9IA6ZuY2ZjDp0KtFO2LZZlg4S/7bzP6qqeHo=
github.com/spf13/cobra v1.10.1 h1:lJeBwCfmrnXthfAupyUTzJ/J4Nc1RsHC/mSRU2dll/s=
github.com/spf13/cobra v1.10.1/go.mod h1:7SmJGaTHFVBY0jW4NXGluQoLvhqFQM+6XSKD+P4XaB0=
github.com/spf13/pflag v1.0.9/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/pflag v1.0.10 h1:4EBh2KAYBwaONj6b2Ye1GiHfwjqyROoF4RwYO+vPwFk=
github.com/spf13/pflag v1.0.10/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/viper v1.21.0 h1:x5S+0EU27Lbphp4UKm1C+1oQO+rKx36vfCoaVebLFSU=
github.com/spf13/viper v1.21.0/go.mod h1:P0lhsswPGWD/1lZJ9ny3fYnVqxiegrlNrEmgLjbTCAY=
github.com/stretchr/testify v1.11.1 h1:7s2iGBzp5EwR7/aIZr8ao5+dra3wiQyKjjFuvgVKu7U=
github.com/stretchr/testify v1.11.1/go.mod h1:wZwfW3scLgRK+23gO65QZefKpKQRnfz6sD981Nm4B6U=
github.com/subosito/gotenv v1.6.0 h1:9NlTDc1FTs4qu0DDq7AEtTPNw6SVm7uBMsUCUjABIf8=
github.com/subosito/gotenv v1.6.0/go.mod h1:Dk4QP5c2W3ibzajGcXpNraDfq2IrhjMIvMSWPKKo0FU=
github.com/tam7t/hpkp v0.0.0-20160821193359-2b70b4024ed5 h1:YqAladjX7xpA6BM04leXMWAEjS0mTZ5kUU9KRBriQJc=
github.com/tam7t/hpkp v0.0.0-20160821193359-2b70b4024ed5/go.mod h1:2JjD2zLQYH5HO74y5+aE3remJQvl6q4Sn6aWA2wD1Ng=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
github.com/xyproto/randomstring v1.0.5 h1:YtlWPoRdgMu3NZtP45drfy1GKoojuR7hmRcnhZqKjWU=
github.com/xyproto/randomstring v1.0.5/go.mod h1:rgmS5DeNXLivK7YprL0pY+lTuhNQW3iGxZ18UQApw/E=
github.com/yuin/goldmark v1.7.1/go.mod h1:uzxRWxtg69N339t3louHJ7+O03ezfj6PlliRlaOzY1E=
github.com/yuin/goldmark v1.7.8 h1:iERMLn0/QJeHFhxSt3p6PeN9mGnvIKSpG9YYorDMnic=
github.com/yuin/goldmark v1.7.8/go.mod h1:uzxRWxtg69N339t3louHJ7+O03ezfj6PlliRlaOzY1E=
github.com/yuin/goldmark-emoji v1.0.5 h1:EMVWyCGPlXJfUXBXpuMu+ii3TIaxbVBnEX9uaDC4cIk=
github.com/yuin/goldmark-emoji v1.0.5/go.mod h1:tTkZEbwu5wkPmgTcitqddVxY9osFZiavD+r4AzQrh1U=
go.uber.org/mock v0.5.0 h1:KAMbZvZPyBPWgD14IrIQ38QCyjwpvVVV6K/bHl1IwQU=
go.uber.org/mock v0.5.0/go.mod h1:ge71pBPLYDk7QIi1LupWxdAykm7KIEFchiOqd6z7qMM=
go.yaml.in/yaml/v3 v3.0.4 h1:tfq32ie2Jv2UxXFdLJdh3jXuOzWiL1fo0bu/FbuKpbc=
go.yaml.in/yaml/v3 v3.0.4/go.mod h1:DhzuOOF2ATzADvBadXxruRBLzYTpT36CKvDb3+aBEFg=
golang.org/x/crypto v0.40.0 h1:r4x+VvoG5Fm+eJcxMaY8CQM7Lb0l1lsmjGBQ6s8BfKM=
golang.org/x/crypto v0.40.0/go.mod h1:Qr1vMER5WyS2dfPHAlsOj01wgLbsyWtFn/aY+5+ZdxY=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=
golang.org/x/mod v0.26.0 h1:EGMPT//Ezu+ylkCijjPc+f4Aih7sZvaAr+O3EHBxvZg=
golang.org/x/mod v0.26.0/go.mod h1:/j6NAhSk8iQ723BGAUyoAcn7SlD7s15Dp9Nd/SfeaFQ=
golang.org/x/net v0.42.0 h1:jzkYrhi3YQWD6MLBJcsklgQsoAcw89EcZbJw8Z614hs=
golang.org/x/net v0.42.0/go.mod h1:FF1RA5d3u7nAYA4z2TkclSCKh68eSXtiFwcWQpPXdt8=
golang.org/x/sync v0.16.0 h1:ycBJEhp9p4vXvUZNszeOq0kGTPghopOL8q0fq3vstxw=
golang.org/x/sync v0.16.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.34.0 h1:H5Y5sJ2L2JRdyv7ROF1he/lPdvFsd0mJHFw2ThKHxLA=
golang.org/x/sys v0.34.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/term v0.33.0 h1:NuFncQrRcaRvVmgRkvM3j/F00gWIAlcmlB8ACEKmGIg=
golang.org/x/term v0.33.0/go.mod h1:s18+ql9tYWp1IfpV9DmCtQDDSRBUjKaw9M1eAv5UeF0=
golang.org/x/text v0.28.0 h1:rhazDwis8INMIwQ4tpjLDzUhx6RlXqZNPEM0huQojng=
golang.org/x/text v0.28.0/go.mod h1:U8nCwOR8jO/marOQ0QbDiOngZVEBB7MAiitBuMjXiNU=
golang.org/x/tools v0.35.0 h1:mBffYraMEf7aa0sB+NuKnuCy8qI/9Bughn8dC2Gu5r0=
golang.org/x/tools v0.35.0/go.mod h1:NKdj5HkL/73byiZSJjqJgKn3ep7KjFkBOkR/Hps3VPw=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
</file>
<file path="Makefile">
# Perplexity CLI - Makefile
# Build and install commands for the Go CLI

# Variables
BINARY_NAME := perplexity
VERSION := 1.0.0
GIT_COMMIT := $(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
BUILD_DATE := $(shell date -u +"%Y-%m-%dT%H:%M:%SZ")
LDFLAGS := -ldflags "-X main.Version=$(VERSION) -X main.GitCommit=$(GIT_COMMIT) -X main.BuildDate=$(BUILD_DATE)"

# Directories
BUILD_DIR := ./build
GOPATH_BIN := $(shell go env GOPATH)/bin

# Go commands
GOCMD := go
GOBUILD := $(GOCMD) build
GOTEST := $(GOCMD) test
GOCLEAN := $(GOCMD) clean
GOMOD := $(GOCMD) mod

# Platforms for cross-compilation
PLATFORMS := linux/amd64 linux/arm64 darwin/amd64 darwin/arm64 windows/amd64

.PHONY: all build install uninstall clean test test-coverage deps tidy cross-compile help

# Default target
all: build

# Build the binary
build:
	@echo "Building $(BINARY_NAME)..."
	@mkdir -p $(BUILD_DIR)
	$(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME) ./cmd/perplexity
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME)"

# Build optimized release binary
build-release:
	@echo "Building optimized release binary..."
	@mkdir -p $(BUILD_DIR)
	CGO_ENABLED=0 $(GOBUILD) $(LDFLAGS) -trimpath -ldflags "-s -w -X main.Version=$(VERSION) -X main.GitCommit=$(GIT_COMMIT) -X main.BuildDate=$(BUILD_DATE)" -o $(BUILD_DIR)/$(BINARY_NAME) ./cmd/perplexity
	@echo "Release binary built: $(BUILD_DIR)/$(BINARY_NAME)"

# Install to GOPATH/bin
install: build
	@echo "Installing $(BINARY_NAME) to $(GOPATH_BIN)..."
	@mkdir -p $(GOPATH_BIN)
	@cp $(BUILD_DIR)/$(BINARY_NAME) $(GOPATH_BIN)/$(BINARY_NAME)
	@chmod +x $(GOPATH_BIN)/$(BINARY_NAME)
	@echo "Installed: $(GOPATH_BIN)/$(BINARY_NAME)"
	@echo "Run '$(BINARY_NAME) --help' to get started"

# Install to user directory (no sudo required)
install-user: build
	@echo "Installing $(BINARY_NAME) to ~/.local/bin..."
	@mkdir -p ~/.local/bin
	@cp $(BUILD_DIR)/$(BINARY_NAME) ~/.local/bin/$(BINARY_NAME)
	@chmod +x ~/.local/bin/$(BINARY_NAME)
	@echo "Installed: ~/.local/bin/$(BINARY_NAME)"
	@echo "Make sure ~/.local/bin is in your PATH"

# Uninstall from GOPATH/bin
uninstall:
	@echo "Uninstalling $(BINARY_NAME) from $(GOPATH_BIN)..."
	@rm -f $(GOPATH_BIN)/$(BINARY_NAME)
	@echo "Uninstalled $(BINARY_NAME)"

# Uninstall from user directory
uninstall-user:
	@echo "Uninstalling $(BINARY_NAME) from ~/.local/bin..."
	@rm -f ~/.local/bin/$(BINARY_NAME)
	@echo "Uninstalled $(BINARY_NAME)"

# Clean build artifacts
clean:
	@echo "Cleaning..."
	@rm -rf $(BUILD_DIR)
	$(GOCLEAN)
	@echo "Clean complete"

# Run tests
test:
	@echo "Running tests..."
	$(GOTEST) -v ./...

# Run tests with coverage
test-coverage:
	@echo "Running tests with coverage..."
	$(GOTEST) -coverprofile=coverage.out ./...
	$(GOCMD) tool cover -func=coverage.out
	@rm -f coverage.out

# Run tests with HTML coverage report
test-coverage-html:
	@echo "Generating HTML coverage report..."
	$(GOTEST) -coverprofile=coverage.out ./...
	$(GOCMD) tool cover -html=coverage.out -o coverage.html
	@echo "Coverage report: coverage.html"

# Download dependencies
deps:
	@echo "Downloading dependencies..."
	$(GOMOD) download
	@echo "Dependencies downloaded"

# Tidy dependencies
tidy:
	@echo "Tidying dependencies..."
	$(GOMOD) tidy
	@echo "Dependencies tidied"

# Cross-compile for all platforms
cross-compile:
	@echo "Cross-compiling for all platforms..."
	@mkdir -p $(BUILD_DIR)
	@for platform in $(PLATFORMS); do \
		GOOS=$${platform%/*} GOARCH=$${platform#*/} \
		$(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-$${platform%/*}-$${platform#*/}$$(if [ "$${platform%/*}" = "windows" ]; then echo ".exe"; fi) ./cmd/perplexity; \
		echo "Built: $(BUILD_DIR)/$(BINARY_NAME)-$${platform%/*}-$${platform#*/}"; \
	done
	@echo "Cross-compilation complete"

# Build for Linux amd64
build-linux:
	@echo "Building for Linux amd64..."
	@mkdir -p $(BUILD_DIR)
	GOOS=linux GOARCH=amd64 $(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-linux-amd64 ./cmd/perplexity
	@echo "Built: $(BUILD_DIR)/$(BINARY_NAME)-linux-amd64"

# Build for macOS (Apple Silicon)
build-darwin:
	@echo "Building for macOS arm64..."
	@mkdir -p $(BUILD_DIR)
	GOOS=darwin GOARCH=arm64 $(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-darwin-arm64 ./cmd/perplexity
	@echo "Built: $(BUILD_DIR)/$(BINARY_NAME)-darwin-arm64"

# Build for Windows
build-windows:
	@echo "Building for Windows amd64..."
	@mkdir -p $(BUILD_DIR)
	GOOS=windows GOARCH=amd64 $(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-windows-amd64.exe ./cmd/perplexity
	@echo "Built: $(BUILD_DIR)/$(BINARY_NAME)-windows-amd64.exe"

# Run the binary
run: build
	@$(BUILD_DIR)/$(BINARY_NAME) $(ARGS)

# Show version info
version:
	@echo "Version: $(VERSION)"
	@echo "Git Commit: $(GIT_COMMIT)"
	@echo "Build Date: $(BUILD_DATE)"

# Help
help:
	@echo "Perplexity CLI - Makefile Commands"
	@echo ""
	@echo "Usage: make [target]"
	@echo ""
	@echo "Build targets:"
	@echo "  build           Build the binary (default)"
	@echo "  build-release   Build optimized release binary"
	@echo "  cross-compile   Build for all platforms"
	@echo "  build-linux     Build for Linux amd64"
	@echo "  build-darwin    Build for macOS arm64"
	@echo "  build-windows   Build for Windows amd64"
	@echo ""
	@echo "Install targets:"
	@echo "  install         Install to GOPATH/bin"
	@echo "  install-user    Install to ~/.local/bin"
	@echo "  uninstall       Remove from GOPATH/bin"
	@echo "  uninstall-user  Remove from ~/.local/bin"
	@echo ""
	@echo "Test targets:"
	@echo "  test            Run all tests"
	@echo "  test-coverage   Run tests with coverage summary"
	@echo "  test-coverage-html  Generate HTML coverage report"
	@echo ""
	@echo "Other targets:"
	@echo "  clean           Remove build artifacts"
	@echo "  deps            Download dependencies"
	@echo "  tidy            Tidy go.mod"
	@echo "  run ARGS='...'  Build and run with arguments"
	@echo "  version         Show version info"
	@echo "  help            Show this help"
</file>

*(This section may contain "N/A" or be empty if the task is purely conceptual design without an existing codebase.)*
